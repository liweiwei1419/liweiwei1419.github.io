<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://suanfa8.com/</id>
  <title>算法吧</title>
  <subtitle>欢迎来到算法吧</subtitle>
  <author>
    <name>liweiwei1419</name>
  </author>
  <updated>2022-08-08T07:12:37.678Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://suanfa8.com/atom.xml"/>
  <link rel="alternate" href="https://suanfa8.com/"/>
  <category term="排序算法"/>
  <category term="二分查找"/>
  <category term="音乐"/>
  <category term="广度优先遍历"/>
  <category term="算法与数据结构"/>
  <category term="二叉搜索树"/>
  <category term="二叉树"/>
  <category term="二分搜索树"/>
  <category term="并查集"/>
  <category term="位运算"/>
  <category term="栈"/>
  <category term="数学"/>
  <category term="循环不变量"/>
  <category term="前缀和"/>
  <category term="优先队列"/>
  <category term="线段树"/>
  <category term="原地哈希"/>
  <category term="数组"/>
  <category term="字符串"/>
  <category term="分治算法"/>
  <category term="队列"/>
  <contributor>
    <name>liweiwei1419</name>
  </contributor>
  <contributor>
    <name>liwei</name>
  </contributor>
  <entry>
    <title type="html">partition 几种写法比较</title>
    <id>https://suanfa8.com/quick-sort/partition%20%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E6%AF%94%E8%BE%83/</id>
    <link href="https://suanfa8.com/quick-sort/partition%20%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <updated>2022-05-02T05:25:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="partition-几种写法比较"> partition 几种写法比较</h1>
<h2 id="partition-1"> partition 1：</h2>
<p>可能会造成递归树倾斜。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Random</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>int</span> target <span>=</span> len <span>-</span> k<span>;</span>

        <span>int</span> left <span>=</span> <span>0</span><span>;</span>
        <span>int</span> right <span>=</span> len <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
            <span>int</span> pIndex <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>

            <span>if</span> <span>(</span>pIndex <span>==</span> target<span>)</span> <span>{</span>
                <span>return</span> nums<span>[</span>pIndex<span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>pIndex <span>&lt;</span> target<span>)</span> <span>{</span>
                <span>// 下一轮搜索区间 [pIndex + 1, right]</span>
                left <span>=</span> pIndex <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// pIndex > target</span>
                <span>// 下一轮搜索区间 [left, pIndex - 1]</span>
                right <span>=</span> pIndex <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>

    <span>}</span>

    <span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>int</span> pivot <span>=</span> nums<span>[</span>left<span>]</span><span>;</span>

        <span>// [left + 1 .. le] &lt;= pivot</span>
        <span>// (le, i] > pivot</span>
        <span>// 注意点 1：一定要设置成 left ，否则交换会出错</span>
        <span>int</span> le <span>=</span> left<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 这里写 &lt; 或者 &lt;= 都可以</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> pivot<span>)</span> <span>{</span>
                le<span>++</span><span>;</span>
                <span>swap</span><span>(</span>nums<span>,</span> le<span>,</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> le<span>)</span><span>;</span>
        <span>return</span> le<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Random</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>int</span> target <span>=</span> len <span>-</span> k<span>;</span>

        <span>int</span> left <span>=</span> <span>0</span><span>;</span>
        <span>int</span> right <span>=</span> len <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
            <span>int</span> pIndex <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>

            <span>if</span> <span>(</span>pIndex <span>==</span> target<span>)</span> <span>{</span>
                <span>return</span> nums<span>[</span>pIndex<span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>pIndex <span>&lt;</span> target<span>)</span> <span>{</span>
                <span>// 下一轮搜索区间 [pIndex + 1, right]</span>
                left <span>=</span> pIndex <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// pIndex > target</span>
                <span>// 下一轮搜索区间 [left, pIndex - 1]</span>
                right <span>=</span> pIndex <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>

    <span>}</span>

    <span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>// 注意点 2：必须随机化</span>
        <span>int</span> randomIndex <span>=</span> left <span>+</span> random<span>.</span><span>nextInt</span><span>(</span>right <span>-</span> left <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> randomIndex<span>)</span><span>;</span>

        <span>int</span> pivot <span>=</span> nums<span>[</span>left<span>]</span><span>;</span>
        <span>// [left + 1 .. le] &lt;= pivot</span>
        <span>// (le, i] > pivot</span>
        <span>// 注意点 1：一定要设置成 left ，否则交换会出错</span>
        <span>int</span> le <span>=</span> left<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 这里写 &lt; 或者 &lt;= 都可以</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> pivot<span>)</span> <span>{</span>
                le<span>++</span><span>;</span>
                <span>swap</span><span>(</span>nums<span>,</span> le<span>,</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> le<span>)</span><span>;</span>
        <span>return</span> le<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><p><strong>注意</strong>：必须随机化 pivot 元素。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx1n2h60pwj30qa06o3yx.jpg" alt="image.png" loading="lazy"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx1n2xdlplj30q206umxl.jpg" alt="image.png" loading="lazy"></p>
<h2 id="partition-2"> partition 2：</h2>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Random</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> left <span>=</span> <span>0</span><span>;</span>
        <span>int</span> right <span>=</span> len <span>-</span> <span>1</span><span>;</span>

        <span>// 转换一下，第 k 大元素的索引是 len - k</span>
        <span>int</span> target <span>=</span> len <span>-</span> k<span>;</span>

        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
            <span>int</span> index <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>
            <span>if</span> <span>(</span>index <span>==</span> target<span>)</span> <span>{</span>
                <span>return</span> nums<span>[</span>index<span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>index <span>&lt;</span> target<span>)</span> <span>{</span>
                left <span>=</span> index <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                right <span>=</span> index <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>// 在区间随机选择一个元素作为标定点</span>
        <span>int</span> randomIndex <span>=</span> left <span>+</span> random<span>.</span><span>nextInt</span><span>(</span>right <span>-</span> left <span>+</span> <span>1</span> <span>)</span><span>;</span>
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> randomIndex<span>)</span><span>;</span>


        <span>int</span> pivot <span>=</span> nums<span>[</span>left<span>]</span><span>;</span>

        <span>// 将等于 pivot 的元素分散到两边</span>
        <span>// [left, le) &lt;= pivot</span>
        <span>// (ge, right] >= pivot</span>

        <span>int</span> le <span>=</span> left <span>+</span> <span>1</span><span>;</span>
        <span>int</span> ge <span>=</span> right<span>;</span>

        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
            <span>// 遇到 nums[le] >= pivot 的时候停下来</span>
            <span>// 遇到与 pivot 相等的元素，是通过交换被等概率分到两边的</span>
            <span>while</span> <span>(</span>le <span>&lt;=</span> ge <span>&amp;&amp;</span> nums<span>[</span>le<span>]</span> <span>&lt;</span> pivot<span>)</span> <span>{</span>
                le<span>++</span><span>;</span>
            <span>}</span>
            <span>while</span> <span>(</span>le <span>&lt;=</span> ge <span>&amp;&amp;</span> nums<span>[</span>ge<span>]</span> <span>></span> pivot<span>)</span> <span>{</span>
                ge<span>--</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>(</span>le <span>></span> ge<span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>swap</span><span>(</span>nums<span>,</span> le<span>,</span> ge<span>)</span><span>;</span>
            le<span>++</span><span>;</span>
            ge<span>--</span><span>;</span>
        <span>}</span>

        <span>// 这里还要交换，注意是 ge</span>
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> ge<span>)</span><span>;</span>
        <span>return</span> ge<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx1n35tvwdj30qw06sgm0.jpg" alt="image.png" loading="lazy"></p>
<h2 id="补-优先队列写法"> 补：优先队列写法</h2>
<p>思路：看 <code>k</code> 是在前面还是后面。</p>
<ul>
<li>前面，就用最小堆；</li>
<li>后面，就用最大堆。</li>
</ul>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>PriorityQueue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>// 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小</span>
    <span>// 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆</span>
    <span>// 例如在一个有 6 个元素的数组里找第 5 大的元素</span>
    <span>// 思路 2：k 要是更靠近 len 的话，用最小堆</span>

    <span>// 所以分界点就是 k = len - k</span>

    <span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>k <span>&lt;=</span> len <span>-</span> k<span>)</span> <span>{</span>
            <span>// System.out.println("使用最小堆");</span>
            <span>// 特例：k = 1，用容量为 k 的最小堆</span>
            <span>// 使用一个含有 k 个元素的最小堆</span>
            <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> minHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>k<span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> a <span>-</span> b<span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> k<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                minHeap<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>}</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> k<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>// 看一眼，不拿出，因为有可能没有必要替换</span>
                <span>Integer</span> topEle <span>=</span> minHeap<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
                <span>// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span>
                <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>></span> topEle<span>)</span> <span>{</span>
                    minHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                    minHeap<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>return</span> minHeap<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>

        <span>}</span> <span>else</span> <span>{</span>
            <span>// System.out.println("使用最大堆");</span>
            <span>assert</span> k <span>></span> len <span>-</span> k<span>;</span>
            <span>// 特例：k = 100，用容量为 len - k + 1 的最大堆</span>
            <span>int</span> capacity <span>=</span> len <span>-</span> k <span>+</span> <span>1</span><span>;</span>
            <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> maxHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>capacity<span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> b <span>-</span> a<span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> capacity<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                maxHeap<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>}</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> capacity<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>// 看一眼，不拿出，因为有可能没有必要替换</span>
                <span>Integer</span> topEle <span>=</span> maxHeap<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
                <span>// 只要当前遍历的元素比堆顶元素严格小，堆顶弹出，遍历的元素进去</span>
                <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;</span> topEle<span>)</span> <span>{</span>
                    maxHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                    maxHeap<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>return</span> maxHeap<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-05-02T05:25:30.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 4 节 随机选择切分元素</title>
    <id>https://suanfa8.com/quick-sort/random-select-pivot/</id>
    <link href="https://suanfa8.com/quick-sort/random-select-pivot/"/>
    <updated>2022-05-02T05:25:30.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/quick-sort/6-4.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
<ul>
<li>问题：对于顺序数组或者逆序数组来说，递归树高度增加、递归树倾斜；</li>
<li>再提出解决方案：破坏顺序性，随机选择 pivot。</li>
</ul>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Random</span></span><span>;</span>


<span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>final</span> <span>static</span> <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>)</span><span>;</span>
    
    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>sortArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>quickSort</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>return</span> nums<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>quickSort</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>left <span>>=</span> right<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>int</span> pivotIndex <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>
        <span>quickSort</span><span>(</span>nums<span>,</span> left<span>,</span> pivotIndex <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>quickSort</span><span>(</span>nums<span>,</span> pivotIndex <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>// [left..right]</span>
        <span>int</span> randomIndex <span>=</span> left <span>+</span> random<span>.</span><span>nextInt</span><span>(</span>right <span>-</span> left <span>+</span> <span>1</span><span>)</span><span>;</span> 
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> randomIndex<span>)</span><span>;</span>
        
        <span>int</span> pivot <span>=</span> nums<span>[</span>left<span>]</span><span>;</span>

        <span>int</span> j <span>=</span> left <span>+</span> <span>1</span><span>;</span>
        <span>// all in nums[left + 1..j) &lt;= pivot</span>
        <span>// all in nums[j..i) > pivot</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span><span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> pivot<span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> j<span>)</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>return</span> j <span>-</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><hr>
<p>快速排序对于有序的数组并没有那么友好，下面我们具体来分析是一下是怎么回事。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx54ty1hrqj312m0lcmzi.jpg" alt="image-20211207115837429" loading="lazy"></p>
<p>避免这种最坏的情况出现，我们在切分 partition 之前，只需要在待排序的区间里，随机选择一个元素交换到数组的第 1 个位置就可以了，这样，最坏的情况出现的概率就极其低了。</p>
<p>针对特殊测试用例（顺序数组或者逆序数组）一定要随机化选择切分元素（<code>pivot</code>），否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢（等同于冒泡排序或者「选择排序」）。</p>
<h3 id="优化-1-随机选择标定点元素-降低递归树结构不平衡的情况"> 优化 1：随机选择标定点元素，降低递归树结构不平衡的情况</h3>
<p>由于快速排序在近乎有序的时候会非常差，此时递归树的深度会增加。此时快速排序的算法就退化为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span style="margin-right:0.10903em;">N</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span>。</p>
<p>解决办法：我们在每一次迭代开始之前，随机选取一个元素作为基准元素与第 1 个元素交换即可。</p>
<div><pre><code><span>int</span> randomIndex <span>=</span> random<span>.</span><span>nextInt</span><span>(</span>right <span>-</span> left <span>+</span> <span>1</span><span>)</span> <span>+</span> left<span>;</span>
<span>swap</span><span>(</span>arr<span>,</span>left<span>,</span>randomIndex<span>)</span><span>;</span>
<span>int</span> v <span>=</span> arr<span>[</span>left<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="优化-2-小区间使用插入排序"> 优化 2：小区间使用插入排序</h3>
<ul>
<li>在第 1 版快速排序的实现上，结合我们对第 1 版归并排序的讨论，我们可以知道：在待排序区间长度比较短的时候可以使用插入排序来提升排序效率，同样，我们使用 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>16</span></span></span></span> 作为临界值；</li>
<li>测试用例：近乎有序的数组，100 万，归并排序，快速排序。</li>
</ul>
<p><strong>参考代码</strong>：</p>
<p>说明：</p>
<ul>
<li><code>lt</code> 是 <code>less than</code> 的缩写，表示（严格）小于；</li>
<li><code>gt</code> 是 <code>greater than</code> 的缩写，表示（严格）大于；</li>
<li><code>le</code> 是 <code>less than or equal</code> 的缩写，表示小于等于（本代码没有用到）；</li>
<li><code>ge</code> 是 <code>greater than or equal</code> 的缩写，表示大于等于（本代码没有用到）。</li>
</ul>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Random</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>// 快速排序 1：基本快速排序</span>

    <span>/**
     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> INSERTION_SORT_THRESHOLD <span>=</span> <span>7</span><span>;</span>

    <span>private</span> <span>static</span> <span>final</span> <span>Random</span> RANDOM <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>


    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>sortArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>quickSort</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>return</span> nums<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>quickSort</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>// 小区间使用插入排序</span>
        <span>if</span> <span>(</span>right <span>-</span> left <span>&lt;=</span> INSERTION_SORT_THRESHOLD<span>)</span> <span>{</span>
            <span>insertionSort</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>int</span> pIndex <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>
        <span>quickSort</span><span>(</span>nums<span>,</span> left<span>,</span> pIndex <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>quickSort</span><span>(</span>nums<span>,</span> pIndex <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 对数组 nums 的子区间 [left, right] 使用插入排序
     *
     * @param nums  给定数组
     * @param left  左边界，能取到
     * @param right 右边界，能取到
     */</span>
    <span>private</span> <span>void</span> <span>insertionSort</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> temp <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>int</span> j <span>=</span> i<span>;</span>
            <span>while</span> <span>(</span>j <span>></span> left <span>&amp;&amp;</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>></span> temp<span>)</span> <span>{</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
                j<span>--</span><span>;</span>
            <span>}</span>
            nums<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>int</span> randomIndex <span>=</span> RANDOM<span>.</span><span>nextInt</span><span>(</span>right <span>-</span> left <span>+</span> <span>1</span><span>)</span> <span>+</span> left<span>;</span>
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> randomIndex<span>)</span><span>;</span>

        <span>// 基准值</span>
        <span>int</span> pivot <span>=</span> nums<span>[</span>left<span>]</span><span>;</span>
        <span>int</span> lt <span>=</span> left<span>;</span>
        <span>// 循环不变量：</span>
        <span>// all in [left + 1, lt] &lt; pivot</span>
        <span>// all in [lt + 1, i) >= pivot</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;</span> pivot<span>)</span> <span>{</span>
                lt<span>++</span><span>;</span>
                <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> lt<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> lt<span>)</span><span>;</span>
        <span>return</span> lt<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>from</span> sorting<span>.</span>sorting_util <span>import</span> SortingUtil


<span>class</span> <span>QuickSort</span><span>:</span>

    <span>def</span> <span>__str__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>"最基本的快速排序"</span>

    <span>def</span> <span>__partition</span><span>(</span>self<span>,</span> arr<span>,</span> left<span>,</span> right<span>)</span><span>:</span>
        <span>"""对区间 [left, right] （包括左右端点）执行 partition 操作，将 pivot 挪到它最终应该在的位置"""</span>
        pivot <span>=</span> arr<span>[</span>left<span>]</span>
        lt <span>=</span> left
        <span># 循环不变式</span>
        <span># [left, lt - 1] &lt; pivot，初始时，lt - 1 = left - 1</span>
        <span># [lt, i) >= pivot，初始时，[left, left + 1)</span>
        <span># i 的性质在循环开始的时候，不能推测出，我们就是要在循环中保持这个性质</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>left <span>+</span> <span>1</span><span>,</span> right <span>+</span> <span>1</span><span>)</span><span>:</span>
            <span>if</span> arr<span>[</span>i<span>]</span> <span>&lt;</span> pivot<span>:</span>
                lt <span>+=</span> <span>1</span>
                arr<span>[</span>lt<span>]</span><span>,</span> arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>,</span> arr<span>[</span>lt<span>]</span>

        arr<span>[</span>left<span>]</span><span>,</span> arr<span>[</span>lt<span>]</span> <span>=</span> arr<span>[</span>lt<span>]</span><span>,</span> arr<span>[</span>left<span>]</span>
        <span>return</span> lt

    <span>def</span> <span>__quick_sort</span><span>(</span>self<span>,</span> nums<span>,</span> left<span>,</span> right<span>)</span><span>:</span>
        <span>"""在区间 [left, right] （包括左右端点）执行快速排序操作"""</span>
        <span>if</span> left <span>>=</span> right<span>:</span>
            <span>return</span>
        p_index <span>=</span> self<span>.</span>__partition<span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span>
        self<span>.</span>__quick_sort<span>(</span>nums<span>,</span> left<span>,</span> p_index <span>-</span> <span>1</span><span>)</span>
        self<span>.</span>__quick_sort<span>(</span>nums<span>,</span> p_index <span>+</span> <span>1</span><span>,</span> right<span>)</span>

    <span>def</span> <span>sort</span><span>(</span>self<span>,</span> arr<span>)</span><span>:</span>
        size <span>=</span> <span>len</span><span>(</span>arr<span>)</span>
        self<span>.</span>__quick_sort<span>(</span>arr<span>,</span> <span>0</span><span>,</span> size <span>-</span> <span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p>下面我们测试一下刚刚写好的快速排序的代码。测试要点：</p>
<p>1、测试正确性；</p>
<p>2、与归并排序比较；快速排序已经快了一些；</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwzqrghabij315o0hd776.jpg" alt="image.png" loading="lazy"></p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="排序算法" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-05-02T05:25:30.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 8 节 再次理解「循环不变量」</title>
    <id>https://suanfa8.com/quick-sort/review-loop-invariant/</id>
    <link href="https://suanfa8.com/quick-sort/review-loop-invariant/"/>
    <updated>2022-05-02T05:25:30.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/quick-sort/6-8.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="排序算法" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-05-02T05:25:30.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 9 节 再次理解「递归」</title>
    <id>https://suanfa8.com/quick-sort/review-recursion/</id>
    <link href="https://suanfa8.com/quick-sort/review-recursion/"/>
    <updated>2022-05-02T05:25:30.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/quick-sort/6-9.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="排序算法" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-05-02T05:25:30.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 7 节 三种划分方式总结</title>
    <id>https://suanfa8.com/quick-sort/summary-partition/</id>
    <link href="https://suanfa8.com/quick-sort/summary-partition/"/>
    <updated>2022-05-02T05:25:30.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/quick-sort/6-7.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
<p>以下是针对特殊测试用例（有很多重复元素的输入数组）有 3 种版本的快排：</p>
<ul>
<li>版本 1：基本快排：把等于切分元素的所有元素分到了数组的同一侧，可能会造成递归树倾斜；</li>
<li>版本 2：双指针快排：把等于切分元素的所有元素 <strong>等概率</strong> 地分到了数组的两侧，避免了递归树倾斜，递归树相对平衡；</li>
<li>版本 3：三指针快排：把等于切分元素的所有元素挤到了数组的中间，在有很多元素和切分元素相等的情况下，递归区间大大减少。</li>
</ul>
<div><p>经验总结</p>
<p>之所以快排有这些优化，起因都是来自「递归树」的高度。<strong>关于「树」的算法的优化，绝大部分都是在和树的「高度」较劲</strong>。类似的通过减少树高度、使得树更平衡的数据结构还有「二叉搜索树」优化成「AVL 树」或者「红黑树」、「并查集」的「按秩合并」与「路径压缩」。</p>
</div>
<ul>
<li>写对「快速排序」的技巧：保持「循环不变量」，即定义的变量在循环开始前、循环过程中、循环结束以后，都保持不变的性质，这个性质是人为根据问题特点定义的。</li>
<li>「循环不变量」的内容在《算法导论》这本书里有介绍。我个人觉得非常有用。<strong>「循环不变量」是证明算法有效性的基础，更是写对代码的保证，遵守循环不变量，是不是该写等于号，先交换还是先 <code>++</code> ，就会特别清楚，绝对不会写错，我在编码的时候，会将遵守的「循环不变量」作为注释写在代码中</strong>。</li>
</ul>
<p>快速排序丢失了稳定性，如果需要稳定的快速排序，需要具体定义比较函数，这个过程叫「稳定化」，在这里就不展开了。</p>
<p>使用「快速排序」解决的经典问题（非常重要）：</p>
<ul>
<li>TopK 问题：「力扣」第 215 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener noreferrer">数组中的第 K 个最大元素<i>Content not supported</i></a>；</li>
<li>荷兰国旗问题：「力扣」第 75 题：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener noreferrer">颜色分类<i>Content not supported</i></a>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="排序算法" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-05-02T05:25:30.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 1 节 二分查找的基本思想</title>
    <id>https://suanfa8.com/binary-search/videos/01/</id>
    <link href="https://suanfa8.com/binary-search/videos/01/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-1.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 2 节 为什么取中间</title>
    <id>https://suanfa8.com/binary-search/videos/02/</id>
    <link href="https://suanfa8.com/binary-search/videos/02/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-2.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 3 节 把区间分成两个部分（重要）</title>
    <id>https://suanfa8.com/binary-search/videos/03/</id>
    <link href="https://suanfa8.com/binary-search/videos/03/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-3.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 4 节 为什么需要上取整</title>
    <id>https://suanfa8.com/binary-search/videos/04/</id>
    <link href="https://suanfa8.com/binary-search/videos/04/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-4.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 5 节 写分支逻辑的经验</title>
    <id>https://suanfa8.com/binary-search/videos/05/</id>
    <link href="https://suanfa8.com/binary-search/videos/05/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-5.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 6 节 二分查找的应用</title>
    <id>https://suanfa8.com/binary-search/videos/06/</id>
    <link href="https://suanfa8.com/binary-search/videos/06/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-6.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">第 7 节 几种二分查找的写法比较</title>
    <id>https://suanfa8.com/binary-search/videos/07/</id>
    <link href="https://suanfa8.com/binary-search/videos/07/"/>
    <updated>2022-05-02T05:22:07.000Z</updated>
    <content type="html"><![CDATA[<video src="https://suanfa8.com/files/binary-search/6-7.mp4" controls="controls" width="800" height="450">
Your browser does not support the video tag.
</video>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">关于这部分视频的说明</title>
    <id>https://suanfa8.com/binary-search/videos/intro/</id>
    <link href="https://suanfa8.com/binary-search/videos/intro/"/>
    <updated>2022-01-19T17:49:13.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>因为 B 站发视频要有连贯性，中间的一些视频还没有来得及录制。这一系列视频目前（2022 年 1 月 20 日）只在「算法吧」能看到；</li>
<li>「视频部分」和「文字部分」讲的内容是一样的，大家选择自己喜欢的形式阅读就可以。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分查找" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-19T17:49:13.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">音乐欣赏</title>
    <id>https://suanfa8.com/music/</id>
    <link href="https://suanfa8.com/music/"/>
    <updated>2022-01-15T08:53:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="音乐欣赏"> 音乐欣赏</h1>
<p>这部分展示了我经常听的一些歌曲，都是歌唱家现场演唱的经典歌曲哦！</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T08:53:33.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">懂你（演唱：满文军）</title>
    <id>https://suanfa8.com/music/dongni/</id>
    <link href="https://suanfa8.com/music/dongni/"/>
    <updated>2022-01-15T08:53:33.000Z</updated>
    <content type="html"><![CDATA[<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=93580136&bvid=BV1FE411t7Nf&cid=159773338&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=64420610&bvid=BV114411o7mN&cid=111845771&page=1" frameborder="no" scrolling="no"></iframe>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="音乐" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T08:53:33.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">滚滚长江东逝水（电视剧《三国演义》片尾曲，演唱：杨洪基）</title>
    <id>https://suanfa8.com/music/gungunchangjiangdongshishui/</id>
    <link href="https://suanfa8.com/music/gungunchangjiangdongshishui/"/>
    <updated>2022-01-15T08:53:33.000Z</updated>
    <content type="html"><![CDATA[<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=20613348&bvid=BV1VW411s7cc&cid=33723391&page=1" frameborder="no" scrolling="no"></iframe>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="音乐" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T08:53:33.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">历史的天空（电视剧《三国演义》片尾曲，演唱：毛阿敏）</title>
    <id>https://suanfa8.com/music/lishidetiankong/</id>
    <link href="https://suanfa8.com/music/lishidetiankong/"/>
    <updated>2022-01-15T08:53:33.000Z</updated>
    <content type="html"><![CDATA[<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=66427317&bvid=BV1C441117Md&cid=115206567&page=1" frameborder="no" scrolling="no"></iframe>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="音乐" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T08:53:33.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">这一拜（电视剧《三国演义》插曲，演唱：刘欢）</title>
    <id>https://suanfa8.com/music/zheyibai/</id>
    <link href="https://suanfa8.com/music/zheyibai/"/>
    <updated>2022-01-15T08:53:33.000Z</updated>
    <content type="html"><![CDATA[<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=81391110&bvid=BV1TJ411h7pN&cid=139295926&page=1" frameborder="no" scrolling="no"></iframe>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="音乐" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T08:53:33.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 207 题：课程表（中等）</title>
    <id>https://suanfa8.com/breadth-first-search/solutions/0207-course-schedule/</id>
    <link href="https://suanfa8.com/breadth-first-search/solutions/0207-course-schedule/"/>
    <updated>2022-08-08T06:56:56.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener noreferrer">207. 课程表<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">拓扑排序、深度优先遍历<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code>，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例 2：</p>
<div><pre><code>输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 105</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>
</ul>
<hr>
<div><p>提示</p>
<p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</p>
</div>
<p>这道题的做法同样适用于第 210 题。</p>
<h2 id="方法一-拓扑排序-kahn-算法-其实就是广度优先遍历的思路"> 方法一：拓扑排序（Kahn 算法，其实就是广度优先遍历的思路）</h2>
<Presentation id="presentation-382ee21f" data-code="%0A!%5B207-1.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2Fe6c9d24egy1h2tpb025nej21hc0u0aej.jpg)%0A%0A---%0A%0A!%5B207-2.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxc0uapuj31hc0u0q5m.jpg)%0A%0A---%0A%0A!%5B207-3.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxc4h72sj31hc0u0n0p.jpg)%0A%0A---%0A%0A!%5B207-4.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxc8667gj31hc0u0n0b.jpg)%0A%0A---%0A%0A!%5B207-5.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxcaj4ptj31hc0u0n0p.jpg)%0A%0A---%0A%0A!%5B207-6.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxcenyrzj31hc0u041l.jpg)%0A%0A---%0A%0A!%5B207-7.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxcctfddj31hc0u0tc4.jpg)%0A%0A---%0A%0A!%5B207-8.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxcjsbfbj31hc0u0whg.jpg)%0A%0A---%0A%0A!%5B207-9.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxcl5w3mj31hc0u0q60.jpg)%0A%0A---%0A%0A!%5B207-10.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxcojuoij31hc0u0dij.jpg)%0A%0A---%0A%0A!%5B207-11.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxd4l5sjj31hc0u0jtu.jpg)%0A%0A---%0A%0A!%5B207-12.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxd094alj31hc0u076b.jpg)%0A%0A---%0A%0A!%5B207-13.png%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxrxazlwo9j31hc0u0jvv.jpg)%0A" theme="auto"></Presentation><p>拓扑排序实际上应用的是<strong>贪心算法</strong>。贪心算法简而言之：每一步最优，全局就最优。</p>
<p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点，并移除它、修改它指向的结点的入度（<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>−</span><span>1</span></span></span></span>即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p>
<p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有 AOV 网，这里就不展开了。</p>
<p><strong>算法流程</strong>：</p>
<p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点放入队列。</p>
<p>2、只要队列非空，就从队首取出入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>，在减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 以后，如果这个被减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的结点的入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> ，就继续入队。</p>
<p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p>
<p>思考这里为什么要使用队列？（马上就会给出答案。）</p>
<p>在代码具体实现的时候，除了保存入度为 0 的队列，我们还需要两个辅助的数据结构：</p>
<p>1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；</p>
<p>2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。</p>
<p>这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。</p>
<p><strong>参考代码 1</strong>：</p>
<p>这里感谢 <a href="/u/johnny_mu-yun/">@johnny_mu-yun</a> 朋友的提醒，其实之前也有多位朋友提醒过我 Java 代码写得有问题，我现在才把它改对（2020 年 1 月 22 日）。</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>canFinish</span><span>(</span><span>int</span> numCourses<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> prerequisites<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>numCourses <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>// 特判</span>
        <span>int</span> pLen <span>=</span> prerequisites<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>pLen <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>int</span><span>[</span><span>]</span> inDegree <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
        <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> adj <span>=</span> <span>new</span> <span>HashSet</span><span>[</span>numCourses<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            adj<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> p <span>:</span> prerequisites<span>)</span> <span>{</span>
            inDegree<span>[</span>p<span>[</span><span>0</span><span>]</span><span>]</span><span>++</span><span>;</span>
            adj<span>[</span>p<span>[</span><span>1</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>p<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

        <span>// 首先加入入度为 0 的结点</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>inDegree<span>[</span>i<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                queue<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>// 记录已经出队的课程数量</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Integer</span> top <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            cnt <span>+=</span> <span>1</span><span>;</span>
            <span>// 遍历当前出队结点的所有后继结点</span>
            <span>for</span> <span>(</span><span>int</span> successor <span>:</span> adj<span>[</span>top<span>]</span><span>)</span> <span>{</span>
                inDegree<span>[</span>successor<span>]</span><span>--</span><span>;</span>
                <span>if</span> <span>(</span>inDegree<span>[</span>successor<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>add</span><span>(</span>successor<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> cnt <span>==</span> numCourses<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>from</span> typing <span>import</span> List
<span>from</span> collections <span>import</span> deque

<span>class</span> <span>Solution</span><span>:</span>

    <span># 思想：该方法的每一步总是输出当前无前趋（即入度为零）的顶点</span>

    <span>def</span> <span>canFinish</span><span>(</span>self<span>,</span> numCourses<span>:</span> <span>int</span><span>,</span> prerequisites<span>:</span> List<span>[</span>List<span>[</span><span>int</span><span>]</span><span>]</span><span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """</span>
        <span># 课程的长度</span>
        clen <span>=</span> <span>len</span><span>(</span>prerequisites<span>)</span>
        <span>if</span> clen <span>==</span> <span>0</span><span>:</span>
            <span># 没有课程，当然可以完成课程的学习</span>
            <span>return</span> <span>True</span>

        <span># 步骤1：统计每个顶点的入度</span>
        <span># 入度数组，记录了指向它的结点的个数，一开始全部为 0</span>
        in_degrees <span>=</span> <span>[</span><span>0</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span># 邻接表，使用散列表是为了去重</span>
        adj <span>=</span> <span>[</span><span>set</span><span>(</span><span>)</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>

        <span># 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</span>
        <span># [0, 1] 表示 1 在先，0 在后</span>
        <span># 注意：邻接表存放的是后继 successor 结点的集合</span>
        <span>for</span> second<span>,</span> first <span>in</span> prerequisites<span>:</span>
            in_degrees<span>[</span>second<span>]</span> <span>+=</span> <span>1</span>
            adj<span>[</span>first<span>]</span><span>.</span>add<span>(</span>second<span>)</span>

        <span># 步骤2：拓扑排序开始之前，先把所有入度为 0 的结点加入到一个队列中</span>
        <span># 首先遍历一遍，把所有入度为 0 的结点都加入队列</span>
        queue <span>=</span> deque<span>(</span><span>)</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>:</span>
            <span>if</span> in_degrees<span>[</span>i<span>]</span> <span>==</span> <span>0</span><span>:</span>
                queue<span>.</span>append<span>(</span>i<span>)</span>

        counter <span>=</span> <span>0</span>
        <span>while</span> queue<span>:</span>
            top <span>=</span> queue<span>.</span>popleft<span>(</span><span>)</span>
            counter <span>+=</span> <span>1</span>
            <span># 步骤3：把这个结点的所有后继结点的入度减去 1，如果发现入度为 0 ，就马上添加到队列中</span>
            <span>for</span> successor <span>in</span> adj<span>[</span>top<span>]</span><span>:</span>
                in_degrees<span>[</span>successor<span>]</span> <span>-=</span> <span>1</span>
                <span>if</span> in_degrees<span>[</span>successor<span>]</span> <span>==</span> <span>0</span><span>:</span>
                    queue<span>.</span>append<span>(</span>successor<span>)</span>

        <span>return</span> counter <span>==</span> numCourses
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>。这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.05764em;">E</span></span></span></span> 表示邻边的条数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span> 表示结点的个数。初始化入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的集合需要遍历整张图，具体做法是检查每个结点和每条边，因此复杂度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>，然后对该集合进行操作，又需要遍历整张图中的每个结点和每条边，复杂度也为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>：邻接表长度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span>，每个课程里又保存了它所有的边。</li>
</ul>
<p>这里回答一下使用队列的问题，如果不使用队列，要想得到当前入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点，就得遍历一遍入度数组。使用队列即用空间换时间。</p>
<h2 id="方法二-深度优先遍历-参考"> 方法二：深度优先遍历（参考）</h2>
<p>提示：这部分内容不重要，掌握上面的「广度优先遍历 + 贪心」的思想是常考的，重要的知识点。</p>
<p>说明：深度优先遍历的思路有 2 个。</p>
<ol>
<li>首先检测是否存在环，然后使用「深度优先遍历」，在「后序」的部分把课程添加到结果集，然后再逆序，就是「拓扑排序」的结果（没有提供参考代码）；</li>
<li>在深度优先遍历的过程中，设置个别有特殊意义的变量，通过这些变量得到「拓扑排序」的结果（下面提供了参考代码）。</li>
</ol>
<p>这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。</p>
<p>具体方法是：</p>
<p>第 1 步：构建逆邻接表；</p>
<p>第 2 步：递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，<strong>先输出指向它的所有顶点，再输出自己</strong>。</p>
<p>第 3 步：如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：<strong>当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止</strong>。</p>
<p><strong>参考代码 2</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>canFinish</span><span>(</span><span>int</span> numCourses<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> prerequisites<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>numCourses <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>int</span> plen <span>=</span> prerequisites<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>plen <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>int</span><span>[</span><span>]</span> marked <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>

        <span>// 初始化有向图 begin</span>
        <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graph <span>=</span> <span>new</span> <span>HashSet</span><span>[</span>numCourses<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            graph<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 初始化有向图 end</span>
        <span>// 有向图的 key 是前驱结点，value 是后继结点的集合</span>
        <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> p <span>:</span> prerequisites<span>)</span> <span>{</span>
            graph<span>[</span>p<span>[</span><span>1</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>p<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>dfs</span><span>(</span>i<span>,</span> graph<span>,</span> marked<span>)</span><span>)</span> <span>{</span>
                <span>// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span>
        <span>// 所有课程任务可以完成，应该返回 true</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * 注意这个 dfs 方法的语义
     * @param i      当前访问的课程结点
     * @param graph
     * @param marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了
     * @return true 表示图中存在环，false 表示访问过了，不用再访问了
     */</span>
    <span>private</span> <span>boolean</span> <span>dfs</span><span>(</span><span>int</span> i<span>,</span>
                        <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graph<span>,</span>
                        <span>int</span><span>[</span><span>]</span> marked<span>)</span> <span>{</span>
        <span>// 如果访问过了，就不用再访问了</span>
        <span>if</span> <span>(</span>marked<span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>// 从正在访问中，到正在访问中，表示遇到了环</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>marked<span>[</span>i<span>]</span> <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>// 表示在访问的过程中没有遇到环，这个节点访问过了</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>// 走到这里，是因为初始化呢，此时 marked[i] == 0</span>
        <span>// 表示正在访问中</span>
        marked<span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>// 后继结点的集合</span>
        <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span> successorNodes <span>=</span> graph<span>[</span>i<span>]</span><span>;</span>

        <span>for</span> <span>(</span><span>Integer</span> successor <span>:</span> successorNodes<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>dfs</span><span>(</span>successor<span>,</span> graph<span>,</span> marked<span>)</span><span>)</span> <span>{</span>
                <span>// 层层递归返回 true ，表示图中存在环</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>
        <span>// 状态设置为 2</span>
        marked<span>[</span>i<span>]</span> <span>=</span> <span>2</span><span>;</span>
        <span>// false 表示图中不存在环</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span># 这里使用逆邻接表</span>

    <span>def</span> <span>canFinish</span><span>(</span>self<span>,</span> numCourses<span>:</span> <span>int</span><span>,</span> prerequisites<span>:</span> List<span>[</span>List<span>[</span><span>int</span><span>]</span><span>]</span><span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """</span>
        <span># 课程的长度</span>
        clen <span>=</span> <span>len</span><span>(</span>prerequisites<span>)</span>
        <span>if</span> clen <span>==</span> <span>0</span><span>:</span>
            <span># 没有课程，当然可以完成课程的学习</span>
            <span>return</span> <span>True</span>
        <span># 深度优先遍历，判断结点是否访问过</span>
        <span># 这里要设置 3 个状态</span>
        <span># 0 就对应 False ，表示结点没有访问过</span>
        <span># 1 就对应 True ，表示结点已经访问过，在深度优先遍历结束以后才置为 1</span>
        <span># 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，</span>
        <span># 有遇到状态为 2 的结点，就表示这个图中存在环</span>
        visited <span>=</span> <span>[</span><span>0</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>

        <span># 逆邻接表，存的是每个结点的前驱结点的集合</span>
        <span># 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</span>
        <span># 1 在前，0 在后</span>
        inverse_adj <span>=</span> <span>[</span><span>set</span><span>(</span><span>)</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span>for</span> second<span>,</span> first <span>in</span> prerequisites<span>:</span>
            inverse_adj<span>[</span>second<span>]</span><span>.</span>add<span>(</span>first<span>)</span>

        <span>for</span> i <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>:</span>
            <span># 在遍历的过程中，如果发现有环，就退出</span>
            <span>if</span> self<span>.</span>__dfs<span>(</span>i<span>,</span> inverse_adj<span>,</span> visited<span>)</span><span>:</span>
                <span>return</span> <span>False</span>
        <span>return</span> <span>True</span>

    <span>def</span> <span>__dfs</span><span>(</span>self<span>,</span> vertex<span>,</span> inverse_adj<span>,</span> visited<span>)</span><span>:</span>
        <span>"""
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环，返回 True 表示这个有向图有环
        """</span>
        <span># 2 表示这个结点正在访问</span>
        <span>if</span> visited<span>[</span>vertex<span>]</span> <span>==</span> <span>2</span><span>:</span>
            <span># 表示遇到环</span>
            <span>return</span> <span>True</span>
        <span>if</span> visited<span>[</span>vertex<span>]</span> <span>==</span> <span>1</span><span>:</span>
            <span>return</span> <span>False</span>

        visited<span>[</span>vertex<span>]</span> <span>=</span> <span>2</span>
        <span>for</span> precursor <span>in</span> inverse_adj<span>[</span>vertex<span>]</span><span>:</span>
            <span># 如果有环，就返回 True 表示有环</span>
            <span>if</span> self<span>.</span>__dfs<span>(</span>precursor<span>,</span> inverse_adj<span>,</span> visited<span>)</span><span>:</span>
                <span>return</span> <span>True</span>

        <span># 1 表示访问结束</span>
        <span># 先把 vertex 这个结点的所有前驱结点都输出之后，再输出自己</span>
        visited<span>[</span>vertex<span>]</span> <span>=</span> <span>1</span>
        <span>return</span> <span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:25.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 210 题：课程表 II（中等）</title>
    <id>https://suanfa8.com/breadth-first-search/solutions/0210-course-schedule-ii/</id>
    <link href="https://suanfa8.com/breadth-first-search/solutions/0210-course-schedule-ii/"/>
    <updated>2022-01-15T07:10:25.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener noreferrer">210. 课程表 II<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/tuo-bu-pai-xu-shen-du-you-xian-bian-li-python-dai-/" target="_blank" rel="noopener noreferrer">拓扑排序（广度优先遍历） + 深度优先遍历（Java、Python）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</p>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：numCourses = 1, prerequisites = []
输出：[0]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>ai != bi</code></li>
<li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li>
</ul>
<div><p>提示</p>
<p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</p>
</div>
<div><p>先说最重要的部分</p>
<ul>
<li>「拓扑排序」是专门应用于有向图的算法；</li>
<li>这道题用 BFS 和 DFS 都可以完成，只需要掌握 BFS 的写法就可以了，BFS 的写法很经典；</li>
<li>BFS 的写法就叫「拓扑排序」，这里还用到了贪心算法的思想，贪的点是：当前让入度为 0 的那些结点入队；</li>
<li>「拓扑排序」的结果不唯一；</li>
<li>删除结点的操作，通过「入度数组」体现，这个技巧要掌握；</li>
<li>「拓扑排序」的一个附加效果是：<strong>能够顺带检测有向图中是否存在环</strong>，这个知识点非常重要，如果在面试的过程中遇到这个问题，要把这一点说出来。
<ul>
<li>具有类似附加功能的算法还有：Bellman-Ford 算法附加的作用是可以用于检测是否有负权环（在这里不展开了，我也不太熟）。
:::</li>
</ul>
</li>
</ul>
<h2 id="方法一-拓扑排序-kahn-算法、类似广度优先遍历的思路"> 方法一：拓扑排序（Kahn 算法、类似广度优先遍历的思路）</h2>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxrxexgdv0g31hc0u0777.gif" alt="0210.gif" loading="lazy"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxrxezmch5j31hc0u0jvv.jpg" alt="207-1.png" loading="lazy"></p>
<p>如果优先图中，存在环，拓扑排序不能继续得到入度值为 0 的节点，退出循环，此时图中存在没有遍历到的节点，说明图中存在环。</p>
<p>此时说明课程设计不合理，有循环依赖。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxrxf378nyj31hc0u0dip.jpg" alt="207-13.png" loading="lazy"></p>
<p>拓扑排序实际上应用的是贪心算法，贪心算法简而言之：每一步最优，则全局最优。</p>
<p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点，并移除它、修改它指向的结点的入度（<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>−</span><span>1</span></span></span></span>即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p>
<p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有 AOV 网，这里就不展开了。</p>
<p><strong>算法流程</strong>：</p>
<p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点放入队列。</p>
<p>2、只要队列非空，就从队首取出入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>，在减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 以后，如果这个被减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的结点的入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> ，就继续入队。</p>
<p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p>
<p>（思考这里为什么要使用队列？如果不用队列，还可以怎么做，会比用队列的效果差还是更好？）</p>
<p>在代码具体实现的时候，除了保存入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的队列，我们还需要两个辅助的数据结构：</p>
<p>1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；</p>
<p>2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。</p>
<p>这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。</p>
<p><strong>参考代码 1</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>findOrder</span><span>(</span><span>int</span> numCourses<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> prerequisites<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>numCourses <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>;</span>
        <span>}</span>

        <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> adj <span>=</span> <span>new</span> <span>HashSet</span><span>[</span>numCourses<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            adj<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>// [1,0] 0 -> 1</span>
        <span>int</span><span>[</span><span>]</span> inDegree <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> p <span>:</span> prerequisites<span>)</span> <span>{</span>
            adj<span>[</span>p<span>[</span><span>1</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>p<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
            inDegree<span>[</span>p<span>[</span><span>0</span><span>]</span><span>]</span><span>++</span><span>;</span>
        <span>}</span>

        <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>inDegree<span>[</span>i<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                queue<span>.</span><span>offer</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>int</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
        <span>// 当前结果集列表里的元素个数，正好可以作为下标</span>
        <span>int</span> count <span>=</span> <span>0</span><span>;</span>

        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>// 当前入度为 0 的结点</span>
            <span>Integer</span> head <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            res<span>[</span>count<span>]</span> <span>=</span> head<span>;</span>
            count<span>++</span><span>;</span>

            <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> successors <span>=</span> adj<span>[</span>head<span>]</span><span>;</span>
            <span>for</span> <span>(</span><span>Integer</span> nextCourse <span>:</span> successors<span>)</span> <span>{</span>
                inDegree<span>[</span>nextCourse<span>]</span><span>--</span><span>;</span>
                <span>// 马上检测该结点的入度是否为 0，如果为 0，马上加入队列</span>
                <span>if</span> <span>(</span>inDegree<span>[</span>nextCourse<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>offer</span><span>(</span>nextCourse<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>// 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span>
        <span>if</span> <span>(</span>count <span>==</span> numCourses<span>)</span> <span>{</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>findOrder</span><span>(</span>self<span>,</span> numCourses<span>,</span> prerequisites<span>)</span><span>:</span>
        <span>"""
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """</span>
        <span># 课程的长度</span>
        clen <span>=</span> <span>len</span><span>(</span>prerequisites<span>)</span>
        <span>if</span> clen <span>==</span> <span>0</span><span>:</span>
            <span># 没有课程，当然可以完成课程的学习</span>
            <span>return</span> <span>[</span>i <span>for</span> i <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span># 入度数组，一开始全部为 0</span>
        in_degrees <span>=</span> <span>[</span><span>0</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span># 邻接表</span>
        adj <span>=</span> <span>[</span><span>set</span><span>(</span><span>)</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span># 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</span>
        <span># 1 -> 0，这里要注意：不要弄反了</span>
        <span>for</span> second<span>,</span> first <span>in</span> prerequisites<span>:</span>
            in_degrees<span>[</span>second<span>]</span> <span>+=</span> <span>1</span>
            adj<span>[</span>first<span>]</span><span>.</span>add<span>(</span>second<span>)</span>

        <span># print("in_degrees", in_degrees)</span>
        <span># 首先遍历一遍，把所有入度为 0 的结点加入队列</span>
        res <span>=</span> <span>[</span><span>]</span>
        queue <span>=</span> <span>[</span><span>]</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>:</span>
            <span>if</span> in_degrees<span>[</span>i<span>]</span> <span>==</span> <span>0</span><span>:</span>
                queue<span>.</span>append<span>(</span>i<span>)</span>

        <span>while</span> queue<span>:</span>
            top <span>=</span> queue<span>.</span>pop<span>(</span><span>0</span><span>)</span>
            res<span>.</span>append<span>(</span>top<span>)</span>

            <span>for</span> successor <span>in</span> adj<span>[</span>top<span>]</span><span>:</span>
                in_degrees<span>[</span>successor<span>]</span> <span>-=</span> <span>1</span>
                <span>if</span> in_degrees<span>[</span>successor<span>]</span> <span>==</span> <span>0</span><span>:</span>
                    queue<span>.</span>append<span>(</span>successor<span>)</span>
        <span>if</span> <span>len</span><span>(</span>res<span>)</span> <span>!=</span> numCourses<span>:</span>
            <span>return</span> <span>[</span><span>]</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>。这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.05764em;">E</span></span></span></span> 表示邻边的条数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span> 表示结点的个数。初始化入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的集合需要遍历整张图，具体做法是检查每个结点和每条边，因此复杂度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>，然后对该集合进行操作，又需要遍历整张图中的每个结点和每条边，复杂度也为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>：入度数组、邻接表的长度都是结点的个数 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span>，即使使用队列，队列最长的时候也不会超过 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span>，因此空间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>。</li>
</ul>
<h2 id="方法二-深度优先遍历-不用掌握-因为要检测环-代码中会做一些处理-代码没有参考价值"> 方法二：深度优先遍历（不用掌握，因为要检测环，代码中会做一些处理，代码没有参考价值）</h2>
<p>这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。</p>
<p><strong>算法流程</strong>：</p>
<p>第 1 步：构建逆邻接表；</p>
<p>第 2 步：递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，<strong>先输出指向它的所有顶点，再输出自己</strong>。</p>
<p>第 3 步：如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：<strong>当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止</strong>。</p>
<p><strong>参考代码 2</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Stack</span></span><span>;</span>

<span>/</span>\<span>*</span>\<span>*</span>

<span>-</span> <span>@author</span> liwei
<span>-</span> <span>@date</span> <span>18</span><span>/</span><span>6</span><span>/</span><span>24</span> 下午 <span>4</span><span>:</span><span>10</span>
  \<span>*</span><span>/</span>
  <span>public</span> <span>class</span> <span>Solution3</span> <span>{</span>

      <span>/**
       * @param numCourses
       * @param prerequisites
       * @return
       */</span>
      <span>public</span> <span>int</span><span>[</span><span>]</span> <span>findOrder</span><span>(</span><span>int</span> numCourses<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> prerequisites<span>)</span> <span>{</span>
          <span>if</span> <span>(</span>numCourses <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
              <span>// 连课程数目都没有，就根本没有办法完成练习了，根据题意应该返回空数组</span>
              <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>;</span>
          <span>}</span>
          <span>int</span> plen <span>=</span> prerequisites<span>.</span>length<span>;</span>
          <span>if</span> <span>(</span>plen <span>==</span> <span>0</span><span>)</span> <span>{</span>
              <span>// 没有有向边，则表示不存在课程依赖，任务一定可以完成</span>
              <span>int</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
              <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                  ret<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
              <span>}</span>
              <span>return</span> ret<span>;</span>
          <span>}</span>
          <span>int</span><span>[</span><span>]</span> marked <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
          <span>// 初始化有向图 begin</span>
          <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graph <span>=</span> <span>new</span> <span>HashSet</span><span>[</span>numCourses<span>]</span><span>;</span>
          <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
              graph<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
          <span>}</span>
          <span>// 初始化有向图 end</span>
          <span>// 有向图的 key 是前驱结点，value 是后继结点的集合</span>
          <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> p <span>:</span> prerequisites<span>)</span> <span>{</span>
              graph<span>[</span>p<span>[</span><span>1</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>p<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
          <span>}</span>
          <span>// 使用 Stack 或者 List 记录递归的顺序，这里使用 Stack</span>
          <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
          <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
              <span>if</span> <span>(</span><span>dfs</span><span>(</span>i<span>,</span> graph<span>,</span> marked<span>,</span> stack<span>)</span><span>)</span> <span>{</span>
                  <span>// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回空数组</span>
                  <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>;</span>
              <span>}</span>
          <span>}</span>
          <span>// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span>
          <span>// 所有课程任务可以完成，应该返回 true</span>
          <span>// 下面这个断言一定成立，这是拓扑排序告诉我们的结论</span>
          <span>assert</span> stack<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> numCourses<span>;</span>
          <span>int</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
          <span>// 想想要怎么得到结论，我们的 dfs 是一致将后继结点进行 dfs 的</span>
          <span>// 所以压在栈底的元素，一定是那个没有后继课程的结点</span>
          <span>// 那个没有前驱的课程，一定在栈顶，所以课程学习的顺序就应该是从栈顶到栈底</span>
          <span>// 依次出栈就好了</span>
          <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
              ret<span>[</span>i<span>]</span> <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
          <span>}</span>
          <span>return</span> ret<span>;</span>
      <span>}</span>

      <span>/**
       * 注意这个 dfs 方法的语义
       *
       * @param i      当前访问的课程结点
       * @param graph
       * @param marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了
       * @return true 表示图中存在环，false 表示访问过了，不用再访问了
       */</span>
      <span>private</span> <span>boolean</span> <span>dfs</span><span>(</span><span>int</span> i<span>,</span>
                          <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graph<span>,</span>
                          <span>int</span><span>[</span><span>]</span> marked<span>,</span>
                          <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack<span>)</span> <span>{</span>
          <span>// 如果访问过了，就不用再访问了</span>
          <span>if</span> <span>(</span>marked<span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
              <span>// 从正在访问中，到正在访问中，表示遇到了环</span>
              <span>return</span> <span>true</span><span>;</span>
          <span>}</span>
          <span>if</span> <span>(</span>marked<span>[</span>i<span>]</span> <span>==</span> <span>2</span><span>)</span> <span>{</span>
              <span>// 表示在访问的过程中没有遇到环，这个节点访问过了</span>
              <span>return</span> <span>false</span><span>;</span>
          <span>}</span>
          <span>// 走到这里，是因为初始化呢，此时 marked[i] == 0</span>
          <span>// 表示正在访问中</span>
          marked<span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>
          <span>// 后继结点的集合</span>
          <span>HashSet</span><span><span>&lt;</span><span>Integer</span><span>></span></span> successorNodes <span>=</span> graph<span>[</span>i<span>]</span><span>;</span>
          <span>for</span> <span>(</span><span>Integer</span> successor <span>:</span> successorNodes<span>)</span> <span>{</span>
              <span>if</span> <span>(</span><span>dfs</span><span>(</span>successor<span>,</span> graph<span>,</span> marked<span>,</span> stack<span>)</span><span>)</span> <span>{</span>
                  <span>// 层层递归返回 true ，表示图中存在环</span>
                  <span>return</span> <span>true</span><span>;</span>
              <span>}</span>
          <span>}</span>
          <span>// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span>
          <span>// 状态设置为 2</span>
          marked<span>[</span>i<span>]</span> <span>=</span> <span>2</span><span>;</span>
          stack<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
          <span>// false 表示图中不存在环</span>
          <span>return</span> <span>false</span><span>;</span>
      <span>}</span>

  <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>findOrder</span><span>(</span>self<span>,</span> numCourses<span>,</span> prerequisites<span>)</span><span>:</span>
        <span>"""
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """</span>
        <span># 课程的长度</span>
        clen <span>=</span> <span>len</span><span>(</span>prerequisites<span>)</span>
        <span>if</span> clen <span>==</span> <span>0</span><span>:</span>
            <span># 没有课程，当然可以完成课程的学习</span>
            <span>return</span> <span>[</span>i <span>for</span> i <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>

        <span># 逆邻接表</span>
        inverse_adj <span>=</span> <span>[</span><span>set</span><span>(</span><span>)</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span># 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</span>
        <span># 1 -> 0，这里要注意：不要弄反了</span>
        <span>for</span> second<span>,</span> first <span>in</span> prerequisites<span>:</span>
            inverse_adj<span>[</span>second<span>]</span><span>.</span>add<span>(</span>first<span>)</span>

        visited <span>=</span> <span>[</span><span>0</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>]</span>
        <span># print("in_degrees", in_degrees)</span>
        <span># 首先遍历一遍，把所有入度为 0 的结点加入队列</span>

        res <span>=</span> <span>[</span><span>]</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>numCourses<span>)</span><span>:</span>
            <span>if</span> self<span>.</span>__dfs<span>(</span>i<span>,</span>inverse_adj<span>,</span> visited<span>,</span> res<span>)</span><span>:</span>
                <span>return</span> <span>[</span><span>]</span>
        <span>return</span> res

    <span>def</span> <span>__dfs</span><span>(</span>self<span>,</span> vertex<span>,</span> inverse_adj<span>,</span> visited<span>,</span> res<span>)</span><span>:</span>
        <span>"""
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """</span>
        <span># 2 表示这个结点正在访问</span>
        <span>if</span> visited<span>[</span>vertex<span>]</span> <span>==</span> <span>2</span><span>:</span>
            <span># DFS 的时候如果遇到一样的结点，就表示图中有环，课程任务便不能完成</span>
            <span>return</span> <span>True</span>
        <span>if</span> visited<span>[</span>vertex<span>]</span> <span>==</span> <span>1</span><span>:</span>
            <span>return</span> <span>False</span>
        <span># 表示正在访问这个结点</span>
        visited<span>[</span>vertex<span>]</span> <span>=</span> <span>2</span>
        <span># 递归访问前驱结点</span>
        <span>for</span> precursor <span>in</span> inverse_adj<span>[</span>vertex<span>]</span><span>:</span>
            <span># 如果没有环，就返回 False，</span>
            <span># 执行以后，逆拓扑序列就存在 res 中</span>
            <span>if</span> self<span>.</span>__dfs<span>(</span>precursor<span>,</span> inverse_adj<span>,</span> visited<span>,</span> res<span>)</span><span>:</span>
                <span>return</span> <span>True</span>

        <span># 能走到这里，说明所有的前驱结点都访问完了，所以可以输出了</span>
        <span># 并且将这个结点状态置为 1</span>
        visited<span>[</span>vertex<span>]</span> <span>=</span> <span>1</span>

        <span># 先把 vertex 这个结点的所有前驱结点都输出之后，再输出自己</span>
        res<span>.</span>append<span>(</span>vertex<span>)</span>
        <span># 最后不要忘记返回 False 表示无环</span>
        <span>return</span> <span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.05764em;">E</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span>)</span></span></span></span>。</li>
</ul>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:25.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 310 题：最小高度树（中等）</title>
    <id>https://suanfa8.com/breadth-first-search/solutions/0310-minimum-height-trees/</id>
    <link href="https://suanfa8.com/breadth-first-search/solutions/0310-minimum-height-trees/"/>
    <updated>2022-08-08T06:56:56.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener noreferrer">310. 最小高度树<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/minimum-height-trees/solution/tan-xin-fa-gen-ju-tuo-bu-pai-xu-de-si-lu-python-da/" target="_blank" rel="noopener noreferrer">拓扑排序（广度优先遍历，Java、Python）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p>
<p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。</p>
<p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即，<code>min(h)</code>）被称为 <strong>最小高度树</strong> 。</p>
<p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p>
<p>树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpbl2kjej211u0a274y.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpbnubzkj20ru0b6t98.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：n = 1, edges = []
输出：[0]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：n = 2, edges = [[0,1]]
输出：[0,1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>n</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>
<li><code>edges.length == n - 1</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span><span>a</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span>b</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>&lt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.4306em;"></span><span>n</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span><span>a</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>!</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span><span>b</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>所有 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span><span>a</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span>b</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>)</span></span></span></span> 互不相同</li>
<li>给定的输入 <strong>保证</strong> 是一棵树，并且 <strong>不会有重复的边</strong></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>直觉上，<strong>一棵树越靠「外面」的结点，我们越不可能把它作为根结点</strong>，这一点是解决这道问题的关键。我们可以画几张图感受一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpbq9hpij21400a0my2.jpg" alt="image.png" loading="lazy"></p>
<p>因此，我们使用「剔除边缘结点」的策略，类似于「拓扑排序」的方式，把外面的结点一点一点拿掉，剩下的结点就是产生「最小高度树」的结点。</p>
<p>下面要解决的问题是：结点最后只会剩下 1 个或者 2 个。</p>
<blockquote>
<p>有的时候分析问题，自己动手，比看别人的思路的理解要深刻。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpbsc3lej20su0zc42t.jpg" alt="image.png" loading="lazy"></p>
<p><strong>画完这张图，我们能归纳出，结点最后只会剩下 1 个或者 2 个</strong>。如果对这个结论还不确定的朋友，不妨多画几张图，把结点个数为 6 个 、7 个时候的情况也考虑一下。</p>
<p>综上所述，总结一下我们的算法：每次总是删除「<strong>出度为 1</strong>」的结点（因为是从叶子开始删），因为树是无向无环图，删除了它们以后，与之相连的结点的出度也相应地减少 1，直到最后剩下 1 个结点或者 2 个结点。</p>
<p>在编码的时候，使用「邻接表」表示图，使用了「出度数组」。关于拓扑排序的知识和代码实现，可以参考<a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener noreferrer">「力扣」第 207 题：课程表<i>Content not supported</i></a> 和<a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener noreferrer">「力扣」第 210 题：课程表 II<i>Content not supported</i></a>。</p>
<p><strong>注意</strong>：</p>
<p>与标准的「拓扑排序」代码不同的地方在于：这个问题是无向图。</p>
<ul>
<li>「拓扑排序」应用于有向无环图，找到没有指向它的结点，找的是「入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>」的结点；</li>
<li>当前这个问题，因为是无向图，就不能找「入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>」的结点了，无向图的「叶子」的特点是，「出度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>」。</li>
</ul>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>findMinHeightTrees</span><span>(</span><span>int</span> n<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> edges<span>)</span> <span>{</span>
        <span>// 特判</span>
        <span>if</span> <span>(</span>n <span>&lt;</span> <span>3</span><span>)</span> <span>{</span>
            <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                res<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> res<span>;</span>
        <span>}</span>

        <span>// 步骤 1：创建邻接表（无向图）</span>
        <span>// 出度数组，每一次要把入度为 1 的结点剔除</span>
        <span>int</span><span>[</span><span>]</span> outDegree <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
        <span>// 因为是无向图，所以邻接表拿出一条边，两个结点都要存一下</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> adjs <span>=</span> <span>new</span> <span>ArrayList</span><span>[</span>n<span>]</span><span>;</span>
        <span>// 初始化</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            adjs<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> edge <span>:</span> edges<span>)</span> <span>{</span>
            adjs<span>[</span>edge<span>[</span><span>0</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>edge<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
            adjs<span>[</span>edge<span>[</span><span>1</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>edge<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
            outDegree<span>[</span>edge<span>[</span><span>0</span><span>]</span><span>]</span> <span>+=</span> <span>1</span><span>;</span>
            outDegree<span>[</span>edge<span>[</span><span>1</span><span>]</span><span>]</span> <span>+=</span> <span>1</span><span>;</span>
        <span>}</span>

        <span>// 步骤 2：拓扑排序</span>
        <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>// 出度为 1 的结点入队</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 注意：这里是出度为 1</span>
            <span>if</span> <span>(</span>outDegree<span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                queue<span>.</span><span>offer</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 注意边界条件 n = 2 和 n = 1 是如何分析出来的</span>
        <span>while</span> <span>(</span>n <span>></span> <span>2</span><span>)</span> <span>{</span>
            <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
            <span>// 一次减去这么多</span>
            n <span>-=</span> size<span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>int</span> front <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                <span>// 把它和它的邻接结点的出度全部减 1</span>
                <span>for</span> <span>(</span><span>Integer</span> successor <span>:</span> adjs<span>[</span>front<span>]</span><span>)</span> <span>{</span>
                    outDegree<span>[</span>successor<span>]</span><span>--</span><span>;</span>
                    <span>if</span> <span>(</span>outDegree<span>[</span>successor<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                        queue<span>.</span><span>offer</span><span>(</span>successor<span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            res<span>.</span><span>add</span><span>(</span>queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:25.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 802 题：找到最终的安全状态（中等）</title>
    <id>https://suanfa8.com/breadth-first-search/solutions/0802-find-eventual-safe-states/</id>
    <link href="https://suanfa8.com/breadth-first-search/solutions/0802-find-eventual-safe-states/"/>
    <updated>2022-01-15T07:10:25.000Z</updated>
    <content type="html"><![CDATA[<p>这是今天（2021 年 8 月 5 日）的每日一题，主要考察了图的遍历。在充分理解题意的基础上，如果有一定知识储备和题量积累，有思路其实并不难。然后就是编写代码、仔细调试。</p>
<h2 id="题目描述"> 题目描述</h2>
<p>在有向图中，我们从某个节点和每个转向处开始，沿着图的有向边走。 如果我们到达的节点是终点 (即它没有连出的有向边)，我们停止。</p>
<p>现在，如果我们最后能走到终点，那么我们的起始节点是最终安全的。 更具体地说，存在一个自然数 <code>K</code>, 无论选择从哪里开始行走，我们走了不到 <code>K</code> 步后必能停止在一个终点。</p>
<p>哪些节点最终是安全的？ 结果返回一个有序的数组。</p>
<p>该有向图有 <code>N</code> 个节点，标签为 <code>0</code>, <code>1</code>, ..., <code>N - 1</code>, 其中 <code>N</code> 是 <code>graph</code> 的节点数. 图以以下的形式给出: <code>graph[i]</code> 是节点 <code>j</code> 的一个列表，满足 <code>(i, j)</code> 是图的一条有向边。</p>
<div><pre><code>示例：
输入：graph = [[1, 2], [2, 3], [5], [0], [5], [], []]
输出：[2, 4, 5, 6]
这里是上图的示意图。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu5qjlozw4j615c0dmjs802.jpg" alt="" loading="lazy"></p>
<p><strong>提示</strong>：</p>
<ul>
<li><code>n == graph.length</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>n</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03588em;">g</span><span style="margin-right:0.02778em;">r</span><span>a</span><span>p</span><span>h</span><span>[</span><span>i</span><span>]</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.4306em;"></span><span>n</span></span></span></span></li>
<li><code>graph[i]</code> 按严格递增顺序排列。</li>
<li>图中可能包含自环。</li>
<li>图中边的数目在范围 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>[</span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>4</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span><span>]</span></span></span></span> 内。</li>
</ul>
<h2 id="理解题意"> <strong>理解题意</strong></h2>
<ul>
<li>该问题给出的图是「有向图」；</li>
<li>「安全终点」的意思是：它的所有前驱结点可以经过有限步来到一个 <strong>没有后继结点的结点</strong>。也就是，<strong>如果结点在环里是不是安全的</strong>；</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt5kdwgocqj31dc0pujto.jpg" alt="在「环」中的顶点不是「最终安全」的" loading="lazy"></p>
<h2 id="思路分析"> 思路分析</h2>
<p>题目要求我们判断一个 <strong>有向图</strong> 是否存在环，可以使用「深度优先遍历」，也可以使用「广度优先遍历」。</p>
<h2 id="方法一-深度优先遍历"> 方法一：深度优先遍历</h2>
<ul>
<li>由于有向图存在环，因此在深度优先遍历的时候需要使用一个布尔数组 <code>visited</code> 记录某个顶点是否被访问过；</li>
<li>由于还需要记录某个结点，在遍历以后是否处在环中，可以丰富布尔数组的含义，以及利用递归函数的返回值，因此定义：
<ul>
<li>拓展布尔数组 <code>visited</code> 的含义，除了表示访问过还是未访问，还需要表示是否存在回路。因此，可以把布尔数组设置成包装类型 <code>Boolean</code>：<code>null</code> 表示当前还没有被访问过，<code>false</code> 表示从当前顶点出发不存在环，<code>true</code> 表示从当前顶点出发存在环；</li>
<li>深度优先遍历的返回值，如果为 <code>true</code> ，表示从该顶点遍历，存在回路；如果为 <code>false</code> ，表示从该顶点遍历，不存在回路。</li>
</ul>
</li>
</ul>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>/**
     * 使用 Boolean 利用了 null 表示还未计算出结果
     * true 表示从当前顶点出发的所有路径存在环
     * false 表示从当前顶点出发的所有路径不存在环
     */</span>
    <span>private</span> <span>Boolean</span><span>[</span><span>]</span> visited<span>;</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> graph<span>;</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>eventualSafeNodes</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> graph<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> graph<span>.</span>length<span>;</span>
        <span>this</span><span>.</span>visited <span>=</span> <span>new</span> <span>Boolean</span><span>[</span>len<span>]</span><span>;</span>
        <span>this</span><span>.</span>graph <span>=</span> graph<span>;</span>

        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 如果从当前顶点出发的所有路径存在环，该顶点跳过</span>
            <span>if</span> <span>(</span><span>dfs</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
                <span>continue</span><span>;</span>
            <span>}</span>
            res<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>

    <span>}</span>

    <span>/**
     * @param u
     * @return 从顶点 u 出发的所有路径是不是有一条能够回到 u，有回路就返回 true
     */</span>
    <span>private</span> <span>boolean</span> <span>dfs</span><span>(</span><span>int</span> u<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>visited<span>[</span>u<span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> visited<span>[</span>u<span>]</span><span>;</span>
        <span>}</span>


        <span>// 先假设从 u 出发的所有路径存在环</span>
        visited<span>[</span>u<span>]</span> <span>=</span> <span>true</span><span>;</span>
        <span>// 结点 u 的所有后继结点都不能回到自己，才能认为结点 u 是安全的</span>
        <span>for</span> <span>(</span><span>int</span> successor <span>:</span> graph<span>[</span>u<span>]</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>dfs</span><span>(</span>successor<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 程序能走到这里，说明从 u 出发的所有顶点都不存在环，因此 visited[u] = false</span>
        visited<span>[</span>u<span>]</span> <span>=</span> <span>false</span><span>;</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.05764em;">E</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span> 为图的顶点总数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.05764em;">E</span></span></span></span> 为图的边数；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.05764em;">E</span><span>)</span></span></span></span>。</li>
</ul>
<p><strong>说明</strong>：在声明变量、设计递归函数的时候，<strong>需要明确递归函数的变量的定义和递归函数的返回值</strong>，写上必要的注释，这样在编写代码逻辑的时候，才不会乱。</p>
<h2 id="方法二-广度优先遍历-拓扑排序"> 方法二：广度优先遍历（拓扑排序）</h2>
<p>广度优先遍历，从「终点」开始遍历，如何知道哪些顶点是终点呢？可以在建立邻接表的时候，把邻接表建立成逆邻接表，也就是把图中给出的有向图中的边 <strong>反向</strong>。从没有前驱结点（没有任何顶点指向它）的顶点开始广度优先遍历，遍历到的所有结点就是「最终安全」的。</p>
<p>在有向图中进行广度优先遍历，有一个典型的应用场景，称为「拓扑排序」，需要借助「入度数组」的概念。题目要求「答案数组中的元素应当按 <strong>升序</strong> 排列」，所以访问过的结点需要先记录下来，最后统一输出。</p>
<p>如果对「拓扑排序」不太熟悉的朋友，可以做一下「力扣」第 207 题和第 210 题，多写几次，就会发现其实是一个很简单的东西。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt5l7zb8h0j315i0n440n.jpg" alt="建立「逆邻接表」" loading="lazy"></p>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Set</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>eventualSafeNodes</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> graph<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> graph<span>.</span>length<span>;</span>
        <span>// 第 1 步：建图，建立逆邻接表</span>
        <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> reverses <span>=</span> <span>new</span> <span>HashSet</span><span>[</span><span>N</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            reverses<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>HashSet</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>int</span><span>[</span><span>]</span> inDegree <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>:</span> graph<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                reverses<span>[</span>j<span>]</span><span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
                inDegree<span>[</span>i<span>]</span><span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>// 第 2 步：拓扑排序，由于需要按顺序输出，把拓扑排序访问到的结点设置为 true</span>
        <span>// 把入度为 0 的点加入队列，从这些顶点开始广度优先遍历</span>
        <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>inDegree<span>[</span>i<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                queue<span>.</span><span>offer</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>boolean</span><span>[</span><span>]</span> visited <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>N</span><span>]</span><span>;</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>int</span> front <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>// 重点理解：从没有入度的结点出发，访问到的所有的结点都是安全的</span>
            visited<span>[</span>front<span>]</span> <span>=</span> <span>true</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> successor <span>:</span> reverses<span>[</span>front<span>]</span><span>)</span> <span>{</span>
                inDegree<span>[</span>successor<span>]</span><span>--</span><span>;</span>
                <span>if</span> <span>(</span>inDegree<span>[</span>successor<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>offer</span><span>(</span>successor<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>// 第 3 步：已经访问过的结点就是「安全结点」</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>visited<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                res<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.05764em;">E</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.22222em;">V</span></span></span></span> 为图的顶点总数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.05764em;">E</span></span></span></span> 为图的边数；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.22222em;">V</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.05764em;">E</span><span>)</span></span></span></span>。</li>
</ul>
<h2 id="总结"> 总结</h2>
<p>图的问题很多时候就是在图中做一次遍历，根据不同的要求，选择深度优先遍历或者广度优先遍历，或者两种遍历都可以。在学习的时候需要多练习，不同的问题需要注意的细节不一样。自己写过几遍，才算真正掌握了，其它算法为也是这样。</p>
<p>这就是今天的分享，感谢大家的收看。</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:25.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1203 题：项目管理（困难）</title>
    <id>https://suanfa8.com/breadth-first-search/solutions/1203-sort-items-by-groups-respecting-dependencies/</id>
    <link href="https://suanfa8.com/breadth-first-search/solutions/1203-sort-items-by-groups-respecting-dependencies/"/>
    <updated>2022-08-08T06:56:56.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/" target="_blank" rel="noopener noreferrer">1203. 项目管理（困难）<i>Content not supported</i></a>；</li>
<li>📺 题解链接：<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/1203-xiang-mu-guan-li-by-leetcode-t63b/" target="_blank" rel="noopener noreferrer">视频题解与文字题解<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/1203-xiang-mu-guan-li-by-leetcode-t63b/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1iy4y1m7ye" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https:////player.bilibili.com/player.html?aid=798749392&bvid=BV1iy4y1m7ye&cid=284091196&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>公司共有 <code>n</code> 个项目和 <code>m</code> 个小组，每个项目要不没有归属，要不就由其中的一个小组负责。</p>
<p>我们用 <code>group[i]</code> 代表第 <code>i</code> 个项目所属的小组，如果这个项目目前无人接手，那么 <code>group[i]</code> 就等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>−</span><span>1</span></span></span></span>。（项目和小组都是从零开始编号的）</p>
<p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p>
<ul>
<li>同一小组的项目，排序后在列表中彼此相邻；</li>
<li>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。</li>
</ul>
<p><strong>结果要求</strong>：</p>
<ul>
<li>如果存在多个解决方案，只需要返回其中任意一个即可。</li>
<li>如果没有合适的解决方案，就请返回一个 <strong>空列表</strong>。</li>
</ul>
<p>关键：每个项目要不没有归属，要不就由其中的一个小组负责。</p>
<p><strong>示例 1</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpf40064j205b051mx4.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
输出：[6,3,4,1,5,2,0,7]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2</strong>：</p>
<div><pre><code>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
输出：[]
解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m &lt;= n &lt;= 3 * 10^4</code></li>
<li><code>group.length == beforeItems.length == n</code></li>
<li><code>-1 &lt;= group[i] &lt;= m - 1</code></li>
<li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li>
<li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li>
<li><code>i != beforeItems[i][j]</code></li>
<li><code>beforeItems[i]</code> 不含重复元素</li>
</ul>
<p>（请见上面「题解链接」，有视频讲解与文字题解。）</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:25.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">拓扑排序简介</title>
    <id>https://suanfa8.com/breadth-first-search/solutions/intro/</id>
    <link href="https://suanfa8.com/breadth-first-search/solutions/intro/"/>
    <updated>2022-01-15T07:10:25.000Z</updated>
    <content type="html"><![CDATA[<div><p>知识点精讲</p>
<p>「拓扑排序」没有新的知识点，最少需要知道：</p>
<ul>
<li>「拓扑排序」可以用于判断有向图是否存在环，如果不存在环，可以给出其中一种拓扑排序的结果；</li>
<li>「拓扑排序」可以使用「广度优先遍历」实现，也可以使用「深度优先遍历」实现。一般而言，需要掌握「广度优先遍历」，而「深度优先遍历」绝大多数情况下不需要掌握。</li>
</ul>
</div>
<p>拓扑排序并非一种排序算法，它能得到一个 AOV 网络的拓扑序列，用于判断 <strong>有向无环图</strong> 中是否有环，即可以判断一系列活动是否有循环依赖；</p>
<p>解决一个工程中的任务是否能够顺利完成，判断是否出现环。（补充：还有一种判断图中是否有环的数据结构是「并查集」）。</p>
<p>具体例子：去店里吃饭的问题：顾客要求先吃饭再付钱，商家要求先收钱再做菜，这就是循环依赖，拓扑排序就可以帮助我们判断是否形成环。算法 4 那本书里面就有拓扑排序。</p>
<h2 id="「拓扑排序」的步骤"> 「拓扑排序」的步骤</h2>
<p>找无前驱的结点（即 <strong>入度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的结点</strong>），一个一个地删去（使用队列），删的时候，把邻居结点的入度（即度 -1 ）。<strong>需要借助队列实现。</strong></p>
<p>「拓扑排序」用于对有先后顺序的任务的输出，如果先后顺序形成一个环，那么就表示这些任务头尾依赖，就永远不能完成。</p>
<p>因此「拓扑排序」还可以用于检测一个图中是否有环。</p>
<p>「力扣 」上拓扑排序目前（截止 2019 年 2 月 16 日早）一共有 5 题。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyeslw1nbj30m8087dg1.jpg" alt="LeetCode 专题：拓扑排序-1" loading="lazy"></p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:25.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">《算法与数据结构》学习笔记8：二分搜索树</title>
    <id>https://suanfa8.com/data-structure/binary-search-tree/</id>
    <link href="https://suanfa8.com/data-structure/binary-search-tree/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="_8-《算法与数据结构》学习笔记-二分搜索树"> 8. 《算法与数据结构》学习笔记：二分搜索树</h1>
<h2 id="_8-1-基于有序数组的二分查找法"> 8.1 基于有序数组的二分查找法</h2>
<ul>
<li>
<p>查找问题是计算机中非常重要的一类基础问题；</p>
</li>
<li>
<p>这个问题可以这样理解，在我们的生活中，要想方便地“找东西”，就要在“存东西”的时候多花点心思。例如：我们在“存东西”的时候，会有意识地“分门别类”放好。在我们的计算机中，文件夹呈现的树形结构，就是一种分类存放的策略，我们想要找张三的资料，肯定不会去李四的文件夹下查找。我们去图书馆要找一本《算法》的书，我们肯定不会去标明“文学”的那个书架上找；</p>
</li>
<li>
<p>学习过 Java 语言的朋友们一定知道 hash 表，我们可以给放进集合中的对象计算一个 hash 值，以后取出来的时候通过计算 hash 值得到之前放进去的对象，这也是一种存放数据和读取数组的策略的策略；</p>
</li>
<li>
<p>那么“二分查找法”要求数据是怎么存的呢？很简单，只要数据是顺序摆放的，我们就可以用“二分查找算法”。即二分查找法的使用前提：<strong>对于有序的数列才能使用二分查找法</strong>，如果数组无序，就不能使用二分查找法。</p>
</li>
</ul>
<blockquote>
<p>“二分查找法”能够根据数组的索引大大减少每次查找所需的比较次数。</p>
</blockquote>
<p>因为每次查找都能缩短一半的查找区间。</p>
<ul>
<li>二分查找法的思想在 1946 年就被提出来了。但是第 1 个没有 bug 的二分查找法在 1962 年才出现。这个 bug  就在于查找两个数的中间数，如何避免为了求中间数而导致的整形溢出，避免这个 bug 的方法我们在介绍归并排序时介绍过。</li>
</ul>
<p>二分查找算法要求数组是顺序数组，但是在我们的生活中，还有这样的场景：我们购买的物品是一件一件买回来的，有时，我们还会丢弃一些物品，那么是不是我们每增加或者丢弃一些物品的时候，都要将他们重新整理一下呢？</p>
<p>可以查阅资料，看看如何使用二分查找实现 <code>floor</code> 和 <code>ceiling</code> 操作。</p>
<h2 id="_8-2-二分搜索树-binary-search-tree"> 8.2 二分搜索树（Binary Search Tree）</h2>
<ul>
<li>实现查找表，可以通过“普通数组”、“顺序数组”、“二分搜索树”来实现。其中，最有效的方式就是实现二分搜索树。这是因为：</li>
</ul>
<blockquote>
<p>BST 是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的数据结构。</p>
</blockquote>
<p>BST 的定义如下：</p>
<blockquote>
<p>一棵二叉搜索树（BST）首先是一棵二叉树，其中每个结点都含有一个可以比较的键（对于 Java 语言来说，就是实现了 <code>Comparable</code> 接口的对象）以及相关联的值，且每个结点的键都大于其左子树中的任意结点的键而小于右子树中任意结点的键。</p>
</blockquote>
<p>理解 BST 的定义是理解关于 BST 操作的基础。</p>
<ul>
<li>二分搜索树很适合用于实现“查找表”或者“字典”这种数据结构。</li>
<li>二分搜索树不一定是一棵完全二叉树。</li>
<li>以左右孩子为根的子树仍为二分搜索树；任一结点的键大于左子树中的<strong>所有</strong>结点的键，小于右子树中的<strong>所有</strong>结点的键；</li>
<li>我个人认为：理解二分搜索树的性质，应该通过二分搜索树的定义，以及接下来我们对二分搜索树的一些操作，看看我们对二分搜索树中的数据进行&quot;增删改查&quot;的时候，是如何去维护&quot;二分搜索树&quot;的性质的。</li>
<li>我一开始在学习&quot;二分搜索树&quot;的时候，有一些混淆的概念如下：</li>
</ul>
<p>1、&quot;二分搜索树&quot;首先是&quot;二叉树&quot;，有了&quot;搜索&quot;两个字，对结点的键值就有要求了，这个结点的键值要可比较，并且还要按照符合二分搜索树的性质来组织结构，在做 LeetCode 上的问题的时候，一定要看清楚题目中给出的条件包不包含&quot;搜索&quot;两个字；
2、&quot;二分搜索树&quot;和&quot;堆&quot;：&quot;最大堆&quot;只要求父结点不小于子结点就可以了，但是&quot;二分搜索树&quot;就完全不一样了；另外，&quot;堆&quot;可以用数组来表示，因为&quot;堆&quot;是&quot;完全二叉树&quot;，而&quot;二分搜索树&quot;是动态的树形结构，这是由它们的性质决定的，&quot;堆&quot;的操作其实比 BST 少（&quot;堆&quot;有自己适用的场合），BST 能够帮助我们完成很多事情。</p>
<p>初始化 BST：</p>
<div><pre><code><span>public</span> <span>class</span> <span>BST</span> <span>{</span>

    <span>// 使用内部类来表示结点</span>
    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>

        <span>// 为了说明算法，我们将 key 设置成易于比较的 int 类型，设计成实现了 Comparable 接口的对象是更标准的做法</span>
        <span>private</span> <span>int</span> key<span>;</span>
        <span>private</span> <span>int</span> value<span>;</span>
        <span>private</span> <span>Node</span> left<span>;</span>
        <span>private</span> <span>Node</span> right<span>;</span>

        <span>public</span> <span>Node</span><span>(</span><span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
            <span>this</span><span>.</span>left <span>=</span> <span>null</span><span>;</span>
            <span>this</span><span>.</span>right <span>=</span> <span>null</span><span>;</span>
        <span>}</span>

    <span>}</span>

    <span>// 节根点</span>
    <span>private</span> <span>Node</span> root<span>;</span>

    <span>// 二分搜索树中的结点个数</span>
    <span>private</span> <span>int</span> count<span>;</span>

    <span>// 默认构造一棵空的二分搜索树</span>
    <span>public</span> <span>BST</span><span>(</span><span>)</span> <span>{</span>
        root <span>=</span> <span>null</span><span>;</span>
        count <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>// 返回二分搜索树的结点个数</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>;</span>
    <span>}</span>

    <span>// 返回二分搜索树是否为空</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count <span>==</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>查阅资料，如何借助二分搜索树实现以下函数：min、max、floor、ceil、rank、select。二分搜索树还可以回答很多数据之间的关系的问题。</p>
<h2 id="_8-3-二分搜索树的第-1-个操作-向二分搜索树中插入新的结点"> 8.3 二分搜索树的第 1 个操作：向二分搜索树中插入新的结点</h2>
<ul>
<li>我们利用了二分搜索树的递归的性质来完成 <code>insert</code> 函数的编写。</li>
<li>应该特别注意的是：<strong>该递归的方法返回了插入了新的结点的二分搜索树的根</strong>，这一点保证了插入新结点以后，它能够被它的父结点的 <code>left</code> 或 <code>right</code> 指向，这一点要认真体会：</li>
</ul>
<p>1、<code>node.left = insert(node.left, key, value);</code></p>
<p>2、<code>node.right = insert(node.right, key, value);</code></p>
<p>注意：在递归的实现中，应该把 <code>insert</code> 的结果返回给 <code>node.left</code> 和 <code>node.right</code> ，刚开始接触这个算法的时候，觉得很难理解，写多了就觉得比较自然了。</p>
<div><pre><code><span>public</span> <span>void</span> <span>insert</span><span>(</span><span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
    <span>insert</span><span>(</span>root<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>// 向一棵二分搜索树的根结点插入 key 和 value，看看放在左边还是放在右边，然后把插入以后形成的树的根结点返回。</span>
<span>// 注意这里的递归调用实现，初学的时候，不是很好理解。可以尝试从最最简单的情况开始分析。</span>
<span>private</span> <span>Node</span> <span>insert</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        count<span>++</span><span>;</span>
        <span>return</span> <span>new</span> <span>Node</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>==</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>// 如果 key 值存在，直接覆盖就好了，即更新</span>
        node<span>.</span>value <span>=</span> value<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>// 递归调用结束以后，要把根结点返回回去</span>
        <span>// 因为很可能，node.left 是空，要让新创建的结点接到原来的根，就得执行这步操作</span>
        node<span>.</span>left <span>=</span> <span>insert</span><span>(</span>node<span>.</span>left<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// 递归调用结束以后，要把根结点返回回去</span>
        node<span>.</span>right <span>=</span> <span>insert</span><span>(</span>node<span>.</span>right<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="_8-4-二分搜索树的第-2-个操作-元素查找和判断是否包含"> 8.4 二分搜索树的第 2 个操作：元素查找和判断是否包含</h2>
<ul>
<li>这一节，我们要实现查找的两个方法：二分查找树的包含 <code>contain</code>（返回 <code>true</code> 或者 <code>false</code>） 和查找 <code>search</code>（返回相应的 <code>vlaue</code> 值），这两个方法同质。还要考虑查找成功和失败这两种情况。</li>
<li>1、首先实现 <code>contain</code> 方法。</li>
</ul>
<div><pre><code><span>public</span> <span>boolean</span> <span>contain</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>
    <span>return</span> <span>contain</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>contain</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>// 先处理递归到底的情况</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>key <span>==</span> key<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>contain</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>contain</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>2、再实现 <code>search</code> 方法。</li>
</ul>
<div><pre><code><span>public</span> <span>int</span> <span>search</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>
    <span>return</span> <span>search</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>// 在以 node 为根的二分搜索树中查找 key 所对应的 value</span>
<span>private</span> <span>Integer</span> <span>search</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>// 先处理递归到底的情况</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>key <span>==</span> key<span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>value<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_8-5-二分搜索树的第-3-个操作-深度优先遍历"> 8.5 二分搜索树的第 3 个操作：深度优先遍历</h2>
<ul>
<li>二分搜索树的遍历，其实就是挨个把二分搜索树中的元素拿出来，只不过二分搜索树不像数组或者链表那样，有明显的“从头到尾”的性质。但其实<strong>走完一个二分搜索树也是有规律可循的</strong>，其中一种方式就是深度优先遍历。</li>
<li>深度优先遍历的顺序是下面这张图展示的样子。首先尝试走到最深，再回退，再走到另一个分支的最深。</li>
</ul>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/二分搜索树的深度优先遍历.jpg" alt="" loading="lazy"></p>
<p>那么什么是二分搜索树的前序、中序、后序遍历呢？</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/遍历方式的解释.jpg" alt="" loading="lazy"></p>
<ul>
<li>把握要点：<strong>通过对深度优先遍历</strong>的遍历路径，我么可以看出，深度优先遍历走完一棵二叉树，每个结点会被访问 3 次，分别对应左边、中间和右边，那么在什么位置进行输出，就对应了深度优先遍历的这三种遍历方式：前序遍历，在访问左边位置的时候，进行操作；中序遍历，在访问中间位置的时候，进行操作；后序遍历，在访问右边位置的时候，进行操作；。</li>
<li>使用递归的方式实现的代码编写是异常简单的！下面的图表多看几遍就明白了，千万不要忘记了对 node 是否为 null 的判断。下面用递归的方式编写前、中、后序遍历是十分简单的。它们的结构是完全相同的。</li>
</ul>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/前序中序后序遍历.jpg" alt="" loading="lazy"></p>
<ul>
<li>后序遍历与空间释放</li>
</ul>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/后序遍历与空间释放.jpg" alt="" loading="lazy"></p>
<p>可以看到，红色标注的部分是结构一致的。</p>
<ul>
<li>记忆要点：左右子树都是递归处理，树根是真正要执行的操作。后序遍历的一个重要特点：前序和后序都访问完以后，才做操作。</li>
<li>中序遍历的重要结论：中序遍历可以将数据按照从小到大升序排列。</li>
<li>后序遍历的重要结论：后续遍历在空间释放的时候可以先释放左右结点，再释放自身。</li>
</ul>
<div><pre><code><span>// 二分搜索树的前序遍历</span>
<span>public</span> <span>void</span> <span>preOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>preOrder</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>preOrder</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"%s "</span><span>,</span> node<span>.</span>value<span>)</span><span>;</span>
        <span>preOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>preOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 二分搜索树的中序遍历</span>
<span>public</span> <span>void</span> <span>inOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>inOrder</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>inOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"%s "</span><span>,</span> node<span>.</span>value<span>)</span><span>;</span>
        <span>inOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 二分搜索树的后序遍历</span>
<span>public</span> <span>void</span> <span>postOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>postOrder</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>postOrder</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>postOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>postOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><ul>
<li>补充知识：使用非递归的方法完成二分搜索树的三种深度优先遍历。</li>
</ul>
<h2 id="_8-6-二分搜索树的第-4-个操作-广度优先遍历"> 8.6 二分搜索树的第 4 个操作：广度优先遍历</h2>
<ul>
<li>重点：广度优先遍历区别于深度优先遍历的方式是<strong>我们首先将每一层的结点优先遍历完毕</strong>。</li>
<li>要想完成广度优先遍历，我们要借助队列（先进先出，后进后出）这个数据结构。</li>
<li>具体实现方式 ：当队列中的队首出队的时候，要从二叉搜索树中找到它的两个孩子入队（如果有左边孩子的话，左边先入队）。队列出队为空的时候，就将二叉树遍历完成了。</li>
<li>我们再归纳一下广度优先遍历的步骤：</li>
</ul>
<ol>
<li>将根结点入队（入队的时候不做别的操作）；</li>
<li>队列非空，所以接下来就要出队，规则是：依次出队，只要出队的元素有孩子，左右孩子依次入队，如果没有孩子不做任何操作。</li>
</ol>
<p>代码实现：</p>
<div><pre><code><span>// 二分搜索树的广度优先遍历(层序遍历)</span>
<span>public</span> <span>void</span> <span>levelOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>Queue</span><span><span>&lt;</span><span>Node</span><span>></span></span> queue <span>=</span> <span>new</span> <span>ArrayDeque</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>Node</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>node<span>.</span>key<span>)</span><span>;</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下的总结是针对深度优先遍历的 3 种方式和广度优先的 1 种方式，总共 4 种遍历方式而言的：整个遍历的复杂度是：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span>。</p>
<ul>
<li>不论是深度优先遍历还是广度优先遍历，对于二分搜索树来说，每一个结点只访问了常数次；</li>
<li><strong>归并排序和快速排序的本质其实是二叉树的深度优先遍历的过程</strong>；</li>
<li>重点把握思想：1、递归调用；2、使用队列实现一个更加复杂的算法的过程（这种按顺序访问的情况，可以使用队列）。</li>
</ul>
<h2 id="_8-7-二分搜索树的结点的删除-这部分有一定难度-不过可以分情况讨论"> 8.7 二分搜索树的结点的删除（这部分有一定难度，不过可以分情况讨论）</h2>
<h3 id="_8-7-1-第-1-种情况-讨论删除二分搜索树中的最小结点和最大结点"> 8.7.1 第 1 种情况：讨论删除二分搜索树中的最小结点和最大结点</h3>
<ul>
<li>我们要删除结点，首先要找到这些结点。因此首先要理解下面的这两个基本且简单的性质：</li>
</ul>
<p>最小值结点如何查找：从根结点开始，不停地沿着左边结点的方向找，直到再也没有左结点为止；</p>
<p>最大值结点如何查找：从根结点开始，不停地沿着右边结点的方向找，直到再也没有右结点为止。</p>
<div><pre><code><span>// 查找二分搜索树 key 的最小值</span>
<span>public</span> <span>int</span> <span>minimum</span><span>(</span><span>)</span> <span>{</span>
    <span>assert</span> count <span>!=</span> <span>0</span><span>;</span>
    <span>Node</span> node <span>=</span> <span>minimum</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> node<span>.</span>key<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>minimum</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> node<span>;</span>
    <span>}</span>
    <span>return</span> <span>minimum</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
<span>}</span>


<span>// 查找二分搜索树 key 的最大值</span>
<span>public</span> <span>int</span> <span>maximum</span><span>(</span><span>)</span> <span>{</span>
    <span>assert</span> count <span>!=</span> <span>0</span><span>;</span>
    <span>Node</span> node <span>=</span> <span>maximum</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> node<span>.</span>key<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>maximum</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> node<span>;</span>
    <span>}</span>
    <span>return</span> <span>maximum</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ul>
<li>删除最小值结点分两种情况：</li>
</ul>
<ol>
<li>最小值结点没有右孩子（子树），此时直接删除就好；</li>
<li>最小值结点有右孩子（子树），此时让右孩子（子树）代替自己就可以了。</li>
</ol>
<ul>
<li>同理分析可以得到：删除最大值结点也分两种情况：</li>
</ul>
<ol>
<li>最大值结点没有左孩子（子树），此时直接删除就好；</li>
<li>最大值结点有左孩子（子树），此时让左孩子（子树）代替自己就可以了。</li>
</ol>
<div><pre><code><span>// 从二分搜索树中删除最小 key 所在的结点</span>
<span>public</span> <span>void</span> <span>removeMin</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> <span>removeMin</span><span>(</span>root<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span>private</span> <span>Node</span> <span>removeMin</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>// 仔细体会这个过程</span>
    <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 就是删除这个结点</span>
        <span>Node</span> rightNode <span>=</span> node<span>.</span>right<span>;</span>
        node<span>.</span>right <span>=</span> <span>null</span><span>;</span> <span>// 因为左边已经是空了，再把右边释放掉</span>
        count<span>--</span><span>;</span>
        <span>return</span> rightNode<span>;</span>

    <span>}</span>
    node<span>.</span>left <span>=</span> <span>removeMin</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>

<span>// 从二分搜索树中删除最大 key 所在的结点</span>
<span>public</span> <span>void</span> <span>removeMax</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 删除了最大元素以后的根结点很有可能不是原来的根结点</span>
        <span>// 所以一定要赋值回去</span>
        root <span>=</span> <span>removeMax</span><span>(</span>root<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span>private</span> <span>Node</span> <span>removeMax</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>Node</span> nodeLeft <span>=</span> node<span>.</span>left<span>;</span>
        node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>return</span> nodeLeft<span>;</span>
    <span>}</span>
    node<span>.</span>right <span>=</span> <span>removeMax</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id="_8-7-2-第-2-种情况-讨论删除只有左孩子-子树-或者只有右孩子-子树-的结点"> 8.7.2 第 2 种情况：讨论删除只有左孩子（子树）或者只有右孩子（子树）的结点</h3>
<p>处理的方式也很简单，只要让那个非空的左右孩子代替自己就可以了，代码我们合并在下一种情况中展示。</p>
<h3 id="_8-7-3-第-3-种情况-删除左右都有孩子-子树-的结点"> 8.7.3 第 3 种情况：删除左右都有孩子（子树）的结点</h3>
<ul>
<li>代替的那个结点是右边子树的最小值（即找到要删除的这个结点的后继结点），或者是左边子树的最大值（或者找到要删除的这个结点的前驱）。</li>
<li>重要结论：删除二分搜索树的任意一个结点的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.01968em;">l</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>n</span><span>)</span></span></span></span>。主要消耗的时间都在找到这个结点，删除这个结点的过程虽然很复杂，但是操作都是指针间的交换，是常数级别的，和整棵树有多少个结点是无关的。所以二分搜索树的删除是非常高效的。</li>
</ul>
<div><pre><code><span>// 算法并不难理解，但是在编写的过程中有一些情况需要讨论清楚，并且要注意一写细节，多写几遍就清楚了</span>
<span>public</span> <span>void</span> <span>remove</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>
    root <span>=</span> <span>remove</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>remove</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>// 这里要想清楚一个问题，删除以后的二分搜索树的根结点很可能不是原来的根结点</span>
        node<span>.</span>left <span>=</span> <span>remove</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>></span> node<span>.</span>key<span>)</span> <span>{</span>
        node<span>.</span>right <span>=</span> <span>remove</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// key == node.key</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>Node</span> rightNode <span>=</span> node<span>.</span>right<span>;</span>
            node<span>.</span>right <span>=</span> <span>null</span><span>;</span>
            count<span>--</span><span>;</span>
            <span>return</span> rightNode<span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>Node</span> leftNode <span>=</span> node<span>.</span>left<span>;</span>
            node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
            count<span>--</span><span>;</span>
            <span>return</span> leftNode<span>;</span>
        <span>}</span>
        <span>// 当前 node 的后继</span>
        <span>Node</span> successor <span>=</span> <span>minimum</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        count<span>++</span><span>;</span><span>// 下面删除了一个结点，所以要先加一下</span>
        successor<span>.</span>right <span>=</span> <span>removeMin</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        successor<span>.</span>left <span>=</span> node<span>.</span>left<span>;</span>
        node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
        node<span>.</span>right <span>=</span> <span>null</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>return</span> successor<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_8-8-二分搜索树的顺序性"> 8.8 二分搜索树的顺序性</h2>
<ul>
<li>之前我们将二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。</li>
<li>二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。</li>
<li>1、minimum，maximum；</li>
<li>2、successor，predecessor（这两个元素在二分搜索树的 key 中必须存在）；</li>
<li>3、floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在）；</li>
<li>4、rank（58 是排名第几的元素）、select（排名第10的元素是谁，这个问题与 rank 正好相反）。</li>
</ul>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/rank.jpg" alt="" loading="lazy"></p>
<ul>
<li>之前，我们的二分搜索树并不支持有重复元素的二分搜索树。在有些情况下，我们须要支持重复元素的二分搜索树。</li>
</ul>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/支持重复元素的二分搜索树.jpg" alt="" loading="lazy"></p>
<h2 id="_8-9-二分搜索树的局限性"> 8.9 二分搜索树的局限性</h2>
<ul>
<li>二分查找树的性能。二分查找树在一些极端情况下性能并不好。</li>
<li>我们首先要认识下面一个事实：同样的数据，可以对应不同的二分搜索树。看下面的例子。</li>
</ul>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/可以对应不同的二分搜索树.jpg" alt="" loading="lazy"></p>
<p>此时二分搜索树可以<strong>退化为链表</strong>。此时时间复杂度变成了 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span>。我们可以做一个极端测试：如果把 key 排序好以后，依次插入到二分搜索树中，此时二分搜索树的高度就会变得非常高。</p>
<ul>
<li>解决方案：改造二叉树的实现，使得二叉树无法成为链表。使用平衡二叉树。</li>
<li>使用红黑树（<strong>红黑树是一种平衡二叉树的实现</strong>，其它平衡二叉树的实现还有 2-3 tree，AVL tree，Splay tree 伸展树，平衡二叉树和堆的结合：Treap）。左右两棵子树的高度差不会超过1。</li>
<li>一个很有意思的数据结构：trie（设计巧妙，实现不难）。使用 trie 统计词频。</li>
</ul>
<p>![](https://liweiwei1419.github.io/images/algorithms/bst/前缀树 trie.jpg)</p>
<h2 id="_8-10-树形问题和更多树"> 8.10 树形问题和更多树</h2>
<ul>
<li>虽然没有创建树。递归方法天然地具有递归的性质。归并排序法和快速排序法的思想它们像极了对一棵树进行后序遍历和前序遍历。</li>
<li><strong>递归的思想</strong>大量应用于搜索问题：一条龙游戏、8 数码、8皇后、数独、搬运工、人工智能：搬运工，<strong>树形搜索</strong>、机器学习。</li>
<li>更多的树还有：KD 树，区间树，哈夫曼树。</li>
<li>这一节的最后，老师介绍了很多开放的问题，帮助我们培养对算法的兴趣。</li>
</ul>
<h2 id="_8-11-二分搜索树的代码实现"> 8.11 二分搜索树的代码实现</h2>
<h3 id="代码实现-java"> 代码实现（Java）</h3>
<p>https://gist.github.com/liweiwei1419/490d6fa4a92b88b166e5680978858034</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/二分搜索树实现.jpg" alt="" loading="lazy"></p>
<ul>
<li>注意：这里查找 key 的最小值，查找 key 的最大值，删除 key 的最小值，删除 key 的最大值，删除任意结点的操作还比较生疏，希望多加练习（BST6.java、BST7.java）！</li>
<li>另外，使用非递归的方式实现递归的效果，用在遍历和查找最小最大、删除最小最大上，也要自己实现一遍。</li>
</ul>
<hr>
<p>补充内容：</p>
<ul>
<li>堆是二叉树结构，但不是二分搜索树结构。</li>
<li>二分查找的思想在 LeetCode 中有很多应用，希望引起重视。</li>
<li>分别使用递归和非递归实现二分查找算法，以及相应的练习。</li>
<li>查找相关的问题：min、max、rank、select、floor、ceiling</li>
<li>什么是完全二叉树、什么是满二叉树</li>
<li>注意为 BST 增加（insert） 结点，使用递归方法将结点挂接到原来的结点上，那么如何写非递归的实现呢？</li>
<li>使用 BST 还可以解决一些例如逆序对这类的问题</li>
<li>删除二分搜索树的结点（<strong>其实就是分类讨论</strong>），应该要做一下总结，否则每次都忘记</li>
<li>BST 更一般地，二叉树的 4 种遍历方式、广度优先遍历，要设置一个队列，深度优先遍历不论是递归还是非递归都和栈有关系</li>
</ul>
<h2 id="bst-的-floor-与-ceiling"> BST 的 floor 与 ceiling</h2>
<ul>
<li>floor(key) 函数返回比 key 小的数的最大值，如果 BST 中没有比 key 小的数，则返回 null</li>
<li>ceiling(key) 函数返回比 key 大的数的最小值，如果 BST 中没有比 key 大的数，则返回 null</li>
</ul>
<h3 id="floor-函数的实现"> floor 函数的实现</h3>
<div><pre><code><span>// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span>private</span> <span>Integer</span> <span>floor</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>key <span>==</span> key<span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>value<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>floor</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
    <span>Integer</span> tempValue <span>=</span> <span>floor</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>tempValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> tempValue<span>;</span>
    <span>}</span>
    <span>return</span> node<span>.</span>value<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：</p>
<ul>
<li>如果给定的键 key 小于二分搜索树的根结点的键，那么小于等于 key 的最大键 floor(key) 一定位于根结点的左子树中；</li>
<li>如果给定的键 key 大于二分搜索树的根结点的键，分两种情况：</li>
</ul>
<ol>
<li>当根结点的右子树中存在小于等于 key 的结点的时候，小于等于 key 的最大键才会出现在右子树中；</li>
<li>否则根结点就是小于等于 key 的最大键。</li>
</ol>
<p>我们可以举出一个具体的例子来说明：</p>
<img src="https://liweiwei1419.github.io/images/algorithms/bst/floor.png">
<p>实现 <code>floor(int key)</code> 函数的关键：</p>
<ol>
<li>利用 BST 的 key 具有顺序性和 BST 的递归性质；</li>
<li>写好递归函数，就要处理好递归到底的条件，这里 <code>node == null</code> 和 <code>node.key = key</code> 就是递归终止条件，<strong><code>node == null</code> 直接影响了后续的逻辑</strong>。</li>
</ol>
<h3 id="ceiling-函数的实现"> ceiling 函数的实现</h3>
<div><pre><code><span>// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span>private</span> <span>Integer</span> <span>ceiling</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>==</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>value<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>></span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>ceiling</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
    <span>Integer</span> tempValue <span>=</span> <span>ceiling</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>tempValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> tempValue<span>;</span>
    <span>}</span>
    <span>return</span> node<span>.</span>value<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>（本节完）</p>
<hr>
<p>title: 【算法日积月累】13-二分搜索树
date: 2019-01-14 08:00:00
author: liwei
top: false
mathjax: true
summary: 本文介绍了二分搜索树。
category: 算法与数据结构
tags:</p>
<ul>
<li>binary-search-tree
permalink: algorithms-and-data-structures/binary-search-tree</li>
</ul>
<hr>
<h1 id="【算法日积月累】13-二分搜索树"> 【算法日积月累】13-二分搜索树</h1>
<h2 id="如何查找"> 如何查找</h2>
<p>我们先从二分查找法开始说起，生活中，如果我们摆放物品是按照一定规律的话，那么查找起来就会非常快，如果我们杂乱无章的摆放我们的物品，那么找起来就非常费劲，我们几乎要看看我们所有可能放置物品的地方，这样的操作无异于计算机中的遍历操作，于是乎，如何摆放以使得我们高效地查找，就是一个值得研究的话题。</p>
<p>1、二分查找法的时间复杂度是 $O(\log n) $，与“递归”相关的算法（呈现树形结构的算法）一般复杂度都是对数阶的复杂度。</p>
<p>2、通过递归来思考一个问题通常更加容易，但递归在性能上会略差（稍差但不意味着我们不会去使用它），因为我们要通过栈来保存层层递归的中间变量。</p>
<h1 id="二分搜索树-binary-search-tree"> 二分搜索树（Binary Search Tree）</h1>
<p>二分搜索树（Binary Search Tree），简称为 BST。二分搜索树这个数据结构的提出，是自来于“查找表”和“字典”这种数据结构。</p>
<p>在“哈希表”没有出现之前，可以通过“普通数组”、“顺序数组”、“二分搜索树”实现查找表。三者之中，最有效的方式是“二分搜索树”。这是因为，BST 是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的数据结构。下面我们比较一下这三个数据结构。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>查找元素</strong></th>
<th><strong>插入元素</strong></th>
<th><strong>删除元素</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>普通数组</strong></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span></td>
</tr>
<tr>
<td><strong>顺序数组</strong></td>
<td>$O(\log n) $</td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span></td>
</tr>
<tr>
<td><strong>二分搜索树</strong></td>
<td>$O(\log n) $</td>
<td>$O(\log n) $</td>
<td>$O(\log n) $</td>
</tr>
</tbody>
</table>
<p>对于上表的说明：</p>
<p>普通数组的插入操作：要先查找有没有这个元素，然后插入或者覆盖。</p>
<p>普通数组的删除操作：要先查找有没有这个元素，然后删除或者什么都不做。</p>
<p>顺序数组的查找操作：可以使用二分查找法，二分查找法的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span>n</span><span>)</span></span></span></span>。</p>
<p>二分搜索树的定义如下：</p>
<blockquote>
<p>一棵二叉搜索树（BST）首先是一棵二叉树，其中每个结点都含有一个可以比较的键（对于 Java 语言来说，就是实现了 <code>Comparable</code> 接口的对象）以及相关联的值，且每个结点的键都大于其左子树中的任意结点的键而小于右子树中任意结点的键。</p>
</blockquote>
<p>理解 BST 的定义是理解关于 BST 操作的基础。</p>
<p>1、二分搜索树很适合用于实现“查找表”或者“字典”这种数据结构；</p>
<p>2、二分搜索树不一定是一棵完全二叉树。</p>
<p>3、以左右孩子为根的子树仍为二分搜索树；任一结点的键大于左子树中的<strong>所有</strong>结点的键，小于右子树中的<strong>所有</strong>结点的键。</p>
<p>理解二分搜索树的性质，应该通过定义，以及二分搜索树的操作，看看我们对二分搜索树中的数据进行“增删改查”的时候，是如何去维护“二分搜索树”的性质。</p>
<p>我一开始在学习“二分搜索树”的时候，有一些混淆的概念如下：</p>
<p>1、“二分搜索树”首先是“二叉树”，有了“搜索”两个字，对结点的 <code>key</code> 就有要求了，这个结点的键值要可比较，并且还要按照符合二分搜索树的性质来组织结构，在做 LeetCode 上的问题的时候，一定要看清楚题目中给出的条件包不包含“搜索”两个字；
2、“二分搜索树”和“堆”的比较：“最大堆”只要求父结点不小于子结点就可以了，但是“二分搜索树”就完全不一样了；另外，“堆”可以用数组来表示，因为“堆”是“完全二叉树”，而“二分搜索树”是动态的树形结构，这是由它们的性质决定的，“堆”的操作其实比 “二分搜索树” 少（“堆”有自己适用的场合），“二分搜索树” 能够帮助我们完成很多事情。</p>
<h2 id="初始化-bst"> 初始化 BST</h2>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>BST</span> <span>{</span>

    <span>// 使用内部类来表示结点</span>
    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>

        <span>// 为了说明算法，我们将 key 设置成易于比较的 int 类型，设计成实现了 Comparable 接口的对象是更标准的做法</span>
        <span>private</span> <span>int</span> key<span>;</span>
        <span>private</span> <span>int</span> value<span>;</span>
        <span>private</span> <span>Node</span> left<span>;</span>
        <span>private</span> <span>Node</span> right<span>;</span>

        <span>public</span> <span>Node</span><span>(</span><span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
            <span>this</span><span>.</span>left <span>=</span> <span>null</span><span>;</span>
            <span>this</span><span>.</span>right <span>=</span> <span>null</span><span>;</span>
        <span>}</span>

    <span>}</span>

    <span>// 根结点</span>
    <span>private</span> <span>Node</span> root<span>;</span>

    <span>// 二分搜索树中的结点个数</span>
    <span>private</span> <span>int</span> count<span>;</span>

    <span>// 默认构造一棵空的二分搜索树</span>
    <span>public</span> <span>BST</span><span>(</span><span>)</span> <span>{</span>
        root <span>=</span> <span>null</span><span>;</span>
        count <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>// 返回二分搜索树的结点个数</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>;</span>
    <span>}</span>

    <span>// 返回二分搜索树是否为空</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count <span>==</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="二分搜索树的操作-增"> 二分搜索树的操作：增</h2>
<p>我们利用二分搜索树的递归的性质来完成 <code>insert</code> 函数的编写。</p>
<p>应该特别注意的是：<strong>该递归的方法返回了插入了新的结点的二分搜索树的根</strong>，这一点保证了插入新结点以后，它能够被它的父结点的 <code>left</code> 或 <code>right</code> 指向，这一点要认真体会：</p>
<p>1、<code>node.left = insert(node.left, key, value);</code></p>
<p>2、<code>node.right = insert(node.right, key, value);</code></p>
<p>注意：在递归的实现中，应该把 <code>insert</code> 的结果返回给 <code>node.left</code> 和 <code>node.right</code> ，刚开始接触这个算法的时候，觉得很难理解，写多了就觉得比较自然了。</p>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>void</span> <span>insert</span><span>(</span><span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
    <span>insert</span><span>(</span>root<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>// 向一棵二分搜索树的根结点插入 key 和 value，看看放在左边还是放在右边，然后把插入以后形成的树的根结点返回。</span>
<span>// 注意这里的递归调用实现，初学的时候，不是很好理解。可以尝试从最最简单的情况开始分析。</span>
<span>private</span> <span>Node</span> <span>insert</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        count<span>++</span><span>;</span>
        <span>return</span> <span>new</span> <span>Node</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>==</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>// 如果 key 值存在，直接覆盖就好了，即更新</span>
        node<span>.</span>value <span>=</span> value<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>// 递归调用结束以后，要把根结点返回回去</span>
        <span>// 因为很可能，node.left 是空，要让新创建的结点接到原来的根，就得执行这步操作</span>
        node<span>.</span>left <span>=</span> <span>insert</span><span>(</span>node<span>.</span>left<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// 递归调用结束以后，要把根结点返回回去</span>
        node<span>.</span>right <span>=</span> <span>insert</span><span>(</span>node<span>.</span>right<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="二分搜索树的操作-查、改"> 二分搜索树的操作：查、改</h2>
<p>这一部分，我们要实现查找的两个方法：二分查找树的包含 <code>contain</code>（返回 <code>true</code> 或者 <code>false</code>） 和查找 <code>search</code>（返回相应的 <code>vlaue</code> 值），这两个方法同质。还要考虑查找成功和失败这两种情况。</p>
<p>1、首先实现 <code>contain</code> 方法。</p>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>contain</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>
    <span>return</span> <span>contain</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>contain</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>// 先处理递归到底的情况</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>key <span>==</span> key<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>contain</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>contain</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>2、再实现 <code>search</code> 方法。</p>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>int</span> <span>search</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>
    <span>return</span> <span>search</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>// 在以 node 为根的二分搜索树中查找 key 所对应的 value</span>
<span>private</span> <span>Integer</span> <span>search</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>// 先处理递归到底的情况</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>key <span>==</span> key<span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>value<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="二分搜索树的操作-删"> 二分搜索树的操作：删</h2>
<p>下面考虑最难的情况：删除左右都有孩子的结点。</p>
<p>思路：拿一个已经有的结点代替这个被删除的结点，同时保持二分搜索树的性质不变。</p>
<p>1962年，由 Hibbard 提出，即 Hibbard Deletion（Hibbard 删除法），即：代替的那个结点是右边子树的最小值（即找到要删除的这个结点的后继结点），或者是左边子树的最大值（或者找到要删除的这个结点的前驱）。</p>
<p>1、删除二分搜索树的任意一个结点的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span>n</span><span>)</span></span></span></span>；</p>
<p>2、主要消耗的时间都在找到这个结点，删除这个结点的过程虽然很复杂，但是操作都是指针间的交换，是常数级别的。</p>
<h3 id="第-1-种情况-删除二分搜索树中的最小结点和最大结点"> 第 1 种情况：删除二分搜索树中的最小结点和最大结点</h3>
<p>我们要删除结点，首先要找到这些结点。因此首先要理解下面的这两个基本且简单的性质：</p>
<p>最小值结点如何查找：从根结点开始，不停地沿着左边结点的方向找，直到再也没有左结点为止；</p>
<p>最大值结点如何查找：从根结点开始，不停地沿着右边结点的方向找，直到再也没有右结点为止。</p>
<p>Java 代码：</p>
<div><pre><code><span>// 查找二分搜索树 key 的最小值</span>
<span>public</span> <span>int</span> <span>minimum</span><span>(</span><span>)</span> <span>{</span>
    <span>assert</span> count <span>!=</span> <span>0</span><span>;</span>
    <span>Node</span> node <span>=</span> <span>minimum</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> node<span>.</span>key<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>minimum</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> node<span>;</span>
    <span>}</span>
    <span>return</span> <span>minimum</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
<span>}</span>


<span>// 查找二分搜索树 key 的最大值</span>
<span>public</span> <span>int</span> <span>maximum</span><span>(</span><span>)</span> <span>{</span>
    <span>assert</span> count <span>!=</span> <span>0</span><span>;</span>
    <span>Node</span> node <span>=</span> <span>maximum</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> node<span>.</span>key<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>maximum</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> node<span>;</span>
    <span>}</span>
    <span>return</span> <span>maximum</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>删除最小值结点分两种情况：</p>
<p>1、最小值结点没有右孩子（子树），此时直接删除就好；</p>
<p>2、最小值结点有右孩子（子树），此时让右孩子（子树）代替自己就可以了。</p>
<p>同理分析可以得到：删除最大值结点也分两种情况：</p>
<p>1、最大值结点没有左孩子（子树），此时直接删除就好；</p>
<p>2、最大值结点有左孩子（子树），此时让左孩子（子树）代替自己就可以了。</p>
<p>Java 代码：</p>
<div><pre><code><span>// 从二分搜索树中删除最小 key 所在的结点</span>
<span>public</span> <span>void</span> <span>removeMin</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> <span>removeMin</span><span>(</span>root<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span>private</span> <span>Node</span> <span>removeMin</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>// 仔细体会这个过程</span>
    <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 就是删除这个结点</span>
        <span>Node</span> rightNode <span>=</span> node<span>.</span>right<span>;</span>
        node<span>.</span>right <span>=</span> <span>null</span><span>;</span> <span>// 因为左边已经是空了，再把右边释放掉</span>
        count<span>--</span><span>;</span>
        <span>return</span> rightNode<span>;</span>

    <span>}</span>
    node<span>.</span>left <span>=</span> <span>removeMin</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>

<span>// 从二分搜索树中删除最大 key 所在的结点</span>
<span>public</span> <span>void</span> <span>removeMax</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 删除了最大元素以后的根结点很有可能不是原来的根结点</span>
        <span>// 所以一定要赋值回去</span>
        root <span>=</span> <span>removeMax</span><span>(</span>root<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span>private</span> <span>Node</span> <span>removeMax</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>Node</span> nodeLeft <span>=</span> node<span>.</span>left<span>;</span>
        node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>return</span> nodeLeft<span>;</span>
    <span>}</span>
    node<span>.</span>right <span>=</span> <span>removeMax</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id="第-2-种情况-删除只有左孩子-子树-或者只有右孩子-子树-的结点"> 第 2 种情况：删除只有左孩子（子树）或者只有右孩子（子树）的结点</h3>
<p>处理的方式也很简单，只要让那个非空的左右孩子代替自己就可以了，代码我们合并在下一种情况中展示。</p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-1.png" alt="二分搜索树的删除-1" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-2.png" alt="二分搜索树的删除-2" loading="lazy"></p>
<h3 id="第-3-种情况-删除左右都有孩子-子树-的结点"> 第 3 种情况：删除左右都有孩子（子树）的结点</h3>
<p>代替的那个结点是右边子树的最小值（即找到要删除的这个结点的后继结点），或者是左边子树的最大值（或者找到要删除的这个结点的前驱）。</p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-3.png" alt="二分搜索树的删除-3" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-4.png" alt="二分搜索树的删除-4" loading="lazy"></p>
<p>重要结论：删除二分搜索树的任意一个结点的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span>n</span><span>)</span></span></span></span>。主要消耗的时间都在找到这个结点，删除这个结点的过程虽然很复杂，但是操作都是指针间的交换，是常数级别的，和整棵树有多少个结点是无关的。所以二分搜索树的删除是非常高效的。</p>
<p>Java 代码：</p>
<div><pre><code><span>// 算法并不难理解，但是在编写的过程中有一些情况需要讨论清楚，并且要注意一写细节，多写几遍就清楚了</span>
<span>public</span> <span>void</span> <span>remove</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>
    root <span>=</span> <span>remove</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>remove</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>// 这里要想清楚一个问题，删除以后的二分搜索树的根结点很可能不是原来的根结点</span>
        node<span>.</span>left <span>=</span> <span>remove</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>></span> node<span>.</span>key<span>)</span> <span>{</span>
        node<span>.</span>right <span>=</span> <span>remove</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// key == node.key</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>Node</span> rightNode <span>=</span> node<span>.</span>right<span>;</span>
            node<span>.</span>right <span>=</span> <span>null</span><span>;</span>
            count<span>--</span><span>;</span>
            <span>return</span> rightNode<span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>Node</span> leftNode <span>=</span> node<span>.</span>left<span>;</span>
            node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
            count<span>--</span><span>;</span>
            <span>return</span> leftNode<span>;</span>
        <span>}</span>
        <span>// 当前 node 的后继</span>
        <span>Node</span> successor <span>=</span> <span>minimum</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        count<span>++</span><span>;</span><span>// 下面删除了一个结点，所以要先加一下</span>
        successor<span>.</span>right <span>=</span> <span>removeMin</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        successor<span>.</span>left <span>=</span> node<span>.</span>left<span>;</span>
        node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
        node<span>.</span>right <span>=</span> <span>null</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>return</span> successor<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="二分搜索树的-floor-与-ceiling"> 二分搜索树的 floor 与 ceiling</h2>
<p>对于二分查找法来说：<code>floor</code> 地板函数和 <code>ceiling</code>天花板函数是这样定义的：</p>
<p>1、在有很多 <code>target</code> 相同元素的数组中，<code>floor</code> 返回第 1 个出现 <code>target</code> 的元素的索引，<code>ceiling</code> 返回最后一个出现这个元素的索引；</p>
<p>2、在没有 <code>target</code> 元素的数组中，<code>floor</code> 返回的是最后一个比 <code>target</code> 小的元素的索引，<code>ceil</code> 返回的是第 1 个比 <code>target</code> 大的元素的索引。</p>
<p>对于二分搜索树来说：</p>
<p><code>floor(key)</code> 函数返回比 <code>key</code> 小的数的最大值，如果 BST 中没有比 <code>key</code> 小的数，则返回 <code>null</code>。</p>
<p><code>ceiling(key)</code> 函数返回比 <code>key</code> 大的数的最小值，如果 BST 中没有比 <code>key</code> 大的数，则返回 <code>null</code>。</p>
<h3 id="floor-函数的实现-2"> floor 函数的实现</h3>
<div><pre><code><span>// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span>private</span> <span>Integer</span> <span>floor</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>node<span>.</span>key <span>==</span> key<span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>value<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>&lt;</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>floor</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
    <span>Integer</span> tempValue <span>=</span> <span>floor</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>tempValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> tempValue<span>;</span>
    <span>}</span>
    <span>return</span> node<span>.</span>value<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：如果给定的键 key 小于二分搜索树的根结点的键，那么小于等于 key 的最大键 floor(key) 一定位于根结点的左子树中；</p>
<p>如果给定的键 key 大于二分搜索树的根结点的键，分两种情况：</p>
<p>1、当根结点的右子树中存在小于等于 key 的结点的时候，小于等于 key 的最大键才会出现在右子树中；</p>
<p>2、否则根结点就是小于等于 key 的最大键。</p>
<p>我们可以举出一个具体的例子来说明：</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/floor.png" alt="二分搜索树的 floor 操作" loading="lazy"></p>
<p>实现 <code>floor(int key)</code> 函数的关键：</p>
<p>1、利用 BST 的 key 具有顺序性和 BST 的递归性质；</p>
<p>2、写好递归函数，就要处理好递归到底的条件，这里 <code>node == null</code> 和 <code>node.key = key</code> 就是递归终止条件，<strong><code>node == null</code> 直接影响了后续的逻辑</strong>。</p>
<h3 id="ceiling-函数的实现-2"> ceiling 函数的实现</h3>
<div><pre><code><span>// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span>private</span> <span>Integer</span> <span>ceiling</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>==</span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>value<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>key <span>></span> node<span>.</span>key<span>)</span> <span>{</span>
        <span>return</span> <span>ceiling</span><span>(</span>node<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
    <span>Integer</span> tempValue <span>=</span> <span>ceiling</span><span>(</span>node<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>tempValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> tempValue<span>;</span>
    <span>}</span>
    <span>return</span> node<span>.</span>value<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="二分搜索树的深度优先遍历"> 二分搜索树的深度优先遍历</h2>
<p>首先强调一点：深度优先遍历是一个重要的遍历方法，不是只在二分搜索树中才有。更一般地，我们要掌握二叉树的深度优先遍历和图中的深度优先遍历。</p>
<p>二分搜索树的遍历，其实就是挨个把二分搜索树中的元素拿出来，只不过二分搜索树不像数组或者链表那样，有明显的“从头到尾”的性质。但其实<strong>走完一个二分搜索树也是有规律可循的</strong>，其中一种方式就是深度优先遍历。</p>
<p>深度优先遍历的顺序是下面这张图展示的样子。首先尝试走到最深，再回退，再走到另一个分支的最深。</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/二分搜索树的深度优先遍历.jpg" alt="二分搜索树的深度优先遍历" loading="lazy"></p>
<p>那么什么是二分搜索树的前序、中序、后序遍历呢？</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/遍历方式的解释.jpg" alt="二分搜索树的遍历方式的解释" loading="lazy"></p>
<p>把握要点：<strong>通过对深度优先遍历</strong>的遍历路径，我么可以看出，深度优先遍历走完一棵二叉树，每个结点会被访问 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>3</span></span></span></span> 次，分别对应左边、中间和右边，那么在什么位置进行输出，就对应了深度优先遍历的这三种遍历方式：前序遍历，在访问左边位置的时候，进行操作；中序遍历，在访问中间位置的时候，进行操作；后序遍历，在访问右边位置的时候，进行操作；。</p>
<p>使用递归的方式实现的代码编写是异常简单的！下面的图表多看几遍就明白了，千万不要忘记了对 <code>node</code> 是否为 <code>null</code> 的判断。下面用递归的方式编写前、中、后序遍历是十分简单的。它们的结构是完全相同的。</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/前序中序后序遍历.jpg" alt="二分搜索树的前序、中序、后序遍历" loading="lazy"></p>
<p>后序遍历与空间释放</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/后序遍历与空间释放.jpg" alt="二分搜索树的后序遍历与空间释放" loading="lazy"></p>
<p>可以看到，红色标注的部分是结构一致的。</p>
<p>记忆要点：左右子树都是递归处理，树根是真正要执行的操作。后序遍历的一个重要特点：前序和后序都访问完以后，才做操作。</p>
<p>中序遍历的重要结论：中序遍历可以将数据按照从小到大升序排列。</p>
<p>后序遍历的重要结论：后续遍历在空间释放的时候可以先释放左右结点，再释放自身。</p>
<p>Java 代码：</p>
<div><pre><code><span>// 二分搜索树的前序遍历</span>
<span>public</span> <span>void</span> <span>preOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>preOrder</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>preOrder</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"%s "</span><span>,</span> node<span>.</span>value<span>)</span><span>;</span>
        <span>preOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>preOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 二分搜索树的中序遍历</span>
<span>public</span> <span>void</span> <span>inOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>inOrder</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>inOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"%s "</span><span>,</span> node<span>.</span>value<span>)</span><span>;</span>
        <span>inOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 二分搜索树的后序遍历</span>
<span>public</span> <span>void</span> <span>postOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>postOrder</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>postOrder</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>postOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>postOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>补充知识：使用非递归的方法完成二叉树树的三种深度优先遍历。</p>
<h2 id="二分搜索树的广度优先遍历"> 二分搜索树的广度优先遍历</h2>
<p>重点：广度优先遍历区别于深度优先遍历的方式是<strong>我们首先将每一层的结点优先遍历完毕</strong>。</p>
<p>要想完成广度优先遍历，我们要借助队列（先进先出，后进后出）这个数据结构。</p>
<p>具体实现方式 ：当队列中的队首出队的时候，要从二叉搜索树中找到它的两个孩子入队（如果有左边孩子的话，左边先入队）。队列出队为空的时候，就将二叉树遍历完成了。</p>
<p>我们再归纳一下广度优先遍历的步骤：</p>
<p>1、将根结点入队（入队的时候不做别的操作）；</p>
<p>2、队列非空，所以接下来就要出队，规则是：依次出队，只要出队的元素有孩子，左右孩子依次入队，如果没有孩子不做任何操作。</p>
<p>Java 代码：</p>
<div><pre><code><span>// 二分搜索树的广度优先遍历(层序遍历)</span>
<span>public</span> <span>void</span> <span>levelOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>Queue</span><span><span>&lt;</span><span>Node</span><span>></span></span> queue <span>=</span> <span>new</span> <span>ArrayDeque</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>Node</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>node<span>.</span>key<span>)</span><span>;</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下的总结是针对深度优先遍历的 3 种方式和广度优先的 1 种方式，总共 4 种遍历方式而言的：整个遍历的复杂度是：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span>。</p>
<p>不论是深度优先遍历还是广度优先遍历，对于二分搜索树来说，每一个结点只访问了常数次；</p>
<blockquote>
<p><strong>归并排序和快速排序的本质其实是二叉树的深度优先遍历的过程</strong>。</p>
</blockquote>
<p>重点把握思想：1、递归调用；2、使用队列实现一个更加复杂的算法的过程（这种按顺序访问的情况，可以使用队列）。</p>
<h2 id="二分搜索树的代码实现"> 二分搜索树的代码实现</h2>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>BST</span><span>:</span>
    <span>class</span> <span>Node</span><span>:</span>
        <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> key<span>,</span> val<span>,</span> N<span>)</span><span>:</span>
            self<span>.</span>key <span>=</span> key
            self<span>.</span>val <span>=</span> val
            <span># 以该结点为根的子树中的结点总数</span>
            self<span>.</span>N <span>=</span> N
            <span># 指向子树的链接</span>
            self<span>.</span>left <span>=</span> <span>None</span>
            self<span>.</span>right <span>=</span> <span>None</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>root <span>=</span> <span>None</span>

    <span>def</span> <span>size</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>get_size<span>(</span>self<span>.</span>root<span>)</span>

    <span>def</span> <span>get_size</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>if</span> node <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>0</span>
        <span>else</span><span>:</span>
            <span>return</span> node<span>.</span>N

    <span>def</span> <span>get</span><span>(</span>self<span>,</span> key<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>__get_from_node<span>(</span>self<span>.</span>root<span>,</span> key<span>)</span>

    <span>def</span> <span>__get_from_node</span><span>(</span>self<span>,</span> node<span>,</span> key<span>)</span><span>:</span>
        <span>if</span> node <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>None</span>
        <span>if</span> key <span>&lt;</span> node<span>.</span>key<span>:</span>
            <span>return</span> self<span>.</span>__get_from_node<span>(</span>node<span>.</span>left<span>,</span> key<span>)</span>
        <span>elif</span> key <span>></span> node<span>.</span>key<span>:</span>
            <span>return</span> self<span>.</span>__get_from_node<span>(</span>node<span>.</span>right<span>,</span> key<span>)</span>
        <span>else</span><span>:</span>
            <span>return</span> node<span>.</span>val

    <span>def</span> <span>put</span><span>(</span>self<span>,</span> key<span>,</span> val<span>)</span><span>:</span>
        <span># 注意：这里是赋值的关系</span>
        self<span>.</span>root <span>=</span> self<span>.</span>__put_to_bst<span>(</span>self<span>.</span>root<span>,</span> key<span>,</span> val<span>)</span>

    <span>def</span> <span>__put_to_bst</span><span>(</span>self<span>,</span> node<span>,</span> key<span>,</span> val<span>)</span><span>:</span>
        <span>if</span> node <span>is</span> <span>None</span><span>:</span>
            <span># 注意：这里叶子结点要把 1 传进去</span>
            <span>return</span> BST<span>.</span>Node<span>(</span>key<span>,</span> val<span>,</span> <span>1</span><span>)</span>
        <span># 此时 node 不为空</span>
        <span>if</span> key <span>&lt;</span> node<span>.</span>key<span>:</span>
            node<span>.</span>left <span>=</span> self<span>.</span>__put_to_bst<span>(</span>node<span>.</span>left<span>,</span> key<span>,</span> val<span>)</span>
        <span>elif</span> key <span>></span> node<span>.</span>key<span>:</span>
            node<span>.</span>right <span>=</span> self<span>.</span>__put_to_bst<span>(</span>node<span>.</span>right<span>,</span> key<span>,</span> val<span>)</span>
        <span>else</span><span>:</span>
            <span># 更新</span>
            node<span>.</span>val <span>=</span> val

        <span># 注意这一行代码</span>
        node<span>.</span>N <span>=</span> self<span>.</span>get_size<span>(</span>node<span>.</span>left<span>)</span> <span>+</span> self<span>.</span>get_size<span>(</span>node<span>.</span>right<span>)</span> <span>+</span> <span>1</span>
        <span># 注意：最后都要将 node 返回回去</span>
        <span>return</span> node


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    bst <span>=</span> BST<span>(</span><span>)</span>
    bst<span>.</span>put<span>(</span><span>1</span><span>,</span> <span>100</span><span>)</span>
    bst<span>.</span>put<span>(</span><span>2</span><span>,</span> <span>200</span><span>)</span>
    bst<span>.</span>put<span>(</span><span>3</span><span>,</span> <span>300</span><span>)</span>
    bst<span>.</span>put<span>(</span><span>4</span><span>,</span> <span>400</span><span>)</span>

    <span>print</span><span>(</span>bst<span>.</span>size<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><p>Java 代码：<a href="https://gist.github.com/liweiwei1419/490d6fa4a92b88b166e5680978858034" target="_blank" rel="noopener noreferrer">这里<i>Content not supported</i></a>。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BST1.java</td>
<td>二分搜索树树的框架。</td>
</tr>
<tr>
<td>BST2.java</td>
<td>在上一版基础上添加了 insert 操作。</td>
</tr>
<tr>
<td>BST3.java</td>
<td>在上一版基础上添加了 contain 和 search 操作。</td>
</tr>
<tr>
<td>BST4.java</td>
<td>在上一版基础上添加了三种深度优先遍历操作（递归实现）。</td>
</tr>
<tr>
<td>BST5.java</td>
<td>在上一版基础上添加了广度优先遍历（层序遍历）的操作。</td>
</tr>
<tr>
<td>BST6.java</td>
<td>在上一版基础上添加了删除以某个结点为根的二分搜索树的操作（<strong>特别注意的一点是：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</strong>）。</td>
</tr>
<tr>
<td>BST7.java</td>
<td>在上一版基础上添加了删除一个结点的操作。直接让我们操作可能会有很多种情况以及一些细节没有考虑到。不过好在计算机科学家为我们解决了这个问题。这里用到的是  Hibbard Deletion 删除法。<strong>算法设计思路</strong>如下：（1）如果要删除的结点是最小值、最大值结点，很容易就删除了（即使最小值结点有右孩子，最大值结点有左孩子），此时删除了以后一定记得把新的二分搜索树的根结点返回回去；（2）如果要删除的结点是非叶子结点，我们可以使用这个结点的直接前驱或者直接后继来代替这个结点，这样就完成了结点的删除操作。</td>
</tr>
</tbody>
</table>
<h3 id="小结"> 小结</h3>
<p>1、堆是二叉树结构，但不是二分搜索树结构；</p>
<p>2、查找相关的问题：min、max、rank、select、floor、ceiling；</p>
<p>3、什么是完全二叉树、什么是满二叉树；</p>
<p>4、注意为 BST 增加（insert） 结点，使用递归方法将结点挂接到原来的结点上，那么如何写非递归的实现呢？</p>
<p>5、使用 BST 还可以解决一些例如逆序对这类的问题；</p>
<p>6、删除二分搜索树的结点（<strong>其实就是分类讨论</strong>），应该要做一下总结，否则每次都忘记；</p>
<p>7、BST 更一般地，二叉树的 4 种遍历方式、广度优先遍历，要设置一个队列，深度优先遍历不论是递归还是非递归都和栈有关系。</p>
<p>LeetCode 第 220 题。</p>
<h2 id="二分搜索树的顺序性"> 二分搜索树的顺序性</h2>
<p>之前我们将二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。</p>
<p>二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。</p>
<p>1、minimum，maximum；</p>
<p>2、successor，predecessor（这两个元素在二分搜索树的 key 中必须存在）；</p>
<p>3、floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在）；</p>
<p>4、rank（58 是排名第几的元素）、select（排名第10的元素是谁，这个问题与 rank 正好相反）。</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/rank.jpg" alt="二分搜索树的 rank 操作" loading="lazy"></p>
<p>之前，我们的二分搜索树并不支持有重复元素的二分搜索树。在有些情况下，我们须要支持重复元素的二分搜索树。</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/支持重复元素的二分搜索树.jpg" alt="支持重复元素的二分搜索树" loading="lazy"></p>
<h2 id="二分搜索树的局限性"> 二分搜索树的局限性</h2>
<p>二分查找树的性能。二分查找树在一些极端情况下性能并不好。我们首先要认识下面一个事实：同样的数据，可以对应不同的二分搜索树。看下面的例子。</p>
<p><img src="https://liweiwei1419.github.io/images/algorithms/bst/可以对应不同的二分搜索树.jpg" alt="可以对应不同的二分搜索树" loading="lazy"></p>
<p>此时二分搜索树可以<strong>退化为链表</strong>。此时时间复杂度变成了 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span>。我们可以做一个极端测试：如果把 key 排序好以后，依次插入到二分搜索树中，此时二分搜索树的高度就会变得非常高。</p>
<p>解决方案：改造二叉树的实现，使得二叉树无法成为链表。1、使用平衡二叉树；2、使用红黑树（<strong>红黑树是一种平衡二叉树的实现</strong>，其它平衡二叉树的实现还有 2-3 tree，AVL tree，Splay tree 伸展树，平衡二叉树和堆的结合：Treap）。左右两棵子树的高度差不会超过1。</p>
<p>一个很有意思的数据结构：Trie，其设计巧妙，实现并不难。</p>
<p>![前缀树](https://liweiwei1419.github.io/images/algorithms/bst/前缀树 trie.jpg)</p>
<h2 id="树形问题和更多树"> 树形问题和更多树</h2>
<p>虽然没有创建树。递归方法天然地具有递归的性质。归并排序法和快速排序法的思想它们像极了对一棵树进行后序遍历和前序遍历。<strong>递归的思想</strong>大量应用于搜索问题：一条龙游戏、8 数码、8皇后、数独、搬运工、人工智能：搬运工，<strong>树形搜索</strong>、机器学习。更多的树还有：KD 树，区间树，哈夫曼树。这一节的最后，老师介绍了很多开放的问题，帮助我们培养对算法的兴趣。</p>
<h3 id="本文源代码"> 本文源代码</h3>
<p>Python：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Python/tree/master/bst" target="_blank" rel="noopener noreferrer">代码文件夹<i>Content not supported</i></a>，Java：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Java/tree/master/08-Binary-Search-Tree/src" target="_blank" rel="noopener noreferrer">代码文件夹<i>Content not supported</i></a>。</p>
<p>（本节完）</p>
<h2 id="二分搜索树"> 二分搜索树</h2>
<hr>
<p>title: 「树」专题 6：二分搜索树中的问题
icon: yongyan
category: 二叉树
tags:</p>
<ul>
<li>二叉树</li>
<li>递归</li>
</ul>
<hr>
<h2 id="「树」专题-6-二分搜索树中的问题"> 「树」专题 6：二分搜索树中的问题</h2>
<h3 id="回顾二分搜索树的定义"> 回顾二分搜索树的定义</h3>
<h3 id="二分搜索树的重要性质"> 二分搜索树的重要性质</h3>
<p>二分搜索树的重要性质如下，初学的时候经常会被忽略或者错误地理解：</p>
<ul>
<li>左子树中所有的结点<strong>都小于</strong>当前结点；</li>
<li>右子树中所有的结点<strong>都大于</strong>当前结点。</li>
<li>以左右孩子为根的子树仍为二分搜索树。</li>
</ul>
<h3 id="回顾二分搜索树中的基本操作"> 回顾二分搜索树中的基本操作</h3>
<p>既然学习到这个专题，我们就有必要来复习巩固之前在学习《二分搜索树》的时候所进行的一些基本操作，这些操作都是十分重要而且基础的。由于二分搜索树的性质，我们总能以 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.01968em;">l</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>n</span><span>)</span></span></span></span> 时间复杂度来完成上面的操作。</p>
<p>1、插入 insert</p>
<p>2、查找 find</p>
<p>3、删除 delete</p>
<p>4、最大值，最小值 minimum, maximum</p>
<p>5、前驱，后继 successor, predecessor</p>
<p>6、上界，下界 floor, ceil</p>
<p>7、某个元素的排名 rank</p>
<p>8、寻找第 k大（小）元素 select</p>
<p>9、如何将二分搜索树改造成平衡搜索树，平衡搜索树的一个重要应用就是红黑树。</p>
<h2 id="例题"> 例题</h2>
]]></content>
    <author>
      <name>liwei</name>
    </author>
    <category term="算法与数据结构" scheme=""/>
    <contributor>
      <name>liwei</name>
    </contributor>
    <published>2018-04-23T08:00:00.000Z</published>
    <rights>Copyright by liwei</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 95 题：不同的二叉搜索树 II（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0095-unique-binary-search-trees-ii/</id>
    <link href="https://suanfa8.com/tree/solutions/0095-unique-binary-search-trees-ii/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener noreferrer">95. 不同的二叉搜索树 II<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：n = 1
输出：[[1]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<h2 id="方法一-递归-分治法"> 方法一：递归（分治法）</h2>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>


<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>// 递归（分支）</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateTrees</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>generateTrees</span><span>(</span><span>1</span><span>,</span> n<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateTrees</span><span>(</span><span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>left <span>></span> right<span>)</span> <span>{</span>
            <span>// 上层调用的方法须要这个空结点作为其左结点或者右节点</span>
            res<span>.</span><span>add</span><span>(</span><span>null</span><span>)</span><span>;</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>left <span>==</span> right<span>)</span> <span>{</span>
            <span>// 只有一个结点，这个结点作为根结点返回即可</span>
            <span>// 这一步可以包括到下面一个情况中</span>
            res<span>.</span><span>add</span><span>(</span><span>new</span> <span>TreeNode</span><span>(</span>left<span>)</span><span>)</span><span>;</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left<span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> leftList <span>=</span> <span>generateTrees</span><span>(</span>left<span>,</span> i <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> rightList <span>=</span> <span>generateTrees</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>TreeNode</span> leftTree <span>:</span> leftList<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>TreeNode</span> rightTree <span>:</span> rightList<span>)</span> <span>{</span>
                    <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>i<span>)</span><span>;</span>
                    root<span>.</span>left <span>=</span> leftTree<span>;</span>
                    root<span>.</span>right <span>=</span> rightTree<span>;</span>
                    res<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>可以把 <code>left == right</code> 的情况去掉。</p>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution2</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateTrees</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>generateTrees</span><span>(</span><span>1</span><span>,</span> n<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateTrees</span><span>(</span><span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>left <span>></span> right<span>)</span> <span>{</span>
            <span>// 这个位置要占住</span>
            res<span>.</span><span>add</span><span>(</span><span>null</span><span>)</span><span>;</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left<span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>TreeNode</span> leftTree <span>:</span> <span>generateTrees</span><span>(</span>left<span>,</span> i <span>-</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>TreeNode</span> rightTree <span>:</span> <span>generateTrees</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>)</span> <span>{</span>
                    <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>i<span>)</span><span>;</span>
                    root<span>.</span>left <span>=</span> leftTree<span>;</span>
                    root<span>.</span>right <span>=</span> rightTree<span>;</span>
                    res<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="方法二-动态规划"> 方法二：动态规划</h2>
<p><strong>参考代码 3</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>/**
 * 动态规划的解法
 */</span>
<span>public</span> <span>class</span> <span>Solution4</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateTrees</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>ArrayList</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
        res<span>[</span><span>0</span><span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>n <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> res<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>}</span>
        <span>// 注意这个位置</span>
        res<span>[</span><span>0</span><span>]</span><span>.</span><span>add</span><span>(</span><span>null</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 先将对象数组初始化</span>
            res<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>TreeNode</span> left <span>:</span> res<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                    <span>for</span> <span>(</span><span>TreeNode</span> right <span>:</span> res<span>[</span>i <span>-</span> j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
                        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>j <span>+</span> <span>1</span><span>)</span><span>;</span>
                        root<span>.</span>left <span>=</span> left<span>;</span>
                        root<span>.</span>right <span>=</span> <span>clone</span><span>(</span>right<span>,</span> j <span>+</span> <span>1</span><span>)</span><span>;</span>
                        res<span>[</span>i<span>]</span><span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>[</span>n<span>]</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>TreeNode</span> <span>clone</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> root<span>;</span>
        <span>}</span>
        <span>TreeNode</span> curNode <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>root<span>.</span>val <span>+</span> k<span>)</span><span>;</span>
        curNode<span>.</span>left <span>=</span> <span>clone</span><span>(</span>root<span>.</span>left<span>,</span> k<span>)</span><span>;</span>
        curNode<span>.</span>right <span>=</span> <span>clone</span><span>(</span>root<span>.</span>right<span>,</span> k<span>)</span><span>;</span>
        <span>return</span> curNode<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 98 题：验证二叉搜索树（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0098-validate-binary-search-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0098-validate-binary-search-tree/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">98. 验证二叉搜索树<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [2,1,3]
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>二分搜索树定义 3 条，根据定义判断其实是最简单的，在技巧上就是要分一下，是左子树还是右子树。</p>
<h3 id="方法一-中序遍历判断有序性"> 方法一： 中序遍历判断有序性</h3>
<blockquote>
<p>说明：这个方法是最容易想到的，直接利用了「二叉搜索树」中序遍历的性质。</p>
</blockquote>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>isValidBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>inOrder</span><span>(</span>root<span>,</span> res<span>)</span><span>;</span>

        <span>int</span> len <span>=</span> res<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>res<span>.</span><span>get</span><span>(</span>i<span>)</span> <span>>=</span> res<span>.</span><span>get</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> treeNode<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>treeNode <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>inOrder</span><span>(</span>treeNode<span>.</span>left<span>,</span> res<span>)</span><span>;</span>
        res<span>.</span><span>add</span><span>(</span>treeNode<span>.</span>val<span>)</span><span>;</span>
        <span>inOrder</span><span>(</span>treeNode<span>.</span>right<span>,</span> res<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="方法二-中序遍历"> 方法二：中序遍历</h2>
<p>分析：这个方法知道就可以了。</p>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution2</span> <span>{</span>

    <span>private</span> <span>long</span> last <span>=</span> <span>Long</span><span>.</span>MIN_VALUE<span>;</span>

    <span>public</span> <span>boolean</span> <span>isValidBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>isValidBST</span><span>(</span>root<span>.</span>left<span>)</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>last <span>&lt;</span> root<span>.</span>val<span>)</span> <span>{</span>
                last <span>=</span> root<span>.</span>val<span>;</span>
                <span>return</span> <span>isValidBST</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="方法三-深度优先遍历"> 方法三：深度优先遍历</h2>
<p>即「依据定义」，前序遍历。</p>
<p><strong>参考代码 3</strong>：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>


<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>isValidBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>// 依据定义</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>dfs</span><span>(</span>root<span>.</span>left<span>,</span> root<span>.</span>val<span>,</span> <span>true</span><span>)</span> <span>&amp;&amp;</span>
                <span>dfs</span><span>(</span>root<span>.</span>right<span>,</span> root<span>.</span>val<span>,</span> <span>false</span><span>)</span> <span>&amp;&amp;</span>
                <span>isValidBST</span><span>(</span>root<span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isValidBST</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * @param node   当前结点
     * @param val    父亲结点的值
     * @param ifLeft 表示传入的结点是否是左结点
     * @return
     */</span>
    <span>private</span> <span>boolean</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>int</span> val<span>,</span> <span>boolean</span> ifLeft<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>ifLeft<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>node<span>.</span>val <span>>=</span> val<span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>dfs</span><span>(</span>node<span>.</span>left<span>,</span> val<span>,</span> <span>true</span><span>)</span> <span>&amp;&amp;</span> <span>dfs</span><span>(</span>node<span>.</span>right<span>,</span> val<span>,</span> <span>true</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>if</span> <span>(</span>node<span>.</span>val <span>&lt;=</span> val<span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>dfs</span><span>(</span>node<span>.</span>left<span>,</span> val<span>,</span> <span>false</span><span>)</span> <span>&amp;&amp;</span> <span>dfs</span><span>(</span>node<span>.</span>right<span>,</span> val<span>,</span> <span>false</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><ul>
<li>另一种写法</li>
</ul>
<p><strong>参考代码 4</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>isValidBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>dfs</span><span>(</span>root<span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>Integer</span> min<span>,</span> <span>Integer</span> max<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>min <span>!=</span> <span>null</span> <span>&amp;&amp;</span> node<span>.</span>val <span>&lt;=</span> min<span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>max <span>!=</span> <span>null</span> <span>&amp;&amp;</span> node<span>.</span>val <span>>=</span> max<span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>dfs</span><span>(</span>node<span>.</span>left<span>,</span> min<span>,</span> node<span>.</span>val<span>)</span> <span>&amp;&amp;</span> <span>dfs</span><span>(</span>node<span>.</span>right<span>,</span> node<span>.</span>val<span>,</span> max<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 108 题：将有序数组转换为二叉搜索树（简单）</title>
    <id>https://suanfa8.com/tree/solutions/0108-convert-sorted-array-to-binary-search-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0108-convert-sorted-array-to-binary-search-tree/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">108. 将有序数组转换为二叉搜索树<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/fen-er-zhi-zhi-di-gui-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">分而治之（递归）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="img" loading="lazy"></p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p>思路：题目要求<strong>构建高度平衡二叉搜索树</strong>，找到解决问题的突破口。</p>
<p>1、将有序数组一分为二，中间结点成为根结点，前半部分是左子树，右半部分是右子树；
2、递归构建左子树和右子树，应用到分治思想。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>TreeNode</span> <span>sortedArrayToBST</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>merge</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>TreeNode</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>left <span>></span> right<span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>left <span>==</span> right<span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>TreeNode</span><span>(</span>nums<span>[</span>left<span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>int</span> mid <span>=</span> left <span>+</span> <span>(</span>right <span>-</span> left<span>)</span> <span>/</span> <span>2</span><span>;</span>

        <span>TreeNode</span> treeNode <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>nums<span>[</span>mid<span>]</span><span>)</span><span>;</span>
        treeNode<span>.</span>left <span>=</span> <span>merge</span><span>(</span>nums<span>,</span> left<span>,</span> mid <span>-</span> <span>1</span><span>)</span><span>;</span>
        treeNode<span>.</span>right <span>=</span> <span>merge</span><span>(</span>nums<span>,</span> mid <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>;</span>
        <span>return</span> treeNode<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>from</span> typing <span>import</span> List


<span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>

    <span>def</span> <span>sortedArrayToBST</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>)</span> <span>-</span><span>></span> TreeNode<span>:</span>
        <span>def</span> <span>helper</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>:</span>
            <span>if</span> left <span>></span> right<span>:</span>
                <span>return</span> <span>None</span>

            <span>if</span> left <span>==</span> right<span>:</span>
                <span>return</span> TreeNode<span>(</span>nums<span>[</span>left<span>]</span><span>)</span>

            mid <span>=</span> <span>(</span>left <span>+</span> right<span>)</span> <span>>></span> <span>1</span>
            root <span>=</span> TreeNode<span>(</span>nums<span>[</span>mid<span>]</span><span>)</span>
            root<span>.</span>left <span>=</span> helper<span>(</span>nums<span>,</span> left<span>,</span> mid <span>-</span> <span>1</span><span>)</span>
            root<span>.</span>right <span>=</span> helper<span>(</span>nums<span>,</span> mid <span>+</span> <span>1</span><span>,</span> right<span>)</span>
            <span>return</span> root

        size <span>=</span> <span>len</span><span>(</span>nums<span>)</span>
        <span>if</span> size <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>None</span>
        <span>return</span> helper<span>(</span>nums<span>,</span> <span>0</span><span>,</span> size <span>-</span> <span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code>class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    public TreeNode sortedArrayToBST(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return null;
        }
        return merge(nums, 0, len - 1);
    }

    private TreeNode merge(int[] nums, int left, int right) {
        if (left &gt; right) {
            return null;
        }

        if (left == right) {
            return new TreeNode(nums[left]);
        }

        int mid = (left + right) &gt;&gt;&gt; 1;

        TreeNode treeNode = new TreeNode(nums[mid]);
        treeNode.left = merge(nums, left, mid - 1);
        treeNode.right = merge(nums, mid + 1, right);
        return treeNode;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>

    <span>def</span> <span>sortedArrayToBST</span><span>(</span>self<span>,</span> nums<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>nums<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>None</span>
        <span>return</span> self<span>.</span>__helper<span>(</span>nums<span>,</span> <span>0</span><span>,</span> <span>len</span><span>(</span>nums<span>)</span> <span>-</span> <span>1</span><span>)</span>

    <span>def</span> <span>__helper</span><span>(</span>self<span>,</span> nums<span>,</span> left<span>,</span> right<span>)</span><span>:</span>
        <span># 写递归问题：先写递归终止条件，然后再写递归流程</span>
        <span>if</span> left <span>></span> right<span>:</span>
            <span>return</span> <span>None</span>
        <span>if</span> left <span>==</span> right<span>:</span>
            <span>return</span> TreeNode<span>(</span>nums<span>[</span>left<span>]</span><span>)</span>
        mid <span>=</span> left <span>+</span> <span>(</span>right <span>-</span> left<span>)</span> <span>//</span> <span>2</span>
        root <span>=</span> TreeNode<span>(</span>nums<span>[</span>mid<span>]</span><span>)</span>
        root<span>.</span>left <span>=</span> self<span>.</span>__helper<span>(</span>nums<span>,</span> left<span>,</span> mid <span>-</span> <span>1</span><span>)</span>
        root<span>.</span>right <span>=</span> self<span>.</span>__helper<span>(</span>nums<span>,</span> mid <span>+</span> <span>1</span><span>,</span> right<span>)</span>
        <span>return</span> root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，根据主定理：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.13889em;">T</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.2173em;vertical-align:-0.345em;"></span><span style="margin-right:0.13889em;">T</span><span>(</span><span><span></span><span><span><span><span style="height:0.8723em;"><span style="top:-2.655em;"><span style="height:3em;"></span><span><span><span>2</span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.10903em;">N</span></span></span></span></span><span>​</span></span><span><span style="height:0.345em;"><span></span></span></span></span></span><span></span></span><span>)</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 109 题：有序链表转换二叉搜索树（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0109-convert-sorted-list-to-binary-search-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0109-convert-sorted-list-to-binary-search-tree/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">109. 有序链表转换二叉搜索树<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/fen-zhi-fa-python-dai-ma-java-dai-ma-by-liweiwei14/" target="_blank" rel="noopener noreferrer">分治法（Python 代码、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" alt="img" loading="lazy"></p>
<div><pre><code>Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>Example 2:</strong></p>
<div><pre><code>Input: head = []
Output: []
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: head = [0]
Output: [0]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 4:</strong></p>
<div><pre><code>Input: head = [1,3]
Output: [3,1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10^4]</code>.</li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.136em;"></span><span style="margin-right:0.10903em;">N</span><span>o</span><span>d</span><span>e</span><span>.</span><span style="margin-right:0.03588em;">v</span><span>a</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>思路其实<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a>已经写得非常清楚了，建议看看其中的动画，展示得非常清楚了。</p>
<p>在这里主要想说二叉树的很多问题基本上都可以通过“分而治之”的策略完成。这里首先找到<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/submissions/" target="_blank" rel="noopener noreferrer">单链表的中间结点<i>Content not supported</i></a>，然后递归构造左子树和右子树。还有一种做法是把单链表变成有序数组，这就是 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">「力扣」第 108 题：将有序数组转换为二叉搜索树<i>Content not supported</i></a>。</p>
<p>编码的细节已经体现在代码注释中。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>TreeNode</span> <span>sortedListToBST</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
        <span>// 特判：当结点为空，或者单结点的时候的简单逻辑</span>
        <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>TreeNode</span><span>(</span>head<span>.</span>val<span>)</span><span>;</span>
        <span>}</span>

        <span>// 设置 pre 指针是为了切断单链表 mid 的前半部分</span>
        <span>ListNode</span> pre <span>=</span> <span>null</span><span>;</span>
        <span>ListNode</span> slow <span>=</span> head<span>;</span>
        <span>ListNode</span> fast <span>=</span> head<span>;</span>

        <span>// 如果写 while fast and fast.next: 后面的代码稍有不同</span>
        <span>while</span> <span>(</span>fast<span>.</span>next <span>!=</span> <span>null</span> <span>&amp;&amp;</span> fast<span>.</span>next<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            pre <span>=</span> slow<span>;</span>
            slow <span>=</span> slow<span>.</span>next<span>;</span>
            fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>
        <span>}</span>

        <span>// 此时 slow 结点就位于链表的中部，</span>
        <span>// 它的值就作为 BST 的根结点返回</span>
        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>slow<span>.</span>val<span>)</span><span>;</span>
        <span>// 因为要传入下一个递归方法，所以得先保存索引</span>
        <span>ListNode</span> newHead <span>=</span> slow<span>.</span>next<span>;</span>
        slow<span>.</span>next <span>=</span> <span>null</span><span>;</span>

        <span>// 当链表只有 2 个结点的时候，pre 指针此时为 null，不用递归构造左子树</span>
        <span>if</span><span>(</span>pre <span>!=</span> <span>null</span><span>)</span><span>{</span>
            pre<span>.</span>next <span>=</span> <span>null</span><span>;</span>
            root<span>.</span>left <span>=</span> <span>sortedListToBST</span><span>(</span>head<span>)</span><span>;</span>
        <span>}</span>
        root<span>.</span>right <span>=</span> <span>sortedListToBST</span><span>(</span>newHead<span>)</span><span>;</span>
        <span>return</span> root<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>sortedListToBST</span><span>(</span>self<span>,</span> head<span>:</span> ListNode<span>)</span> <span>-</span><span>></span> TreeNode<span>:</span>
        <span># 特判：当结点为空，或者单结点的时候的简单逻辑</span>
        <span>if</span> head <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>None</span>

        <span>if</span> head<span>.</span><span>next</span> <span>is</span> <span>None</span><span>:</span>
            <span>return</span> TreeNode<span>(</span>head<span>.</span>val<span>)</span>

        <span># 设置 pre 指针是为了切断单链表 mid 的前半部分</span>
        pre <span>=</span> <span>None</span>
        slow <span>=</span> head
        fast <span>=</span> head

        <span># 如果写 while fast and fast.next: 后面的代码稍有不同</span>
        <span>while</span> fast<span>.</span><span>next</span> <span>and</span> fast<span>.</span><span>next</span><span>.</span><span>next</span><span>:</span>
            pre <span>=</span> slow
            slow <span>=</span> slow<span>.</span><span>next</span>
            fast <span>=</span> fast<span>.</span><span>next</span><span>.</span><span>next</span>

        <span># 此时 slow 结点就位于链表的中部，</span>
        <span># 它的值就作为 BST 的根结点返回</span>
        root <span>=</span> TreeNode<span>(</span>slow<span>.</span>val<span>)</span>

        <span># 因为要传入下一个递归方法，所以得先保存索引</span>
        new_head <span>=</span> slow<span>.</span><span>next</span>
        slow<span>.</span><span>next</span> <span>=</span> <span>None</span>

        <span># 当链表只有 2 个结点的时候，pre 指针此时为 None，不用递归构造左子树</span>
        <span>if</span> pre<span>:</span>
            pre<span>.</span><span>next</span> <span>=</span> <span>None</span>
            root<span>.</span>left <span>=</span> self<span>.</span>sortedListToBST<span>(</span>head<span>)</span>
        root<span>.</span>right <span>=</span> self<span>.</span>sortedListToBST<span>(</span>new_head<span>)</span>
        <span>return</span> root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div></CodeGroupItem>
</CodeGroup>
<hr>
<p>补充：</p>
<p>用于测试的结点类（这部分代码不用提交给「力扣」）。</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>ListNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>ListNode</span> next<span>;</span>

    <span>ListNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>

<span>}</span>

<span>class</span> <span>TreeNode</span> <span>{</span>
<span>int</span> val<span>;</span>
<span>TreeNode</span> left<span>;</span>
<span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python">
<div><pre><code><span>class</span> <span>ListNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span><span>next</span> <span>=</span> <span>None</span>


<span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 220 题： 存在重复元素 III（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0220-contains-duplicate-iii/</id>
    <link href="https://suanfa8.com/tree/solutions/0220-contains-duplicate-iii/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目地址：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener noreferrer">220. 存在重复元素 III<i>Content not supported</i></a>；</li>
<li>题解地址：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/hua-dong-chuang-kou-er-fen-sou-suo-shu-zhao-shang-/" target="_blank" rel="noopener noreferrer">暴力解法、滑动窗口（二叉搜索树）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [1,0,1,1], k = 1, t = 2
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [1,5,9,1,5,9], k = 2, t = 3
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.136em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>t</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
<h2 id="题意分析"> 题意分析</h2>
<p>题目让我们找出：<strong>在数组 <code>nums[i]</code> 中，在任意有效区间 <code>[i..i + k]</code> 里是否存在两个数的绝对值小于等于 <code>t</code></strong>，存在则返回 <code>true</code>，不存在返回 <code>false</code>。存在性问题，找到符合题意的「数据对」即可返回 <code>true</code>，所有可能的情况都看完以后，都没有找到才返回 <code>false</code>。</p>
<h2 id="方法一-暴力解法-超时"> 方法一：暴力解法（超时）</h2>
<p>枚举所有长度小于等于 <code>k + 1</code> 的「下标对」 <code>（i, j）</code>，只要发现 <code>nums[i] - nums[j]</code> 的绝对值小于 <code>t</code> ，就返回 <code>true</code>。</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>containsNearbyAlmostDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>,</span> <span>int</span> t<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span> <span>||</span> k <span>&lt;=</span> <span>0</span> <span>||</span> t <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> len<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>// 注意：nums[j] - nums[i] 的结果可能会整型溢出，因此运算之前需要转换成 long 类型</span>
                <span>if</span> <span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span>j <span>-</span> i<span>)</span> <span>&lt;=</span> k <span>&amp;&amp;</span> <span>Math</span><span>.</span><span>abs</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>j<span>]</span> <span>-</span> <span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span><span>)</span> <span>&lt;=</span> t<span>)</span> <span>{</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span style="margin-right:0.10903em;">N</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span>，这里数组的长度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span>，枚举可能的数对 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>i</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.05724em;">j</span><span>)</span></span></span></span> ；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</li>
</ul>
<p>优化的思路是：<strong>空间换时间</strong>，这里的空间还需要有比较大小的功能，比较容易想到的数据结构是二叉搜索树（方法二会说理由）。</p>
<hr>
<h2 id="方法二-滑动窗口-二叉搜索树"> 方法二：滑动窗口 + 二叉搜索树</h2>
<p>题目有两个不确定的因素：</p>
<ul>
<li>两个不同位置下标的差的绝对值小于等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.03148em;">k</span></span></span></span>；</li>
<li>两个不同位置的数值的差的绝对值小于等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6151em;"></span><span>t</span></span></span></span>。</li>
</ul>
<p>暴力解法同时考虑了两个因素，在遍历数组的过程中没有记录下有用的信息。相比于两个不同位置的数值，下标的值是容易掌握的。于是我们可以 <strong>维护长度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的滑动窗口</strong>，把滑动窗口滑过的元素加入一个数据结构，把滑动窗口滑出的元素移出数据结构。（滑动窗口的长度是 <code>k + 1</code>，但是真正数据结构里保存的元素个数可能是 <code>k</code> 也可能是 <code>k + 1</code>，取决于先插入新元素，还是先移除旧元素，这里不展开叙述了。）</p>
<p>我们把题目意思翻译一下：在数组 <code>nums[i]</code> 中，在任意长度大于等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的区间 <code>[i..i + k]</code> 里是否存在两个数的绝对值小于等于 <code>t</code>，即</p>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>∣</span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span><span>∣</span><span style="margin-right:0.2778em;"></span><span>&lt;=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span></span></p>
<p>去掉绝对值符号</p>
<p><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2778em;"></span><span>&lt;=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span> （不等式 1）</p>
<p>并且</p>
<p><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2778em;"></span><span>&gt;=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6984em;vertical-align:-0.0833em;"></span><span>−</span><span>t</span></span></span></span> （不等式 2）。</p>
<p>可以把 <code>nums[i]</code> 看作新遍历到的元素，把 <code>nums[j]</code> 看作当前在滑动窗口中的元素。</p>
<p>根据（不等式 1）得：</p>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>t</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span></span></span></span></span></p>
<p>根据（不等式 2）得：</p>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>t</span><span style="margin-right:0.2778em;"></span><span>≥</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span></span></span></span></span></p>
<p>由此我们可以得到：如果在滑动窗口中能够找到一个元素 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span></span></span></span>，它的值大于等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span>（条件 1），并且还要小于等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span>（条件 2）。</p>
<p>滑动窗口中可以有很多个元素的值满足「条件 1」，为了能够找同时满足两个条件的合适的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span></span></span></span>，由于「条件 2」中 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span> 的值是固定的，为了让「条件 2」有更多的可能性成立，「条件 1」找到的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span></span></span></span> 需要尽可能小，这件事情等价于找到大于等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span> 的最小的值，即找到 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span> 的最小上界。</p>
<hr>
<h2 id="为什么使用二分搜索树"> 为什么使用二分搜索树</h2>
<p><strong>理由 1</strong>：由于维护的是固定长度的一系列数，除了最开始的几个数添加进数据结构以外。</p>
<ul>
<li>当程序看到下标为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的元素的时候，就需要移除下标为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的元素；</li>
<li>当程序看到下标为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的元素的时候，就需要移除下标为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的元素。</li>
</ul>
<p>频繁的删除和添加元素，符合条件的数据结构是「查找表」，「查找表」的两种实现分别是「哈希表」和「二分搜索树（红黑树）」。</p>
<p><strong>理由 2</strong>：根据上面的分析，我们需要找到 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6151em;"></span><span>t</span></span></span></span> 的最小上界，「哈希表」是不维护元素顺序性的，而「二分搜索树」恰好维护了顺序性，是当前场景下合适的数据结构。</p>
<p>Java 的 <code>ceiling(key)</code> 函数提供了这样的功能：返回大于等于 <code>key</code> 的最小元素，如果不存在，返回空。下面的是这个函数的文档（通过 Intellij IDEA 查看）。</p>
<div><pre><code><span>/**
  * Returns the least key greater than or equal to the given key,
  * or {@code null} if there is no such key.
  *
  * @param key the key
  * @return the least key greater than or equal to {@code key},
  *         or {@code null} if there is no such key
  * @throws ClassCastException if the specified key cannot be compared
  *         with the keys currently in the map
  * @throws NullPointerException if the specified key is null
  *         and this map does not permit null keys
  */</span>
<span>K</span> <span>ceilingKey</span><span>(</span><span>K</span> key<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>TreeSet</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>containsNearbyAlmostDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>,</span> <span>int</span> t<span>)</span> <span>{</span>
        <span>// 滑动窗口结合查找表，此时滑动窗口即为查找表本身（控制查找表的大小即可控制窗口大小）</span>
        <span>TreeSet</span><span><span>&lt;</span><span>Long</span><span>></span></span> set <span>=</span> <span>new</span> <span>TreeSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 边添加边查找，查找表中是否有大于等于 nums[i] - t 且小于等于 nums[i] + t 的值</span>
            <span>Long</span> ceiling <span>=</span> set<span>.</span><span>ceiling</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>(</span><span>long</span><span>)</span> t<span>)</span><span>;</span>
            <span>if</span> <span>(</span>ceiling <span>!=</span> <span>null</span> <span>&amp;&amp;</span> ceiling <span>&lt;=</span> <span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span> <span>+</span> <span>(</span><span>long</span><span>)</span> t<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
            <span>// 添加后，控制查找表（窗口）大小，移除窗口最左边元素</span>
            set<span>.</span><span>add</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>set<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> k <span>+</span> <span>1</span><span>)</span> <span>{</span>
                set<span>.</span><span>remove</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i <span>-</span> k<span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.07153em;">K</span><span>)</span></span></span></span>，遍历数组使用 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，在遍历的同时向二叉搜索树中插入元素和移除元素的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.07153em;">K</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.07153em;">K</span><span>)</span></span></span></span>。</li>
</ul>
<p>另一种写法：在一开始就把滑动窗口左边的元素删除。</p>
<p><strong>参考代码 3</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>TreeSet</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>containsNearbyAlmostDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>,</span> <span>int</span> t<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>// 特判</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span> <span>||</span> k <span>&lt;=</span> <span>0</span> <span>||</span> t <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>TreeSet</span><span><span>&lt;</span><span>Long</span><span>></span></span> set <span>=</span> <span>new</span> <span>TreeSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>i <span>></span> k<span>)</span> <span>{</span>
                set<span>.</span><span>remove</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i <span>-</span> k <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
            <span>}</span>

            <span>Long</span> ceiling <span>=</span> set<span>.</span><span>ceiling</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>(</span><span>long</span><span>)</span> t<span>)</span><span>;</span>
            <span>if</span> <span>(</span>ceiling <span>!=</span> <span>null</span> <span>&amp;&amp;</span> ceiling <span>&lt;=</span> <span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span> <span>+</span> <span>(</span><span>long</span><span>)</span> t<span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>

            set<span>.</span><span>add</span><span>(</span><span>(</span><span>long</span><span>)</span> nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>复杂度分析</strong>：（同上）</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二分搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 230 题：二叉搜索树中第 K 小的元素（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0230-kth-smallest-element-in-a-bst/</id>
    <link href="https://suanfa8.com/tree/solutions/0230-kth-smallest-element-in-a-bst/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener noreferrer">230. 二叉搜索树中第 K 小的元素<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/di-gui-yu-fei-di-gui-xie-fa-tong-li-wan-cheng-di-1/" target="_blank" rel="noopener noreferrer">递归与非递归写法（同理完成第 144、94、145 题，Python 代码、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [3,1,4,null,2], k = 1
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 10^4</code></li>
<li><code>0 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<p>**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<h2 id="思路分析"> 思路分析</h2>
<p>利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.03148em;">k</span></span></span></span> 个数即可。</p>
<blockquote>
<p>我写下来发现递归的写法比较容易写错，要设置全局变量，而非递归的写法还相对比较“通用”且好理解。</p>
</blockquote>
<p><strong>参考代码 1</strong>：使用递归“中序遍历”。</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>

<span># 使用递归的方法，中序遍历</span>

<span>class</span> <span>Solution</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>counter <span>=</span> <span>0</span>
        self<span>.</span>res <span>=</span> <span>0</span>

    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        <span># 递归执行左子树的逻辑</span>
        <span>if</span> root<span>.</span>left<span>:</span>
            <span># 不是空，才继续遍历</span>
            self<span>.</span>kthSmallest<span>(</span>root<span>.</span>left<span>,</span> k<span>)</span>

        <span># 在这里执行操作，数到第 k 个即可</span>
        self<span>.</span>counter <span>+=</span> <span>1</span>
        <span># print(root.val)</span>
        <span>if</span> self<span>.</span>counter <span>==</span> k<span>:</span>
            <span># 注意：千万不能在这里返回，后序遍历还要继续进行下去</span>
            self<span>.</span>res <span>=</span> root<span>.</span>val
            <span># 注意：这里不能加 return</span>

        <span># 递归执行右子树的逻辑</span>
        <span>if</span> root<span>.</span>right<span>:</span>
            self<span>.</span>kthSmallest<span>(</span>root<span>.</span>right<span>,</span> k<span>)</span>
        <span>return</span> self<span>.</span>res


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    node3 <span>=</span> TreeNode<span>(</span><span>3</span><span>)</span>
    node1 <span>=</span> TreeNode<span>(</span><span>1</span><span>)</span>
    node4 <span>=</span> TreeNode<span>(</span><span>4</span><span>)</span>
    node2 <span>=</span> TreeNode<span>(</span><span>2</span><span>)</span>

    node3<span>.</span>left <span>=</span> node1
    node3<span>.</span>right <span>=</span> node4
    node1<span>.</span>right <span>=</span> node2

    solution <span>=</span> Solution<span>(</span><span>)</span>
    result <span>=</span> solution<span>.</span>kthSmallest<span>(</span>node3<span>,</span> k<span>=</span><span>1</span><span>)</span>
    <span>print</span><span>(</span>result<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>// 解题关键：中序遍历</span>
<span>// https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/</span>
<span>// 给定一个二叉搜索树，编写一个函数kthSmallest来查找其中第 k 个最小的元素。</span>
<span>// 只要利用二分搜索树的中序遍历，就可以完成。</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>int</span> res <span>=</span> <span>0</span><span>;</span>

    <span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 什么都不做</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>dfs</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>res <span>=</span> node<span>.</span>val<span>;</span>
        <span>}</span>
        <span>dfs</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>

    <span>// k 如果在方法传递的过程中是值传递，所以把它设置为成员变量，这样就是引用传递</span>
    <span>// 因为我们要用到 k 全局的值，去数出，我是第几个中序遍历到的值</span>
    <span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        count <span>=</span> k<span>;</span>
        <span>dfs</span><span>(</span>root<span>)</span><span>;</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TreeNode</span> treeNode1 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>TreeNode</span> treeNode2 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>15</span><span>)</span><span>;</span>
        <span>TreeNode</span> treeNode3 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>20</span><span>)</span><span>;</span>
        treeNode2<span>.</span>left <span>=</span> treeNode1<span>;</span>
        treeNode2<span>.</span>right <span>=</span> treeNode3<span>;</span>
        <span>Solution</span> solution <span>=</span> <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> kthSmallest <span>=</span> solution<span>.</span><span>kthSmallest</span><span>(</span>treeNode2<span>,</span> <span>2</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>kthSmallest<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>下面是 Python 的另一种写法：使用 <code>global</code> 关键字，仍需使用辅助函数：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        <span>global</span> counter<span>,</span> res
        counter <span>=</span> <span>0</span>
        res <span>=</span> <span>0</span>

        <span>def</span> <span>dfs</span><span>(</span>root<span>,</span> k<span>)</span><span>:</span>
            <span>if</span> <span>not</span> root<span>:</span>
                <span># 如果是空，直接退出</span>
                <span>return</span>
            dfs<span>(</span>root<span>.</span>left<span>,</span> k<span>)</span>
            <span>global</span> counter<span>,</span> res
            counter <span>+=</span> <span>1</span>
            <span>if</span> counter <span>==</span> k<span>:</span>
                res <span>=</span> root<span>.</span>val
            dfs<span>(</span>root<span>.</span>right<span>,</span> k<span>)</span>

        dfs<span>(</span>root<span>,</span> k<span>)</span>
        <span>return</span> res

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>参考代码 2</strong>：模拟系统栈的方式：使用二叉树非递归遍历的通用方法。使用同样的的方法还可以解决 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">「力扣」LeetCode 第 144 题：二叉树的前序遍历<i>Content not supported</i></a>、<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal" target="_blank" rel="noopener noreferrer">「力扣」第 94 题：二叉树的中序遍历<i>Content not supported</i></a>、<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener noreferrer">「力扣」第 145 题：二叉树的后序遍历<i>Content not supported</i></a>。</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>

    <span># 模拟系统栈的方式实现，是一种比较通用的做法，</span>
    <span># 可以作为二叉树的三种非递归遍历</span>

    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        <span># 0 表示当前遍历到它，1 表示压入栈</span>
        <span># 刚开始是 1 ，不要写成 0 了</span>
        stack <span>=</span> <span>[</span><span>(</span><span>1</span><span>,</span> root<span>)</span><span>]</span>

        <span>while</span> stack<span>:</span>
            command<span>,</span> node <span>=</span> stack<span>.</span>pop<span>(</span><span>)</span>
            <span>if</span> node <span>is</span> <span>None</span><span>:</span>
                <span># 不能写 return ，这不是递归</span>
                <span>continue</span>
            <span>if</span> command <span>==</span> <span>0</span><span>:</span>
                k <span>-=</span> <span>1</span>
                <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                    <span>return</span> node<span>.</span>val
            <span>else</span><span>:</span>
                <span># 此时 command == 1 的时候，表示递归遍历到的</span>
                <span># 注意：写的时候倒过来写</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>right<span>)</span><span>)</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>0</span><span>,</span> node<span>)</span><span>)</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>left<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>其实入栈的时候，就可以判断，我们只将非空结点入栈，<strong>推荐下面这种写法</strong>：</p>
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        stack <span>=</span> <span>[</span><span>(</span><span>1</span><span>,</span> root<span>)</span><span>]</span>
        <span>while</span> stack<span>:</span>
            command<span>,</span> node <span>=</span> stack<span>.</span>pop<span>(</span><span>)</span>
            <span>if</span> command <span>==</span> <span>0</span><span>:</span>
                k <span>-=</span> <span>1</span>
                <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                    <span>return</span> node<span>.</span>val
            <span>else</span><span>:</span>
                <span># 模拟系统栈实现中序遍历(先左边、再自己、再右边)</span>
                <span># 注意：写的时候倒过来写</span>
                <span>if</span> node<span>.</span>right<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>right<span>)</span><span>)</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>0</span><span>,</span> node<span>)</span><span>)</span>
                <span>if</span> node<span>.</span>left<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>left<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Stack</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution4</span> <span>{</span>

    <span>private</span> <span>enum</span> <span>Action</span> <span>{</span>
        <span>// GO 表示递归处理</span>
        <span>// ADDTORESULT 表示当前马上执行将结点的值添加到结果集中</span>
        GO<span>,</span> ADDTORESULT
    <span>}</span>

    <span>private</span> <span>class</span> <span>Command</span> <span>{</span>
        <span>private</span> <span>Action</span> action<span>;</span>
        <span>private</span> <span>TreeNode</span> node<span>;</span>

        <span>public</span> <span>Command</span><span>(</span><span>Action</span> action<span>,</span> <span>TreeNode</span> node<span>)</span> <span>{</span>
            <span>this</span><span>.</span>action <span>=</span> action<span>;</span>
            <span>this</span><span>.</span>node <span>=</span> node<span>;</span>
        <span>}</span>
    <span>}</span>


    <span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>Stack</span><span><span>&lt;</span><span>Command</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>GO<span>,</span> root<span>)</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Command</span> cur <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            <span>TreeNode</span> node <span>=</span> cur<span>.</span>node<span>;</span>
            <span>if</span> <span>(</span>cur<span>.</span>action <span>==</span> <span>Action</span><span>.</span>ADDTORESULT<span>)</span> <span>{</span>
                k<span>--</span><span>;</span>
                <span>if</span> <span>(</span>k <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    <span>return</span> node<span>.</span>val<span>;</span>
                <span>}</span>

            <span>}</span> <span>else</span> <span>{</span>
                <span>assert</span> cur<span>.</span>action <span>==</span> <span>Action</span><span>.</span>GO<span>;</span>
                <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>GO<span>,</span> node<span>.</span>right<span>)</span><span>)</span><span>;</span>
                <span>}</span>
                stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>ADDTORESULT<span>,</span> node<span>)</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>GO<span>,</span> node<span>.</span>left<span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"参数错误"</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><hr>
<h3 id="方法一-先得到中序遍历的结果-然后找到第-k-大元素"> 方法一：先得到中序遍历的结果，然后找到第 k 大元素</h3>
<p>我们利用了二分搜索树的有序性，二分搜索树的中序遍历得到的是一个有序数组，直接得到结论。</p>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>dfs</span><span>(</span>root<span>,</span> res<span>)</span><span>;</span>
        <span>return</span> res<span>.</span><span>get</span><span>(</span>k <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>dfs</span><span>(</span>node<span>.</span>left<span>,</span> res<span>)</span><span>;</span>
        res<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        <span>dfs</span><span>(</span>node<span>.</span>right<span>,</span> res<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，遍历了整个树。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，用了一个数组存储中序序列。</li>
</ul>
<h3 id="方法二-在递归的时候不记录全部结果-只记录计数器"> 方法二：在递归的时候不记录全部结果，只记录计数器</h3>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        count <span>=</span> k<span>;</span>
        <span>dfs</span><span>(</span>root<span>)</span><span>;</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>int</span> res <span>=</span> <span>0</span><span>;</span>

    <span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>// 先写递归终止条件</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 什么都不做</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>dfs</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>

        count<span>--</span><span>;</span>
        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>res <span>=</span> node<span>.</span>val<span>;</span>
        <span>}</span>

        <span>dfs</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>分析：因为二分搜索树具有顺序性，所以我们可以用类似快速排序的 partition 操作来完成</p>
<p>1、二分搜索树的有序性；2、二叉树中序遍历，特别地，</p>
<p>简而言之就是在中序遍历的时候数个数，第 1 个遍历到的是第 1 个最小的元素，第 2 个遍历到的是第 2 个最小的元素，数到第 k 个够数了，就不用再遍历了。</p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span># 230. 二叉搜索树中第K小的元素</span>
<span># 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</span>

<span>class</span> <span>Solution</span><span>:</span>

    <span># 使用中序遍历得到 BST 第 k 小的那个元素</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>k <span>=</span> <span>None</span>
        self<span>.</span>res <span>=</span> <span>None</span>

    <span>def</span> <span>__dfs</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>if</span> node <span>is</span> <span>None</span><span>:</span>
            <span>return</span>
        self<span>.</span>__dfs<span>(</span>node<span>.</span>left<span>)</span>
        self<span>.</span>k <span>-=</span> <span>1</span>
        <span>if</span> self<span>.</span>k <span>==</span> <span>0</span><span>:</span>
            self<span>.</span>res <span>=</span> node<span>.</span>val
            <span>return</span>

        self<span>.</span>__dfs<span>(</span>node<span>.</span>right<span>)</span>

    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        self<span>.</span>k <span>=</span> k
        self<span>.</span>__dfs<span>(</span>root<span>)</span>
        <span>return</span> self<span>.</span>res

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>等价写法：</p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>counter <span>=</span> <span>0</span>
        self<span>.</span>res <span>=</span> <span>0</span>

    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        <span># 使用递归的方法，中序遍历</span>
        <span>if</span> root<span>.</span>left<span>:</span>
            <span># 不是空，才继续遍历</span>
            self<span>.</span>kthSmallest<span>(</span>root<span>.</span>left<span>,</span> k<span>)</span>
        self<span>.</span>counter <span>+=</span> <span>1</span>
        <span># print(root.val)</span>
        <span>if</span> self<span>.</span>counter <span>==</span> k<span>:</span>
            <span># 注意：千万不能在这里返回，后序遍历还要继续进行下去</span>
            self<span>.</span>res <span>=</span> root<span>.</span>val
            <span>return</span>
        <span>if</span> root<span>.</span>right<span>:</span>
            self<span>.</span>kthSmallest<span>(</span>root<span>.</span>right<span>,</span> k<span>)</span>
        <span>return</span> self<span>.</span>res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>Python 代码：推荐写法</p>
<div><pre><code><span># Definition for a binary tree node.</span>
<span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>

<span># 这种写法比 3 更好一些，在入栈的时候，就判断结点是不是空，非空才入栈</span>


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        stack <span>=</span> <span>[</span><span>(</span><span>1</span><span>,</span> root<span>)</span><span>]</span>
        <span>while</span> stack<span>:</span>
            command<span>,</span> node <span>=</span> stack<span>.</span>pop<span>(</span><span>)</span>
            <span>if</span> command <span>==</span> <span>0</span><span>:</span>
                k <span>-=</span> <span>1</span>
                <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                    <span>return</span> node<span>.</span>val
            <span>else</span><span>:</span>
                <span># 模拟系统栈实现中序遍历(先左边、再自己、再右边)</span>
                <span>if</span> node<span>.</span>right<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>right<span>)</span><span>)</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>0</span><span>,</span> node<span>)</span><span>)</span>
                <span>if</span> node<span>.</span>left<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>left<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>kthSmallest</span><span>(</span>self<span>,</span> root<span>,</span> k<span>)</span><span>:</span>
        stack <span>=</span> <span>[</span><span>(</span><span>1</span><span>,</span> root<span>)</span><span>]</span>
        <span>while</span> stack<span>:</span>
            command<span>,</span> node <span>=</span> stack<span>.</span>pop<span>(</span><span>)</span>
            <span>if</span> command <span>==</span> <span>0</span><span>:</span>
                k <span>-=</span> <span>1</span>
                <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                    <span>return</span> node<span>.</span>val
            <span>else</span><span>:</span>
                <span># 模拟系统栈实现中序遍历(先左边、再自己、再右边)</span>
                <span>if</span> node<span>.</span>right<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>right<span>)</span><span>)</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>0</span><span>,</span> node<span>)</span><span>)</span>
                <span>if</span> node<span>.</span>left<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>left<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 235 题：二叉搜索树的最近公共祖先（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0235-lowest-common-ancestor-of-a-binary-search-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0235-lowest-common-ancestor-of-a-binary-search-tree/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">235. 二叉搜索树的最近公共祖先<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank" rel="noopener noreferrer">百度百科<i>Content not supported</i></a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="LeetCode 第 235 题（寻找二分搜索树中指定两个结点的最近公共祖先）" loading="lazy"></p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>这道题只要我们分析清楚递归关系，其实是非常简单的。就是利用了我们在本文开头部分所叙述的“二分搜索树的重要性质”来进行分类讨论。</p>
<ol>
<li>如果 p、q 结点位于 root 结点的同一侧，如果位于左侧，则递归地调用左孩子，如果位于右侧，则递归地调用右孩子；</li>
<li>如果 p、q 结点位于 root 结点的两侧，则所求的最近的公共祖先就是 root 自己；</li>
<li>如果 p、q 其中之一位于 root 结点，则 root 结点即为所求的结点。</li>
</ol>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>

<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
<span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>
<span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>
<span>return</span> <span>null</span><span>;</span>
<span>}</span>
<span>if</span><span>(</span>p<span>.</span>val <span>&lt;</span> root<span>.</span>val <span>&amp;&amp;</span> q<span>.</span>val <span>&lt;</span> root<span>.</span>val<span>)</span><span>{</span>
<span>return</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>left<span>,</span>p<span>,</span>q<span>)</span><span>;</span>
<span>}</span>
<span>if</span><span>(</span>p<span>.</span>val <span>></span> root<span>.</span>val <span>&amp;&amp;</span> q<span>.</span>val <span>></span> root<span>.</span>val<span>)</span><span>{</span>
<span>return</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>right<span>,</span>p<span>,</span>q<span>)</span><span>;</span>
<span>}</span>
<span>return</span> root<span>;</span>
<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>
        <span>// 其实这一步判断可以不用</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span> <span>||</span> root <span>==</span> p <span>||</span> root <span>==</span> q<span>)</span> <span>{</span>
            <span>return</span> root<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>p<span>.</span>val <span>&lt;</span> root<span>.</span>val <span>&amp;&amp;</span> q<span>.</span>val <span>&lt;</span> root<span>.</span>val<span>)</span> <span>{</span>
            <span>return</span> <span>lowestCommonAncestor1</span><span>(</span>root<span>.</span>left<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>p<span>.</span>val <span>></span> root<span>.</span>val <span>&amp;&amp;</span> q<span>.</span>val <span>></span> root<span>.</span>val<span>)</span> <span>{</span>
            <span>return</span> <span>lowestCommonAncestor1</span><span>(</span>root<span>.</span>right<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> root<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></CodeGroupItem>
</CodeGroup>
<h2 id="总结"> 总结</h2>
<p>这道问题的实现有赖于我们对二分搜索树的深刻的理解以及我们对整个问题的逻辑分析。</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 449 题：序列化和反序列化二叉搜索树（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0449-serialize-and-deserialize-bst/</id>
    <link href="https://suanfa8.com/tree/solutions/0449-serialize-and-deserialize-bst/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener noreferrer">449. 序列化和反序列化二叉搜索树<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>
<p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>
<p><strong>编码的字符串应尽可能紧凑。</strong></p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：root = [2,1,3]
输出：[2,1,3]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：root = []
输出：[]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>树中节点数范围是 <code>[0, 10^4]</code></li>
<li><code>0 &lt;= Node.val &lt;= 10^4</code></li>
<li>题目数据 <strong>保证</strong> 输入的树是一棵二叉搜索树。</li>
</ul>
<div><p>说明</p>
<p>因时间和精力关系，本题没有写详解，只给出了参考代码。读者可以在「力扣」这道题的评论区和题解区找到适合自己的思路分析和代码。如果确实需要我编写具体的解题思路，可以发邮件到 liweiwei1419@gmail.com。</p>
</div>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Codec</span> <span>{</span>

    <span>// Encodes a tree to a single string.</span>
    <span>public</span> <span>String</span> <span>serialize</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>""</span><span>;</span>
        <span>}</span>
        <span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>dfs</span><span>(</span>root<span>,</span> stringBuilder<span>)</span><span>;</span>
        <span>return</span> stringBuilder<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> stringBuilder<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>StringBuilder</span> stringBuilder<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        stringBuilder<span>.</span><span>append</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        stringBuilder<span>.</span><span>append</span><span>(</span><span>","</span><span>)</span><span>;</span>
        <span>dfs</span><span>(</span>node<span>.</span>left<span>,</span> stringBuilder<span>)</span><span>;</span>
        <span>dfs</span><span>(</span>node<span>.</span>right<span>,</span> stringBuilder<span>)</span><span>;</span>
    <span>}</span>

    <span>// Decodes your encoded data to tree.</span>
    <span>public</span> <span>TreeNode</span> <span>deserialize</span><span>(</span><span>String</span> data<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> data<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>String</span><span>[</span><span>]</span> dataArray <span>=</span> data<span>.</span><span>split</span><span>(</span><span>","</span><span>)</span><span>;</span>
        <span>return</span> <span>deserialize</span><span>(</span>dataArray<span>,</span> <span>0</span><span>,</span> dataArray<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>TreeNode</span> <span>deserialize</span><span>(</span><span>String</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>left <span>></span> right<span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>Integer</span><span>.</span><span>parseInt</span><span>(</span>arr<span>[</span>left<span>]</span><span>)</span><span>)</span><span>;</span>
        <span>int</span> index <span>=</span> right <span>+</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> left <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>Integer</span><span>.</span><span>parseInt</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span> <span>></span> root<span>.</span>val<span>)</span> <span>{</span>
                index <span>=</span> i<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
        root<span>.</span>left <span>=</span> <span>deserialize</span><span>(</span>arr<span>,</span> left <span>+</span> <span>1</span><span>,</span> index <span>-</span> <span>1</span><span>)</span><span>;</span>
        root<span>.</span>right <span>=</span> <span>deserialize</span><span>(</span>arr<span>,</span> index<span>,</span> right<span>)</span><span>;</span>
        <span>return</span> root<span>;</span>
    <span>}</span>
<span>}</span>

<span>// Your Codec object will be instantiated and called as such:</span>
<span>// Codec codec = new Codec();</span>
<span>// codec.deserialize(codec.serialize(root));</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 450 题：删除二叉搜索树中的节点（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0450-delete-node-in-a-bst/</id>
    <link href="https://suanfa8.com/tree/solutions/0450-delete-node-in-a-bst/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener noreferrer">450. 删除二叉搜索树中的节点<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/yong-qian-qu-huo-zhe-hou-ji-jie-dian-zi-shu-dai-ti/" target="_blank" rel="noopener noreferrer">用前驱或者后继结点代替被删除结点（Python、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt="img" loading="lazy"></p>
<p><strong>示例 2:</strong></p>
<div><pre><code>输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 3:</strong></p>
<div><pre><code>输入: root = [], key = 0
输出: []
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示:</strong></p>
<ul>
<li>节点数的范围 <code>[0, 10^4]</code>.</li>
<li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li>
<li>节点值唯一</li>
<li><code>root</code> 是合法的二叉搜索树</li>
<li><code>-10^5 &lt;= key &lt;= 10^5</code></li>
</ul>
<h2 id="用前驱或者后继结点代替被删除结点-python、java-代码"> 用前驱或者后继结点代替被删除结点（Python、Java 代码）</h2>
<p>“二分搜索树删除结点”这一操作在《数据结构与算法》这一类的教科书上均有介绍，虽然这个操作是计算机科学家 <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener noreferrer">Hibbard<i>Content not supported</i></a> 发明的，但其实这个操作非常简单且直观。</p>
<p>掌握递归删除二分搜索树结点的方法，注意递归函数的定义，有的时候需要返回一个新的二分搜索树的根。</p>
<h2 id="思路分析"> 思路分析</h2>
<p>删除结点是一个比较复杂的操作，一定要会。给定一棵二分搜索树，删除其中的一个结点。若删除的结点不存在？是否可能有多个需要删除的结点，删除的结点是否需要返回？</p>
<p>这个问题我以前专门写了题解，请点击<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0450-delete-node-in-a-bst/" target="_blank" rel="noopener noreferrer">这里<i>Content not supported</i></a>。</p>
<p>理解这个算法的关键在于保持 BST 中序遍历的顺序性，当待删除结点的左右结点都不为空的时候，让待删除结点的前驱结点或者后继结点代替被删除结点，这样就能成为一棵树，并且还是 BST，否则就变成森林，或者不保持 BST 中序遍历的顺序性了。</p>
<p><img src="https://pic.leetcode-cn.com/65820431b5bc15336391c8445bb22d8d6de3bd428a660413b9bd20fe5933ed72.png" alt="" loading="lazy"></p>
<p><img src="https://pic.leetcode-cn.com/0e4d4f0a47608586e810a898f30900eaab3a81b49e6ebe237c415651bcc8c181.png" alt="" loading="lazy"></p>
<p><img src="https://pic.leetcode-cn.com/33dc518fa189e9df2f2a7b1239489008da1d4306eeec8b80456962839a99a6b2.png" alt="" loading="lazy"></p>
<p><img src="https://pic.leetcode-cn.com/2fc9bbc19b20dcf017f794824c36ac0bef8115b4d888454b0977a1a9fdc1308e.png" alt="" loading="lazy"></p>
<p>在草稿纸上很容易画出 BST 删除结点操作的这 3 种情况。</p>
<p><img src="https://pic.leetcode-cn.com/60d185c859470a8118a6d5319300749a1b504c18935d2b0a28d45d58afd248aa.png" alt="" loading="lazy"></p>
<p><img src="https://pic.leetcode-cn.com/f8d57d74649c7f1737f64fdeaf92ad78f9e8a40794ac5409b60844ad28ff3ec2.png" alt="" loading="lazy"></p>
<h2 id="方法一-用前驱结点-左子树中最大结点-代替被删除结点"> 方法一：用前驱结点（左子树中最大结点）代替被删除结点</h2>
<p><strong>参考代码 1</strong>：</p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span># 方法1：用左子树中最大结点的代替被删除结点</span>


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>deleteNode</span><span>(</span>self<span>,</span> root<span>,</span> key<span>)</span><span>:</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>None</span>

        <span>if</span> key <span>&lt;</span> root<span>.</span>val<span>:</span>
            root<span>.</span>left <span>=</span> self<span>.</span>deleteNode<span>(</span>root<span>.</span>left<span>,</span> key<span>)</span>
            <span>return</span> root

        <span>if</span> key <span>></span> root<span>.</span>val<span>:</span>
            root<span>.</span>right <span>=</span> self<span>.</span>deleteNode<span>(</span>root<span>.</span>right<span>,</span> key<span>)</span>
            <span>return</span> root

        <span>if</span> root<span>.</span>left <span>is</span> <span>None</span><span>:</span>
            new_root <span>=</span> root<span>.</span>right
            root<span>.</span>right <span>=</span> <span>None</span>
            <span>return</span> new_root

        <span>if</span> root<span>.</span>right <span>is</span> <span>None</span><span>:</span>
            new_root <span>=</span> root<span>.</span>left
            root<span>.</span>left <span>=</span> <span>None</span>
            <span>return</span> new_root

        <span># 找到左子树中最大的</span>
        predecessor <span>=</span> self<span>.</span>__maximum<span>(</span>root<span>.</span>left<span>)</span>
        predecessor_copy <span>=</span> TreeNode<span>(</span>predecessor<span>.</span>val<span>)</span>
        predecessor_copy<span>.</span>left <span>=</span> self<span>.</span>__remove_max<span>(</span>root<span>.</span>left<span>)</span>
        predecessor_copy<span>.</span>right <span>=</span> root<span>.</span>right
        root<span>.</span>left <span>=</span> <span>None</span>
        root<span>.</span>right <span>=</span> <span>None</span>
        <span>return</span> predecessor_copy

    <span>def</span> <span>__remove_max</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>if</span> node<span>.</span>right <span>is</span> <span>None</span><span>:</span>
            new_root <span>=</span> node<span>.</span>left
            node<span>.</span>left <span>=</span> <span>None</span>
            <span>return</span> new_root
        node<span>.</span>right <span>=</span> self<span>.</span>__remove_max<span>(</span>node<span>.</span>right<span>)</span>
        <span>return</span> node

    <span>def</span> <span>__maximum</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>while</span> node<span>.</span>right<span>:</span>
            node <span>=</span> node<span>.</span>right
        <span>return</span> node
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p>Java 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>TreeNode</span> <span>deleteNode</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>key <span>&lt;</span> root<span>.</span>val<span>)</span> <span>{</span>
            root<span>.</span>left <span>=</span> <span>deleteNode</span><span>(</span>root<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
            <span>return</span> root<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>key <span>></span> root<span>.</span>val<span>)</span> <span>{</span>
            root<span>.</span>right <span>=</span> <span>deleteNode</span><span>(</span>root<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
            <span>return</span> root<span>;</span>
        <span>}</span>

        <span>assert</span> key <span>==</span> root<span>.</span>val<span>;</span>

        <span>if</span> <span>(</span>root<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>TreeNode</span> right <span>=</span> root<span>.</span>right<span>;</span>
            root<span>.</span>right <span>=</span> <span>null</span><span>;</span>
            <span>return</span> right<span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>root<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>TreeNode</span> left <span>=</span> root<span>.</span>left<span>;</span>
            root<span>.</span>left <span>=</span> <span>null</span><span>;</span>
            <span>return</span> left<span>;</span>
        <span>}</span>
        <span>TreeNode</span> predecessor <span>=</span> <span>maximum</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
        <span>TreeNode</span> predecessorCopy <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>predecessor<span>.</span>val<span>)</span><span>;</span>
        predecessorCopy<span>.</span>left <span>=</span> <span>removeMax</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
        predecessorCopy<span>.</span>right <span>=</span> root<span>.</span>right<span>;</span>
        root<span>.</span>left <span>=</span> <span>null</span><span>;</span>
        root<span>.</span>right <span>=</span> <span>null</span><span>;</span>
        <span>return</span> predecessorCopy<span>;</span>
    <span>}</span>

    <span>private</span> <span>TreeNode</span> <span>removeMax</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>TreeNode</span> left <span>=</span> node<span>.</span>left<span>;</span>
            node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
            <span>return</span> left<span>;</span>
        <span>}</span>
        node<span>.</span>right <span>=</span> <span>removeMax</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span>

    <span>private</span> <span>TreeNode</span> <span>maximum</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> node<span>;</span>
        <span>}</span>
        <span>return</span> <span>maximum</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id="方法二-用后继结点-右子树中最小结点-代替被删除结点"> 方法二：用后继结点（右子树中最小结点）代替被删除结点</h2>
<p><strong>参考代码 2</strong>：</p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span># 方法2：用右子树中最小结点的代替被删除结点</span>


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>deleteNode</span><span>(</span>self<span>,</span> root<span>,</span> key<span>)</span><span>:</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>None</span>

        <span>if</span> key <span>&lt;</span> root<span>.</span>val<span>:</span>
            root<span>.</span>left <span>=</span> self<span>.</span>deleteNode<span>(</span>root<span>.</span>left<span>,</span> key<span>)</span>
            <span>return</span> root

        <span>if</span> key <span>></span> root<span>.</span>val<span>:</span>
            root<span>.</span>right <span>=</span> self<span>.</span>deleteNode<span>(</span>root<span>.</span>right<span>,</span> key<span>)</span>
            <span>return</span> root

        <span>if</span> root<span>.</span>left <span>is</span> <span>None</span><span>:</span>
            new_root <span>=</span> root<span>.</span>right
            root<span>.</span>right <span>=</span> <span>None</span>
            <span>return</span> new_root

        <span>if</span> root<span>.</span>right <span>is</span> <span>None</span><span>:</span>
            new_root <span>=</span> root<span>.</span>left
            root<span>.</span>left <span>=</span> <span>None</span>
            <span>return</span> new_root

        <span># 找到右子树中最小的结点，复制它的值</span>
        successor <span>=</span> self<span>.</span>__minimum<span>(</span>root<span>.</span>right<span>)</span>
        successor_copy <span>=</span> TreeNode<span>(</span>successor<span>.</span>val<span>)</span>
        successor_copy<span>.</span>left <span>=</span> root<span>.</span>left
        successor_copy<span>.</span>right <span>=</span> self<span>.</span>__remove_min<span>(</span>root<span>.</span>right<span>)</span>
        root<span>.</span>left <span>=</span> <span>None</span>
        root<span>.</span>right <span>=</span> <span>None</span>
        <span>return</span> successor_copy

    <span>def</span> <span>__remove_min</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>if</span> node<span>.</span>left <span>is</span> <span>None</span><span>:</span>
            new_root <span>=</span> node<span>.</span>right
            node<span>.</span>right <span>=</span> <span>None</span>
            <span>return</span> new_root
        node<span>.</span>left <span>=</span> self<span>.</span>__remove_min<span>(</span>node<span>.</span>left<span>)</span>
        <span>return</span> node

    <span>def</span> <span>__minimum</span><span>(</span>self<span>,</span> node<span>)</span><span>:</span>
        <span>while</span> node<span>.</span>left<span>:</span>
            node <span>=</span> node<span>.</span>left
        <span>return</span> node
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p>Java 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>TreeNode</span> <span>minNode</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>while</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            node <span>=</span> node<span>.</span>left<span>;</span>
        <span>}</span>
        <span>return</span> node<span>;</span>
    <span>}</span>

    <span>/**
     * 删除一个二分搜索树中最小的节点，把新的二分搜索树的根返回回去
     * 使用递归，要特别注意，定义的递归函数，返回的是，删除了最小值节点以后的新的二分搜索树的根
     *
     * @param node
     * @return
     */</span>
    <span>private</span> <span>TreeNode</span> <span>removeMin</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 就是那个我们要删除的节点</span>
            <span>TreeNode</span> rightNode <span>=</span> node<span>.</span>right<span>;</span>
            node<span>.</span>right <span>=</span> <span>null</span><span>;</span>
            <span>return</span> rightNode<span>;</span>
        <span>}</span>
        node<span>.</span>left <span>=</span> <span>removeMin</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span>

    <span>public</span> <span>TreeNode</span> <span>deleteNode</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>root<span>.</span>val <span>&lt;</span> key<span>)</span> <span>{</span>
            root<span>.</span>right <span>=</span> <span>deleteNode</span><span>(</span>root<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
            <span>return</span> root<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>root<span>.</span>val <span>></span> key<span>)</span> <span>{</span>
            root<span>.</span>left <span>=</span> <span>deleteNode</span><span>(</span>root<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
            <span>return</span> root<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 如果待删除的节点左孩子为空</span>
            <span>if</span> <span>(</span>root<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>TreeNode</span> rightNode <span>=</span> root<span>.</span>right<span>;</span>
                root<span>.</span>right <span>=</span> <span>null</span><span>;</span>
                <span>return</span> rightNode<span>;</span>
            <span>}</span>
            <span>// 如果待删除的节点只有右孩子</span>
            <span>if</span> <span>(</span>root<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>TreeNode</span> leftNode <span>=</span> root<span>.</span>left<span>;</span>
                root<span>.</span>left <span>=</span> <span>null</span><span>;</span>
                <span>return</span> leftNode<span>;</span>
            <span>}</span>
            <span>// 从它的右子树中拿到最小的</span>
            <span>TreeNode</span> successor <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>minNode</span><span>(</span>root<span>.</span>right<span>)</span><span>.</span>val<span>)</span><span>;</span>
            successor<span>.</span>left <span>=</span> root<span>.</span>left<span>;</span>
            successor<span>.</span>right <span>=</span> <span>removeMin</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
            root<span>.</span>left <span>=</span> <span>null</span><span>;</span>
            root<span>.</span>right <span>=</span> <span>null</span><span>;</span>
            <span>return</span> successor<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 897 题：递增顺序查找树（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0897-increasing-order-search-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0897-increasing-order-search-tree/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<p>说明：本题官方题解我参与了编写，因此内容与官方题解有重合的地方。</p>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一棵二叉搜索树，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [5,1,7]
输出：[1,null,5,null,7]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>树中节点数的取值范围是 <code>[1, 100]</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="方法一-先中序遍历-再生成新的树"> 方法一：先中序遍历，再生成新的树</h2>
<p><strong>算法</strong></p>
<p>题目要求我们返回按照中序遍历的结果改造而成的、只有右节点的 <strong>等价</strong> 二叉查找树。提示中说：每个节点具有唯一值。因此我们可以：</p>
<ul>
<li>先对输入的二叉查找树执行中序遍历，将结果保存到一个列表中；</li>
<li>然后根据列表中的节点值，创建等价的，只含有右节点的二叉查找树，其过程等价于：根据数组创建一个链表。</li>
</ul>
<p><strong>代码</strong></p>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>TreeNode</span> <span>increasingBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>inorder</span><span>(</span>root<span>,</span> res<span>)</span><span>;</span>

        <span>TreeNode</span> dummyNode <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        <span>TreeNode</span> currNode <span>=</span> dummyNode<span>;</span>
        <span>for</span> <span>(</span><span>int</span> value<span>:</span> res<span>)</span> <span>{</span>
            currNode<span>.</span>right <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>value<span>)</span><span>;</span>
            currNode <span>=</span> currNode<span>.</span>right<span>;</span>
        <span>}</span>
        <span>return</span> dummyNode<span>.</span>right<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>inorder</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>inorder</span><span>(</span>node<span>.</span>left<span>,</span> res<span>)</span><span>;</span>
        res<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        <span>inorder</span><span>(</span>node<span>.</span>right<span>,</span> res<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。其中 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是二叉查找树的节点总数。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，保存二叉查找树的所有节点的值需要长度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 的列表。</li>
</ul>
<h2 id="方法二-在中序遍历的过程中改变节点指向"> 方法二：在中序遍历的过程中改变节点指向</h2>
<p>方法一需要遍历一次二叉查找树以后，然后再创建新的等价的二叉查找树。事实上，还可以遍历一次输入二叉查找树，在遍历的过程中改变结点指向以满足题目的要求。</p>
<p>具体来说，在中序遍历的时候，修改结点指向就可以实现。具体地，当我们遍历到一个节点时，把它的左孩子设为空，并将其本身作为上一个遍历到的节点的右孩子。这里需要有一些想象能力。递归遍历的过程中，由于递归函数的调用栈保存了节点的引用，使得上述操作可以实现。下面的幻灯片展示了这样的过程。</p>
<Presentation id="presentation-382ee225" data-code="%0A!%5B1.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-CYccaw-1.png)%0A%0A---%0A%0A!%5B2.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-wVIkEe-2.png)%0A%0A---%0A%0A!%5B3.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-wVNSxo-3.png)%0A%0A---%0A%0A!%5B4.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-MRrcNu-4.png)%0A%0A---%0A%0A!%5B5.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-ZaLISJ-5.png)%0A%0A---%0A%0A!%5B6.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-tdVhEG-6.png)%0A%0A---%0A%0A!%5B7.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-ljGMbE-7.png)%0A%0A---%0A%0A!%5B8.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-ObVBhn-8.png)%0A%0A---%0A%0A!%5B9.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-alyIKA-9.png)%0A%0A---%0A%0A!%5B10.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-hRHcnK-10.png)%0A%0A---%0A%0A!%5B11.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-AZbrbl-11.png)%0A%0A---%0A%0A!%5B12.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-aAIrLT-12.png)%0A%0A---%0A%0A!%5B13.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-IrZyWz-13.png)%0A%0A---%0A%0A!%5B14.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-EzRWkT-14.png)%0A%0A---%0A%0A!%5B15.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-INQjIh-15.png)%0A%0A---%0A%0A!%5B16.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-XUkntJ-16.png)%0A%0A---%0A%0A!%5B17.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-SNRECU-17.png)%0A%0A---%0A%0A!%5B18.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-MJNEuw-18.png)%0A%0A---%0A%0A!%5B19.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-APxVgX-19.png)%0A%0A---%0A%0A!%5B20.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-kncxnf-20.png)%0A%0A---%0A%0A!%5B21.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-AfojZp-21.png)%0A%0A---%0A%0A!%5B22.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-arlRwv-22.png)%0A%0A---%0A%0A!%5B23.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-dRsEXD-23.png)%0A%0A---%0A%0A!%5B24.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-mmcVcf-24.png)%0A%0A---%0A%0A!%5B25.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-PlYUtg-25.png)%0A%0A---%0A%0A!%5B26.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-oowOmh-26.png)%0A%0A---%0A%0A!%5B27.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1617605893-uzfpip-27.png)%0A" theme="auto"></Presentation><p><strong>代码</strong></p>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>TreeNode</span> resNode<span>;</span>

    <span>public</span> <span>TreeNode</span> <span>increasingBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>TreeNode</span> dummyNode <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        resNode <span>=</span> dummyNode<span>;</span>
        <span>inorder</span><span>(</span>root<span>)</span><span>;</span>
        <span>return</span> dummyNode<span>.</span>right<span>;</span>

    <span>}</span>

    <span>public</span> <span>void</span> <span>inorder</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>inorder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>

        <span>// 在中序遍历的过程中修改结点指向</span>
        resNode<span>.</span>right <span>=</span> node<span>;</span>
        node<span>.</span>left <span>=</span> <span>null</span><span>;</span>
        resNode <span>=</span> node<span>;</span>

        <span>inorder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。其中 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是二叉查找树的节点总数。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，保存二叉查找树的所有节点的值需要长度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 的列表。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1008 题：前序遍历构造二叉搜索树（中等）</title>
    <id>https://suanfa8.com/tree/solutions/1008-construct-binary-search-tree-from-preorder-traversal/</id>
    <link href="https://suanfa8.com/tree/solutions/1008-construct-binary-search-tree-from-preorder-traversal/"/>
    <updated>2022-01-15T07:10:01.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener noreferrer">1008. 前序遍历构造二叉搜索树<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/solution/fen-zhi-si-xiang-java-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">分治思想（Java）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>返回与给定前序遍历 <code>preorder</code> 相匹配的二叉搜索树（binary <strong>search</strong> tree）的根结点。</p>
<p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 <code>node.left</code> 的任何后代，值总 <code>&lt; node.val</code>，而 <code>node.right</code> 的任何后代，值总 <code>&gt; node.val</code>。<em>此外，前序遍历首先显示节点 <code>node</code> 的值，然后遍历 <code>node.left</code>，接着遍历 <code>node.right</code>。）</em></p>
<p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。</p>
<p><strong>示例：</strong></p>
<div><pre><code>输入：[8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/1266.png" alt="img" loading="lazy"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
<li><code>1 &lt;= preorder[i] &lt;= 10^8</code></li>
<li><code>preorder</code> 中的值互不相同</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>这道题如果做过 「力扣」第 105 题：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">从前序与中序遍历序列构造二叉树<i>Content not supported</i></a>，就会容易很多。</p>
<p>二叉树的很多问题都可以根据分治来做。</p>
<p><strong>编码要点</strong>：</p>
<ul>
<li>前序遍历的第 1 个结点一定是二叉树的根结点；</li>
<li>由于构造出来的是 BST，第 1 个结点后面被分成了两个子区间：
<ul>
<li>第 1 个子区间里所有的元素都严格小于根结点 -&gt; 递归构建成根结点的左子树；</li>
<li>第 2 个子区间里所有的元素都严格大于根结点 -&gt; 递归构建成根结点的右子树。</li>
</ul>
</li>
</ul>
<p>在这里递归函数里面一定会有一次遍历，不可以像 「力扣」第 105 题：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">从前序与中序遍历序列构造二叉树<i>Content not supported</i></a> 一样，先用哈希表记住一些关系，然后递归的时候一下子得到左右分界线。</p>
<ul>
<li>但是可以发现，后面那一段其实是一个有「谷底」的数组，我们可以使用「二分查找」找到那个谷底，这里要注意边界条件。</li>
</ul>
<p>（如果知道优化解法的朋友，欢迎指正。）</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>TreeNode</span> <span>bstFromPreorder</span><span>(</span><span>int</span><span>[</span><span>]</span> preorder<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> preorder<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>return</span> <span>buildBST</span><span>(</span>preorder<span>,</span> <span>0</span><span>,</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 使用 preorder 的子区间 [left, right] 构建二叉树
     *
     * @param preorder
     * @param left
     * @param right
     * @return
     */</span>
    <span>private</span> <span>TreeNode</span> <span>buildBST</span><span>(</span><span>int</span><span>[</span><span>]</span> preorder<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>left <span>></span> right<span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>preorder<span>[</span>left<span>]</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>left <span>==</span> right<span>)</span> <span>{</span>
            <span>return</span> root<span>;</span>
        <span>}</span>

        <span>int</span> i <span>=</span> left<span>;</span>
        <span>while</span> <span>(</span>i <span>+</span> <span>1</span> <span>&lt;=</span> right <span>&amp;&amp;</span> preorder<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>&lt;</span> preorder<span>[</span>left<span>]</span><span>)</span> <span>{</span>
            i<span>++</span><span>;</span>
        <span>}</span>

        <span>// 此时子区间 [left + 1..i] 所有元素都 &lt; preorder[left]</span>
        <span>//  [i + 1..right] 所有元素都 > preorder[left]</span>

        <span>TreeNode</span> leftTree <span>=</span> <span>buildBST</span><span>(</span>preorder<span>,</span> left <span>+</span> <span>1</span><span>,</span> i<span>)</span><span>;</span>
        <span>TreeNode</span> rightTree <span>=</span> <span>buildBST</span><span>(</span>preorder<span>,</span> i <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>;</span>

        root<span>.</span>left <span>=</span> leftTree<span>;</span>
        root<span>.</span>right <span>=</span> rightTree<span>;</span>
        <span>return</span> root<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span style="margin-right:0.10903em;">N</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span>，最差情况就是顺序数组和倒序数组，这种情况相当于构建一个链表；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，递归调用的方法栈的高度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，被忽略。</li>
</ul>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>// 889. Construct Binary Tree from Preorder and Postorder Traversal</span>
    <span>// 1028 就是更难点的题目了</span>

    <span>public</span> <span>TreeNode</span> <span>bstFromPreorder</span><span>(</span><span>int</span><span>[</span><span>]</span> preorder<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> preorder<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>return</span> <span>buildBST</span><span>(</span>preorder<span>,</span> <span>0</span><span>,</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 使用 preorder 的子区间 [left, right] 构建二叉树
     *
     * @param preorder
     * @param left
     * @param right
     * @return
     */</span>
    <span>private</span> <span>TreeNode</span> <span>buildBST</span><span>(</span><span>int</span><span>[</span><span>]</span> preorder<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>left <span>></span> right<span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>preorder<span>[</span>left<span>]</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>left <span>==</span> right<span>)</span> <span>{</span>
            <span>return</span> root<span>;</span>
        <span>}</span>

        <span>// 重点逻辑：在区间 [left, right] 里找最后一个小于等于 preorder[left] 的下标</span>
        <span>// 注意这里设置区间的左边界为 left ，不能是 left + 1</span>
        <span>int</span> leftPoint <span>=</span> left<span>;</span>
        <span>int</span> rightPoint <span>=</span> right<span>;</span>

        <span>while</span> <span>(</span>leftPoint <span>&lt;</span> rightPoint<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> leftPoint <span>+</span> <span>(</span>rightPoint <span>-</span> leftPoint <span>+</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>preorder<span>[</span>mid<span>]</span> <span>&lt;</span> preorder<span>[</span>left<span>]</span><span>)</span> <span>{</span>
                <span>// 下一轮搜索区间是 [mid, rightPoint]</span>
                leftPoint <span>=</span> mid<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// 下一轮搜索区间是 [left, mid - 1]</span>
                rightPoint <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>TreeNode</span> leftTree <span>=</span> <span>buildBST</span><span>(</span>preorder<span>,</span> left <span>+</span> <span>1</span><span>,</span> leftPoint<span>)</span><span>;</span>
        <span>TreeNode</span> rightTree <span>=</span> <span>buildBST</span><span>(</span>preorder<span>,</span> leftPoint <span>+</span> <span>1</span><span>,</span> right<span>)</span><span>;</span>

        root<span>.</span>left <span>=</span> leftTree<span>;</span>
        root<span>.</span>right <span>=</span> rightTree<span>;</span>
        <span>return</span> root<span>;</span>


    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，二分查找优化了线性查找的时间复杂度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，同上。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉搜索树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-15T07:10:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 778 题：水位上升的泳池中游泳（困难）</title>
    <id>https://suanfa8.com/union-find/solutions/0778-swim-in-rising-water/</id>
    <link href="https://suanfa8.com/union-find/solutions/0778-swim-in-rising-water/"/>
    <updated>2022-01-14T07:07:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/swim-in-rising-water/" target="_blank" rel="noopener noreferrer">778. 水位上升的泳池中游泳<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/shui-wei-shang-sheng-de-yong-chi-zhong-y-862o/" target="_blank" rel="noopener noreferrer">🎦 水位上升的泳池中游泳<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/shui-wei-shang-sheng-de-yong-chi-zhong-y-862o/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1kv4y1f7to" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=543883098&bvid=BV1kv4y1f7to&cid=291911006&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>在一个 N x N 的坐标方格 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示在位置 <code>(i,j)</code> 的平台高度。</p>
<p>现在开始下雨了。当时间为 <code>t</code> 时，此时雨水导致水池中任意位置的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>
<p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 <code>(N-1, N-1)</code>？</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: [[0,2],[1,3]]
输出: 3
解释:
时间为0时，你位于坐标方格的位置为 (0, 0)。
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。

等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>示例 2:</strong>（这个例子的着重号没有显示出来，请读者直接看 <a href="https://leetcode-cn.com/problems/swim-in-rising-water/" target="_blank" rel="noopener noreferrer">原题目描述<i>Content not supported</i></a>）</p>
<div><pre><code>输出: 16
解释:
 0  1  2  3  4
24 23 22 21  5
12 13 14 15 16
11 17 18 19 20
10  9  8  7  6

最终的路线用加粗进行了标记。
我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>提示:</strong></p>
<ol>
<li><code>2 &lt;= N &lt;= 50</code>.</li>
<li><code>grid[i][j]</code> 是 <code>[0, ..., N*N - 1]</code> 的排列。</li>
</ol>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="并查集" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-14T07:07:51.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 803 题：打砖块（困难）</title>
    <id>https://suanfa8.com/union-find/solutions/0803-bricks-falling-when-hit/</id>
    <link href="https://suanfa8.com/union-find/solutions/0803-bricks-falling-when-hit/"/>
    <updated>2022-01-14T07:07:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener noreferrer">803. 打砖块<i>Content not supported</i></a></li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/solution/803-da-zhuan-kuai-by-leetcode-r5kf/" target="_blank" rel="noopener noreferrer">🎦 803. 打砖块<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/solution/803-da-zhuan-kuai-by-leetcode-r5kf/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1Xv411W74B" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=246251062&bvid=BV1Xv411W74B&cid=287320353&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>有一个 <code>m x n</code> 的二元网格，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>
<ul>
<li>一块砖直接连接到网格的顶部，或者</li>
<li>至少有一块相邻（4 个方向之一）砖块 <strong>稳定</strong> 不会掉落时</li>
</ul>
<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除 <code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。</p>
<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>
<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
输出：[2]
解释：
网格开始为：
[[1,0,0,0]，
 [1,1,1,0]]
消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0]
 [0,1,1,0]]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
[[1,0,0,0],
 [0,0,0,0]]
因此，结果为 [2] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
输出：[0,0]
解释：
网格开始为：
[[1,0,0,0],
 [1,1,0,0]]
消除 (1,1) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [1,0,0,0]]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
[[1,0,0,0],
 [1,0,0,0]]
接下来消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [0,0,0,0]]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 [0,0] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
<li><code>1 &lt;= hits.length &lt;= 4 * 10^4</code></li>
<li><code>hits[i].length == 2</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.786em;vertical-align:-0.15em;"></span><span><span>x</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>m</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.1944em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>n</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
<li>所有 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span><span>x</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>)</span></span></span></span> 互不相同</li>
</ul>
<div><p>说明</p>
<p>本题详解请见本文的「题解链接」，有视频讲解和文字讲解。</p>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="并查集" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-14T07:07:51.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 947 题：移除最多的同行或同列石头（中等）</title>
    <id>https://suanfa8.com/union-find/solutions/0947-most-stones-removed-with-same-row-or-column/</id>
    <link href="https://suanfa8.com/union-find/solutions/0947-most-stones-removed-with-same-row-or-column/"/>
    <updated>2022-01-14T07:07:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/" target="_blank" rel="noopener noreferrer">947. 移除最多的同行或同列石头<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/947-yi-chu-zui-duo-de-tong-xing-huo-tong-ezha/" target="_blank" rel="noopener noreferrer">🎦 947. 移除最多的同行或同列石头<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/947-yi-chu-zui-duo-de-tong-xing-huo-tong-ezha/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1Nr4y1K7Gj" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=756368279&bvid=BV1Nr4y1K7Gj&cid=285382785&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>
<p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>
<p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>s</span><span>t</span><span>o</span><span>n</span><span>es</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>[</span><span><span>x</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>]</span></span></span></span> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.1944em;"></span><span><span>x</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>
<li>不会有两块石头放在同一个坐标点上</li>
</ul>
<div><p>说明</p>
<p>本题详解请见本文的「题解链接」，有视频讲解和文字讲解。</p>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="并查集" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-14T07:07:51.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 959 题：由斜杠划分区域（中等）</title>
    <id>https://suanfa8.com/union-find/solutions/0959-regions-cut-by-slashes/</id>
    <link href="https://suanfa8.com/union-find/solutions/0959-regions-cut-by-slashes/"/>
    <updated>2022-01-14T07:07:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/" target="_blank" rel="noopener noreferrer">959. 由斜杠划分区域<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/" target="_blank" rel="noopener noreferrer">🎦 由斜杠划分区域<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1Ry4y117HD" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=798948748&bvid=BV1Ry4y117HD&cid=288731392&page=1" frameborder="no" scrolling="no"></iframe>
</div>
## 题目描述
<p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p>
<p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>&quot;\\&quot;</code> 表示。）。</p>
<p>返回区域的数目。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：
[
  &quot; /&quot;,
  &quot;/ &quot;
]
输出：2
解释：2x2 网格如下：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/1.png" alt="img" loading="lazy"></p>
<p><strong>示例 2：</strong></p>
<div><pre><code>输入：
[
  &quot; /&quot;,
  &quot;  &quot;
]
输出：1
解释：2x2 网格如下：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/2.png" alt="img" loading="lazy"></p>
<p><strong>示例 3：</strong></p>
<div><pre><code>输入：
[
  &quot;\\/&quot;,
  &quot;/\\&quot;
]
输出：4
解释：（回想一下，因为 \ 字符是转义的，所以 &quot;\\/&quot; 表示 \/，而 &quot;/\\&quot; 表示 /\。）
2x2 网格如下：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/3.png" alt="img" loading="lazy"></p>
<p><strong>示例 4：</strong></p>
<div><pre><code>输入：
[
  &quot;/\\&quot;,
  &quot;\\/&quot;
]
输出：5
解释：（回想一下，因为 \ 字符是转义的，所以 &quot;/\\&quot; 表示 /\，而 &quot;\\/&quot; 表示 \/。）
2x2 网格如下：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/4.png" alt="img" loading="lazy"></p>
<p><strong>示例 5：</strong></p>
<div><pre><code>输入：
[
  &quot;//&quot;,
  &quot;/ &quot;
]
输出：3
解释：2x2 网格如下：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/5.png" alt="img" loading="lazy"></p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 30</code></li>
<li><code>grid[i][j]</code> 是 <code>'/'</code>、<code>'\'</code>、或 <code>' '</code>。</li>
</ol>
<div><p>说明</p>
<p>本题详解请见本文的「题解链接」，有视频讲解和文字讲解。</p>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="并查集" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-14T07:07:51.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1202 题：交换字符串中的元素（中等）</title>
    <id>https://suanfa8.com/union-find/solutions/1202-smallest-string-with-swaps/</id>
    <link href="https://suanfa8.com/union-find/solutions/1202-smallest-string-with-swaps/"/>
    <updated>2022-01-14T07:07:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener noreferrer">1202. 交换字符串中的元素<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/" target="_blank" rel="noopener noreferrer">🎦 1202. 交换字符串中的元素<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1Yh41127VH" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=203640244&bvid=BV1Yh41127VH&cid=282280079&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p>
<p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p>
<p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]
输出：&quot;bacd&quot;
解释：
交换 s[0] 和 s[3], s = &quot;bcad&quot;
交换 s[1] 和 s[2], s = &quot;bacd&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]
输出：&quot;abcd&quot;
解释：
交换 s[0] 和 s[3], s = &quot;bcad&quot;
交换 s[0] 和 s[2], s = &quot;acbd&quot;
交换 s[1] 和 s[2], s = &quot;abcd&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]]
输出：&quot;abc&quot;
解释：
交换 s[0] 和 s[1], s = &quot;bca&quot;
交换 s[1] 和 s[2], s = &quot;bac&quot;
交换 s[0] 和 s[1], s = &quot;abc&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length</code></li>
<li><code>s</code> 中只含有小写英文字母</li>
</ul>
<div><p>说明</p>
<p>本题详解请见本文的「题解链接」，有视频讲解和文字讲解。</p>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="并查集" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-14T07:07:51.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1128 题：等价多米诺骨牌对的数量（简单）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/1128-number-of-equivalent-domino-pairs/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/1128-number-of-equivalent-domino-pairs/"/>
    <updated>2022-01-14T06:41:46.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/" target="_blank" rel="noopener noreferrer">1128. 等价多米诺骨牌对的数量<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/solution/deng-jie-duo-mi-nuo-gu-pai-dui-de-shu-li-08z8/" target="_blank" rel="noopener noreferrer">官方题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV1fV411q7ZY" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=416433823&bvid=BV1fV411q7ZY&cid=291046663&page=1" frameborder="no" scrolling="no"></iframe>
</div>
## 题目描述
<p>给你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。</p>
<p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p>
<p>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a==c</code> 且 <code>b==d</code>，或是 <code>a==d</code> 且 <code>b==c</code>。</p>
<p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p>
<p><strong>示例：</strong></p>
<div><pre><code>输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= dominoes.length &lt;= 40000</code></li>
<li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li>
</ul>
<div><p>说明</p>
<p>本题详解请见本文的「题解链接」，有视频讲解和文字讲解。</p>
</div>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-14T06:41:46.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 962 题：最大宽度坡（中等）</title>
    <id>https://suanfa8.com/monotonous-stack/solutions/0962-maximum-width-ramp/</id>
    <link href="https://suanfa8.com/monotonous-stack/solutions/0962-maximum-width-ramp/"/>
    <updated>2022-01-12T01:10:13.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目描述：<a href="https://leetcode-cn.com/problems/maximum-width-ramp/" target="_blank" rel="noopener noreferrer">962. 最大宽度坡<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个整数数组 <code>A</code>，<em>坡</em>是元组 <code>(i, j)</code>，其中 <code>i &lt; j</code> 且 <code>A[i] &lt;= A[j]</code>。这样的坡的宽度为 <code>j - i</code>。</p>
<p>找出 <code>A</code> 中的坡的最大宽度，如果不存在，返回 0 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：[6,0,8,2,1,5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：[9,8,1,0,1,9,4,0,4,1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>提示：</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 50000</code></li>
<li><code>0 &lt;= A[i] &lt;= 50000</code></li>
</ol>
<div><p>说明</p>
<p>因时间和个人精力关系，本题没有写详解，只给出了参考代码。</p>
<p>读者可以在「力扣」这道题的评论区和题解区找到适合自己的思路分析和代码。</p>
<p>如果确实需要我编写具体的解题思路，可以发邮件到 liweiwei1419@gmail.com 或者给本项目的 <a href="https://github.com/liweiwei1419/liweiwei1419.github.io/issues" target="_blank" rel="noopener noreferrer">issue<i>Content not supported</i></a> 留言。</p>
</div>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayDeque</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Deque</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>maxWidthRamp</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>Deque</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stacks <span>=</span> <span>new</span> <span>ArrayDeque</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        stacks<span>.</span><span>addLast</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> nums<span>[</span>stacks<span>.</span><span>peekLast</span><span>(</span><span>)</span><span>]</span><span>)</span> <span>{</span>
                stacks<span>.</span><span>addLast</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> len <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span><span>!</span>stacks<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>>=</span> nums<span>[</span>stacks<span>.</span><span>peekLast</span><span>(</span><span>)</span><span>]</span><span>)</span> <span>{</span>
                res <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>res<span>,</span> i <span>-</span> stacks<span>.</span><span>removeLast</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="栈" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-07T09:10:45.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 507 题：完美数（简单）</title>
    <id>https://suanfa8.com/math/solutions/0507-perfect-number/</id>
    <link href="https://suanfa8.com/math/solutions/0507-perfect-number/"/>
    <updated>2022-01-14T06:42:28.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/perfect-number/" target="_blank" rel="noopener noreferrer">507. 完美数<i>Content not supported</i></a></li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>对于一个 <strong>正整数</strong>，如果它和除了它自身以外的所有 <strong>正因子</strong> 之和相等，我们称它为 「完美数」。</p>
<p>给定一个 <strong>整数</strong> <code>n</code>， 如果是完美数，返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：num = 6
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：num = 496
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：num = 8128
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 5：</strong></p>
<div><pre><code>输入：num = 2
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 10^8</code></li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>checkPerfectNumber</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>num <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>// 所有乘法因子的和存在这里</span>
        <span>int</span> res <span>=</span> <span>1</span><span>;</span>
        <span>// 可能的乘法因子，从 2 开始</span>
        <span>int</span> factor <span>=</span> <span>2</span><span>;</span>
        <span>while</span> <span>(</span>factor <span>*</span> factor <span>&lt;</span> num<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>num <span>%</span> factor <span>==</span> <span>0</span> <span>)</span> <span>{</span>
                res <span>+=</span> factor<span>;</span>
                res <span>+=</span> <span>(</span>num <span>/</span> factor<span>)</span><span>;</span>
            <span>}</span>
            factor <span>+=</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>// 把中间那个数单独拿出来</span>
        <span>if</span> <span>(</span>factor <span>*</span> factor <span>==</span> num<span>)</span> <span>{</span>
            res <span>+=</span> factor<span>;</span>
        <span>}</span>
        <span>return</span> res <span>==</span> num<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>checkPerfectNumber</span><span>(</span>self<span>,</span> num<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>

        <span># 特判</span>
        <span>if</span> num <span>==</span> <span>1</span><span>:</span>
            <span>return</span> <span>False</span>
        <span># 所有乘法因子的和存在这里</span>
        res <span>=</span> <span>1</span>
        <span># 可能的乘法因子，从 2 开始</span>
        factor <span>=</span> <span>2</span>
        <span>while</span> factor <span>*</span> factor <span>&lt;</span> num<span>:</span>
            <span>if</span> num <span>%</span> factor <span>==</span> <span>0</span><span>:</span>
                res <span>+=</span> factor
                res <span>+=</span> <span>(</span>num <span>//</span> factor<span>)</span>
            factor <span>+=</span> <span>1</span>
        <span># 把中间那个数单独拿出来</span>
        <span>if</span> factor <span>*</span> factor <span>==</span> num<span>:</span>
            res <span>+=</span> factor
        <span>return</span> res <span>==</span> num
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数学" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:10:57.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">例 1：「力扣」第 26 题：删除排序数组中的重复项（简单）</title>
    <id>https://suanfa8.com/loop-invariant/solutions/0026-remove-duplicates-from-sorted-array/</id>
    <link href="https://suanfa8.com/loop-invariant/solutions/0026-remove-duplicates-from-sorted-array/"/>
    <updated>2022-01-13T15:14:00.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener noreferrer">26. 删除排序数组中的重复项<i>Content not supported</i></a> <i>Content not supported</i>。</li>
</ul>
<h3 id="视频教程"> 📺 <strong>视频教程</strong></h3>
<p>建议使用 1.5 倍速观看。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=2" target="_blank" rel="noopener noreferrer">3-2 例 1：「力扣」第 26 题：删除数组中重复的元素（06:20）<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=2" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=504293075&bvid=BV1Jg411M7Lp&cid=375380886&page=2" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个排序数组，你需要在 <strong>原地</strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span> 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>给定数组 nums = [1,1,2],

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以 <strong>“引用”</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下：</p>
<div><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（思路分析在「视频教程」，在这里只给出「参考代码」。）</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> len<span>;</span>
        <span>}</span>
        <span>// 循环不变量：nums[0..j）是移除重复元素以后的数组</span>
        <span>int</span> j <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
                <span>// 注意顺序：先更新值，再递增下标</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> j<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> len<span>;</span>
        <span>}</span>
        <span>// 循环不变量：nums[0..j] 是移除重复元素以后的数组</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                j<span>++</span><span>;</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> j <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是输入数组的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，只使用了常数个变量。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="循环不变量" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:09:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">例 3：「力扣」第 27 题：移除元素（简单）</title>
    <id>https://suanfa8.com/loop-invariant/solutions/0027-remove-element/</id>
    <link href="https://suanfa8.com/loop-invariant/solutions/0027-remove-element/"/>
    <updated>2022-01-13T15:14:00.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/remove-element/description/" target="_blank" rel="noopener noreferrer">27. 移除元素<i>Content not supported</i></a> <i>Content not supported</i>。</li>
</ul>
<h3 id="视频教程"> 📺 <strong>视频教程</strong></h3>
<p>建议使用 1.5 倍速观看。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=4" target="_blank" rel="noopener noreferrer">3-4 例 3：「力扣」第 27 题：移除元素（03:17）<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=4" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=504293075&bvid=BV1Jg411M7Lp&cid=375382765&page=4" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<div><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（思路分析在「视频教程」，在这里只给出「参考代码」。）</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>removeElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> len<span>;</span>
        <span>}</span>

        <span>// 循环不变量：nums[0..j) != val</span>
        <span>// j 指向了下一个要赋值的元素的位置</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> val<span>)</span> <span>{</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> j<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>removeElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>// 循环不变量：nums[0..j] != val</span>
        <span>// 等于 val 的时候跳过</span>
        <span>// 不等于 val 的时候赋值</span>
        <span>int</span> j <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> val<span>)</span> <span>{</span>
                j<span>++</span><span>;</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> j <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是输入数组的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，只使用了常数个变量。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="循环不变量" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:09:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">例 4：「力扣」第 80 题：删除排序数组中的重复项 II（中等）</title>
    <id>https://suanfa8.com/loop-invariant/solutions/0080-remove-duplicates-from-sorted-array-ii/</id>
    <link href="https://suanfa8.com/loop-invariant/solutions/0080-remove-duplicates-from-sorted-array-ii/"/>
    <updated>2022-01-13T15:14:00.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener noreferrer">80. 删除排序数组中的重复项 II<i>Content not supported</i></a> <i>Content not supported</i>。</li>
</ul>
<h3 id="视频教程"> 📺 <strong>视频教程</strong></h3>
<p>建议使用 1.5 倍速观看。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=5" target="_blank" rel="noopener noreferrer">3-5 例 4：「力扣」第 80 题：删除数组中重复的元素 II（07:30）<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=5" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=504293075&bvid=BV1Jg411M7Lp&cid=375383286&page=5" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个排序数组，你需要在 <strong>原地</strong> 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以 <strong>“引用”</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<div><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（思路分析在「视频教程」，在这里只给出「参考代码」。）</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>&lt;</span> <span>2</span><span>)</span><span>{</span>
            <span>return</span> len<span>;</span>
        <span>}</span>

        <span>// 循环不变量：nums[0..j) 是有序的，并且相同元素最多保留 2 次</span>
        <span>// j 指向下一个要赋值的元素的位置</span>
        <span>int</span> j <span>=</span> <span>2</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>j <span>-</span> <span>2</span><span>]</span><span>)</span><span>{</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> j<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution2</span> <span>{</span>

    <span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>&lt;</span> <span>2</span><span>)</span><span>{</span>
            <span>return</span> len<span>;</span>
        <span>}</span>

        <span>// 循环不变量：nums[0..j] 是有序的，并且相同元素最多保留 2 次</span>
        <span>// j 已经赋值过的元素的最后一个位置</span>
        <span>int</span> j <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>{</span>
                j<span>++</span><span>;</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> j <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是输入数组的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，只使用了常数个变量。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="循环不变量" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:09:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">例 2：「力扣」第 283 题：移动零（简单）</title>
    <id>https://suanfa8.com/loop-invariant/solutions/0283-move-zeroes/</id>
    <link href="https://suanfa8.com/loop-invariant/solutions/0283-move-zeroes/"/>
    <updated>2022-01-13T15:14:00.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/move-zeroes/description/" target="_blank" rel="noopener noreferrer">283. 移动零<i>Content not supported</i></a> <i>Content not supported</i> ；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/move-zeroes/solution/zun-shou-xun-huan-bu-bian-shi-java-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">遵守循环不变式（Java）<i>Content not supported</i></a>。</li>
</ul>
<h3 id="视频教程"> 📺 <strong>视频教程</strong></h3>
<p>建议使用 1.5 倍速观看。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=3" target="_blank" rel="noopener noreferrer">3-3 例 2：「力扣」第 283 题：移动零（03:26）<i>Content not supported</i></a>。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://www.bilibili.com/video/BV1Jg411M7Lp?p=3" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=504293075&bvid=BV1Jg411M7Lp&cid=375382369&page=3" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<div><pre><code>输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<p>（思路分析在「视频教程」，在这里只给出「参考代码」。）</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>void</span> <span>moveZeroes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>// 循环不变量：nums[0..j) !=0, nums[j..i) = 0</span>
        <span>// j 指向了下一个要赋值的元素的位置</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> j<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            nums<span>[</span>i<span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>}</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>void</span> <span>moveZeroes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>// 循环不变式：nums[0..j] != 0，nums(j..i) == 0</span>
        <span>int</span> j <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                j<span>++</span><span>;</span>
                <span>swap</span><span>(</span>nums<span>,</span> j<span>,</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是输入数组的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，只使用了常数个变量。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="循环不变量" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:09:01.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 523 题：连续的子数组（中等）</title>
    <id>https://suanfa8.com/presum-hashtable/solutions/0523-continuous-subarray-sum/</id>
    <link href="https://suanfa8.com/presum-hashtable/solutions/0523-continuous-subarray-sum/"/>
    <updated>2022-01-13T16:19:20.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener noreferrer">523. 连续的子数组和<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小 <strong>至少为 2</strong> ，且</li>
<li>子数组元素总和为 <code>k</code> 的倍数。</li>
</ul>
<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [23,2,6,4,7], k = 13
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>s</span><span>u</span><span>m</span><span>(</span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>])</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.136em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<blockquote>
<p><strong>说明</strong>：本题解修改自原始的官方题解，现在的官方题解已经被官方题解团队修改过。</p>
</blockquote>
<p><strong>概述</strong>：</p>
<ul>
<li>这道问题我们使用三种方法，层层递进介绍了这个问题的解法，基本的思路是 <strong>空间换时间</strong>；</li>
<li>如果空间使用恰当，可以减少遍历的次数；</li>
<li>这道问题的方法二和方法三都很有代表性，大家需要仔细体会。</li>
</ul>
<hr>
<h2 id="方法一-暴力解法-超时"> 方法一：暴力解法（超时）</h2>
<p>考虑所有长度 <strong>大于等于</strong> <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的连续子数组，将各个子数组遍历一遍求和，并判断和是否是给定整数 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.03148em;">k</span></span></span></span> 的倍数。</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>checkSubarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> left <span>=</span> <span>0</span><span>;</span> left <span>&lt;</span> len <span>-</span> <span>1</span><span>;</span> left<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> right <span>=</span> left <span>+</span> <span>1</span><span>;</span> right <span>&lt;</span> len<span>;</span> right<span>++</span><span>)</span> <span>{</span>
                <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> left<span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    sum <span>+=</span> nums<span>[</span>i<span>]</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>sum <span>==</span> k <span>||</span> <span>(</span>k <span>!=</span> <span>0</span> <span>&amp;&amp;</span> sum <span>%</span> k <span>==</span> <span>0</span><span>)</span><span>)</span> <span>{</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span style="margin-right:0.10903em;">N</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>3</span></span></span></span></span></span></span></span><span>)</span></span></span></span> 。三重嵌套的 <code>for</code> 循环遍历数组；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span> ，只用了常数个额外变量。</li>
</ul>
<h2 id="方法-2-前缀和-超时"> 方法 2：前缀和（超时）</h2>
<p><strong>基本思想</strong>：空间换时间。</p>
<ul>
<li>注意到题目中我们求连续子数组的区间和；</li>
<li>求区间和的一个基本的技巧是：根据前缀和的差，求出区间和。</li>
</ul>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>checkSubarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>// preSum[i] 表示：区间 [0..i) 的前缀和</span>
        <span>int</span><span>[</span><span>]</span> preSum <span>=</span> <span>new</span> <span>int</span><span>[</span>len <span>+</span> <span>1</span><span>]</span><span>;</span>
        preSum<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            preSum<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>=</span> preSum<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>


        <span>for</span> <span>(</span><span>int</span> left <span>=</span> <span>0</span><span>;</span> left <span>&lt;</span> len <span>-</span> <span>1</span><span>;</span> left<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> right <span>=</span> left <span>+</span> <span>1</span><span>;</span> right <span>&lt;</span> len<span>;</span> right<span>++</span><span>)</span> <span>{</span>
                <span>int</span> sum <span>=</span> preSum<span>[</span>right <span>+</span> <span>1</span><span>]</span> <span>-</span> preSum<span>[</span>left<span>]</span><span>;</span>
                <span>if</span> <span>(</span>sum <span>==</span> k <span>||</span> <span>(</span>k <span>!=</span> <span>0</span> <span>&amp;&amp;</span> sum <span>%</span> k <span>==</span> <span>0</span><span>)</span><span>)</span> <span>{</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度： <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span>n</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span> 。为了考虑每一个子数组，我们需要一个 2 重嵌套的循环。</li>
<li>空间复杂度： <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span> 。 使用了长度为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>n</span></span></span></span> 的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>s</span><span>u</span><span>m</span></span></span></span> 数组。</li>
</ul>
<blockquote>
<p>事实上，当前问题是一个计数问题，根据求解 <a href="/problems/two-sum/">1. 两数之和</a> 的经验，我们可以在遍历的过程当中记录已经出现的信息，这样就可以通过一次遍历完成计算。已经遍历过的信息就需要记录下来，我们使用 <strong>哈希表</strong>。</p>
</blockquote>
<hr>
<h2 id="方法-3-前缀与哈希表"> 方法 3：前缀与哈希表</h2>
<p>使用哈希表保存到下标 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6595em;"></span><span>i</span></span></span></span> 个止的元素的和，并且 <strong>对这个前缀和除以 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.03148em;">k</span></span></span></span> 取余数（请大家思考这是为什么？）</strong>。</p>
<p>原因如下：遍历输入数组，记录到当前位置为止的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8056em;vertical-align:-0.0556em;"></span><span>s</span><span>u</span><span>m</span><span>%</span><span style="margin-right:0.03148em;">k</span></span></span></span>，一旦我们找到新的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8056em;vertical-align:-0.0556em;"></span><span>s</span><span>u</span><span>m</span><span>%</span><span style="margin-right:0.03148em;">k</span></span></span></span> 的值（即在哈希表中没有这个值），我们就 <strong>往哈希表中插入一条记录 key：<code>sum % k</code>，value：<code>i</code></strong>。</p>
<p>假设第 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6595em;"></span><span>i</span></span></span></span> 个位置的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>s</span><span>u</span><span>m</span></span></span></span> 的值为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>re</span><span>m</span></span></span></span>。如果以 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6595em;"></span><span>i</span></span></span></span> 为左端点的任何子数组的和是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.03148em;">k</span></span></span></span> 的倍数，假设该位置为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.854em;vertical-align:-0.1944em;"></span><span style="margin-right:0.05724em;">j</span></span></span></span> ，那么哈希表中第 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.854em;vertical-align:-0.1944em;"></span><span style="margin-right:0.05724em;">j</span></span></span></span> 个元素保存的值为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>re</span><span>m</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4653em;"></span><span>n</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03148em;">k</span><span>)</span><span>%</span><span style="margin-right:0.03148em;">k</span></span></span></span> ，其中 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.5782em;vertical-align:-0.0391em;"></span><span>n</span><span style="margin-right:0.2778em;"></span><span>&gt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 整数。发现 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>re</span><span>m</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4653em;"></span><span>n</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03148em;">k</span><span>)</span><span>%</span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.4306em;"></span><span>re</span><span>m</span></span></span></span> ，也就是跟第 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6595em;"></span><span>i</span></span></span></span> 个元素保存到哈希表 中的值相同。</p>
<p>基于这一观察，可以得出结论：</p>
<p>无论何时，只要 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8056em;vertical-align:-0.0556em;"></span><span>s</span><span>u</span><span>m</span><span>%</span><span style="margin-right:0.03148em;">k</span></span></span></span> 的值已经被放入哈希表，代表着有两个下标 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6595em;"></span><span>i</span></span></span></span> 和 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.854em;vertical-align:-0.1944em;"></span><span style="margin-right:0.05724em;">j</span></span></span></span> ，它们之间元素的和是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.03148em;">k</span></span></span></span> 的整数倍。因此只要哈希表中有相同的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8056em;vertical-align:-0.0556em;"></span><span>s</span><span>u</span><span>m</span><span>%</span><span style="margin-right:0.03148em;">k</span></span></span></span> ，就可以直接返回 <span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \teat at position 1: \̲t̲e̲a̲t̲{True}'>\teat{True}</span> 。</p>
<p>下面的幻灯片描述了数组 <code>nums = [2, 5, 33, 6, 7, 25, 15]</code> 且 <code>k = 13</code> 的求解过程。</p>
<Presentation id="presentation-64a56eee" data-code="%0A!%5Bimage.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Ffff44f1a5a0d964210afb0dc29eccb594838ac5c042f383e63ffa2c9f1f337e0-image.png)%0A%0A---%0A%0A!%5Bimage.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fe4c4cdbd7f678e580a0c4b98bcb7d5ce34f0165012acdbcd332b8cc425a58eb5-image.png)%0A%0A---%0A%0A!%5Bimage.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F758b7f8f4ea5af1d91802792699591c435832f6e63c63d5a0deec701b368839e-image.png)%0A%0A---%0A%0A!%5Bimage.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F07cb8e8d956cc2d3a2d18df59d537d2e8ba75bbddde7f9de4f233663b70b8ff4-image.png)%0A%0A---%0A%0A!%5Bimage.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F2a09f77a87eee9396bba1b41a98eb5ef0ef5d64d126414b5c4bd63d1c16b54a4-image.png)%0A%0A---%0A%0A!%5Bimage.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F0a3a37abed5345ce6b70f877774674a8ccd3e31681f50d3b3917f0ea055c766c-image.png)%0A" theme="auto"></Presentation><div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashMap</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Map</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>checkSubarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>

        <span>// key：区间 [0..i] 里所有元素的和 % k</span>
        <span>// value：下标 i</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>// 理解初始化的意义</span>
        map<span>.</span><span>put</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sum <span>+=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>if</span> <span>(</span>k <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                sum <span>=</span> sum <span>%</span> k<span>;</span>
            <span>}</span>

            <span>if</span> <span>(</span>map<span>.</span><span>containsKey</span><span>(</span>sum<span>)</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>i <span>-</span> map<span>.</span><span>get</span><span>(</span>sum<span>)</span> <span>></span> <span>1</span><span>)</span> <span>{</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>else</span> <span>{</span>
                map<span>.</span><span>put</span><span>(</span>sum<span>,</span> i<span>)</span><span>;</span>
            <span>}</span>

        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，仅需要遍历输入数组一遍；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>min</span><span>(</span><span>n</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03148em;">k</span><span>))</span></span></span></span>。哈希表最多包含 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>min</span><span>(</span><span>n</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03148em;">k</span><span>)</span></span></span></span> 个不同的元素。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="前缀和" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:28.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 525 题：连续数组（中等）</title>
    <id>https://suanfa8.com/presum-hashtable/solutions/0525-contiguous-array/</id>
    <link href="https://suanfa8.com/presum-hashtable/solutions/0525-contiguous-array/"/>
    <updated>2022-01-13T16:19:20.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/contiguous-array/" target="_blank" rel="noopener noreferrer">525. 连续数组<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/contiguous-array/solution/qian-zhui-he-chai-fen-ha-xi-biao-java-by-liweiwei1/" target="_blank" rel="noopener noreferrer">前缀和与哈希表（Java）、相关问题推荐<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>数据范围</strong>：</p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span><span>nums.length</span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
<li>输入数组的值只包含 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 和 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>首先想到的是「暴力解法」，使用两个 <code>for</code> 循环枚举所有可能的区间，然后判断区间是否符合题意，进而计算区间的长度。</p>
<p>这道题如果之前没有做过相关的问题，很难想到比较好的思路。这里我的思路来自「力扣」第 1371 题：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener noreferrer">每个元音包含偶数次的最长子字符串<i>Content not supported</i></a>，周赛的时候没有做出来。学习了 <a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/" target="_blank" rel="noopener noreferrer">题解<i>Content not supported</i></a> 以后知道了「前缀和」与「哈希表」经常配合使用。</p>
<h2 id="为什么不是滑动窗口"> 为什么不是滑动窗口</h2>
<p>求 <strong>连续</strong> 区间里的性质，一种思路是「滑动窗口」。但是本题，如果我们找到了一个连续子区间里有相同个数的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 和 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> ，左端点相同且更长的连续子区间很可能也有相同个数的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 和 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>。</p>
<h2 id="通过前缀和求区间和"> 通过前缀和求区间和</h2>
<p><strong>注意</strong>：只记录某个前缀和数字第 1 次出现的下标，因为我们要求的是最长。</p>
<ul>
<li>这里引入一个概念，叫做「不变量」，题目要我们找的「不变量」是「区间里」 <code>0</code> 的个数和 <code>1</code> 的个数相等的区间的长度；</li>
<li>但是发现很难下手，另一种思路就是「前缀和之差」，这一点在学习「线段树」的时候，是作为例子引入的；</li>
<li><strong>重点思路</strong>：要利用到「前缀和」还有希望能够通过一次遍历记住结果，多半要使用到哈希表，这里做的一个处理是把所有的 <code>0</code> 都看成 <code>-1</code>，如此一来：<strong>如果一个区间的和是 <code>0</code> ，就说明这个区间里的 <code>0</code>（被视为 <code>-1</code>） 和 1 的数量相同</strong>；</li>
<li>由于求的是最长区间，因此就需要记录前缀和的数值第 1 次出现的下标，相同的前缀再次出现，就说明这一段区间的和为 <code>0</code>（把 <code>0</code> 看成 <code>-1</code> 以后），在遍历的过程中，记录最长的区间的长度；</li>
<li>区间的问题几个思路供参考：滑动窗口（双指针）；前缀和的差；线段树（树状数组）。</li>
</ul>
<h2 id="总结"> 总结</h2>
<ul>
<li>一开始介绍的「不变量」是比较繁琐的，把它转换成一个等价的表示，就使得解决问题变得简单；</li>
<li>在编码的过程中，还需要注意一些细节，这里放在代码注释里说明；</li>
<li>有相关问题的经验还是比较重要的，在平常刷题的过程中需要多总结。</li>
</ul>
<p>可以做一下相似的问题，「力扣」第 352 题：<a href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/" target="_blank" rel="noopener noreferrer">和等于 k 的最长子数组长度<i>Content not supported</i></a>。</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashMap</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Map</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>findMaxLength</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span>len<span>)</span><span>;</span>
        <span>// 下标 0 之前的位置是 -1，注意：可以理解为哨兵</span>
        map<span>.</span><span>put</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>

        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>int</span> preSum <span>=</span> <span>0</span><span>;</span>

        <span>// 把数组中的 0 都看成 -1</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// pre 是先加了，所以后面计算的时候是 i - map.get(preSum)</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                preSum <span>+=</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                preSum <span>+=</span> <span>-</span><span>1</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>(</span>map<span>.</span><span>containsKey</span><span>(</span>preSum<span>)</span><span>)</span> <span>{</span>
                res <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>res<span>,</span> i <span>-</span> map<span>.</span><span>get</span><span>(</span>preSum<span>)</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// 注意：只记录这个数字第 1 次出现的下标</span>
                map<span>.</span><span>put</span><span>(</span>preSum<span>,</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度，算法遍历了一次数组，每一个元素的操作都是常数次的，因此整体时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="前缀和" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:28.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 974 题：和可被 K 整除的子数组（中等）</title>
    <id>https://suanfa8.com/presum-hashtable/solutions/0974-subarray-sums-divisible-by-k/</id>
    <link href="https://suanfa8.com/presum-hashtable/solutions/0974-subarray-sums-divisible-by-k/"/>
    <updated>2022-01-13T16:19:20.000Z</updated>
    <content type="html"><![CDATA[<div><p>说明</p>
<p>时间有限，未能详细编写，请大家理解，可以前往该题的题解区与评论区查看适合自己的题解。</p>
</div>
<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener noreferrer">974. 和可被 K 整除的子数组<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p>
<p><strong>示例</strong>：</p>
<div><pre><code>输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>2 &lt;= K &lt;= 10000</code></li>
</ol>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>subarraysDivByK</span><span>(</span><span>int</span><span>[</span><span>]</span> <span>A</span><span>,</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> <span>A</span><span>.</span>length<span>;</span>

        <span>// 前缀和出现的次数</span>
        <span>// key: i 之前的前缀和，value：出现的次数</span>
        <span>int</span><span>[</span><span>]</span> preSumCount <span>=</span> <span>new</span> <span>int</span><span>[</span><span>K</span><span>]</span><span>;</span>
        preSumCount<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>

        <span>int</span> preSum <span>=</span> <span>0</span><span>;</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> value <span>:</span> <span>A</span><span>)</span> <span>{</span>
            preSum <span>+=</span> value<span>;</span>

            <span>int</span> remainder <span>=</span> <span>(</span>preSum <span>%</span> <span>K</span> <span>+</span> <span>K</span><span>)</span> <span>%</span> <span>K</span><span>;</span>
            <span>int</span> count <span>=</span> preSumCount<span>[</span>remainder<span>]</span><span>;</span>
            res <span>+=</span> count<span>;</span>

            preSumCount<span>[</span>remainder<span>]</span><span>++</span><span>;</span>

        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution3</span> <span>{</span>

    <span>// 哈希表</span>

    <span>public</span> <span>int</span> <span>subarraysDivByK</span><span>(</span><span>int</span><span>[</span><span>]</span> <span>A</span><span>,</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> <span>A</span><span>.</span>length<span>;</span>

        <span>// 前缀和出现的次数</span>
        <span>// key: i 之前的前缀和，value：出现的次数</span>
        <span>int</span><span>[</span><span>]</span> preSumCount <span>=</span> <span>new</span> <span>int</span><span>[</span><span>K</span><span>]</span><span>;</span>
        preSumCount<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>

        <span>int</span> preSum <span>=</span> <span>0</span><span>;</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> value <span>:</span> <span>A</span><span>)</span> <span>{</span>
            preSum <span>+=</span> value<span>;</span>

            <span>// (preSum % K + K) % K 这句话要解释清楚</span>
            <span>int</span> remainder <span>=</span> <span>(</span>preSum <span>%</span> <span>K</span> <span>+</span> <span>K</span><span>)</span> <span>%</span> <span>K</span><span>;</span>
            <span>int</span> count <span>=</span> preSumCount<span>[</span>remainder<span>]</span><span>;</span>
            res <span>+=</span> count<span>;</span>

            preSumCount<span>[</span>remainder<span>]</span><span>++</span><span>;</span>

        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>int</span><span>[</span><span>]</span> <span>A</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>4</span><span>,</span> <span>5</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>1</span><span>}</span><span>;</span>
        <span>int</span> <span>K</span> <span>=</span> <span>5</span><span>;</span>

<span>//        int[] A = new int[]{-5};</span>
<span>//        int K = 5;</span>
        <span>Solution3</span> solution <span>=</span> <span>new</span> <span>Solution3</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> res <span>=</span> solution<span>.</span><span>subarraysDivByK</span><span>(</span><span>A</span><span>,</span> <span>K</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>res<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="前缀和" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:28.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 560 题：和为 K 的子数组（中等）</title>
    <id>https://suanfa8.com/presum-hashtable/solutions/0560-subarray-sum-equals-k/</id>
    <link href="https://suanfa8.com/presum-hashtable/solutions/0560-subarray-sum-equals-k/"/>
    <updated>2022-01-13T16:19:20.000Z</updated>
    <content type="html"><![CDATA[<div><p>说明</p>
<p>分享一下，没有会员的朋友可以做类似 352 题的 560 题。</p>
</div>
<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener noreferrer">560. 和为 K 的子数组<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/bao-li-jie-fa-qian-zhui-he-qian-zhui-he-you-hua-ja/" target="_blank" rel="noopener noreferrer">暴力解法、前缀和、前缀和优化（Java）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [1,1,1], k = 2
输出：2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [1,2,3], k = 3
输出：2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-10^7 &lt;= k &lt;= 10^7</code></li>
</ul>
<h2 id="方法一-暴力解法-超时"> 方法一：暴力解法（超时）</h2>
<ul>
<li>枚举左右边界（超时）。</li>
</ul>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>subarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> count <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> left <span>=</span> <span>0</span><span>;</span> left <span>&lt;</span> len<span>;</span> left<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> right <span>=</span> left<span>;</span> right <span>&lt;</span> len<span>;</span> right<span>++</span><span>)</span> <span>{</span>

                <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> left<span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    sum <span>+=</span> nums<span>[</span>i<span>]</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>sum <span>==</span> k<span>)</span> <span>{</span>
                    count<span>++</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/9074405a1aeb2b91c003db60608401ef.svg#card=math&amp;code=O(N^3)&amp;height=23&amp;width=49" alt="" loading="lazy">，这里  <img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg#card=math&amp;code=N&amp;height=16&amp;width=15" alt="" loading="lazy">  是数组的长度；</li>
<li>空间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/5e079a28737d5dd019a3b8f6133ee55e.svg#card=math&amp;code=O(1)&amp;height=20&amp;width=34" alt="" loading="lazy">。</li>
</ul>
<h2 id="方法二-暴力解法的优化"> 方法二：暴力解法的优化</h2>
<p>固定了起点，即枚举左边界，时间复杂度降了一维。
Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>subarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> count <span>=</span> <span>0</span><span>;</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> left <span>=</span> <span>0</span><span>;</span> left <span>&lt;</span> len<span>;</span> left<span>++</span><span>)</span> <span>{</span>
            <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
            <span>// 区间里可能会有一些互相抵销的元素</span>
            <span>for</span> <span>(</span><span>int</span> right <span>=</span> left<span>;</span> right <span>&lt;</span> len<span>;</span> right<span>++</span><span>)</span> <span>{</span>
                sum <span>+=</span> nums<span>[</span>right<span>]</span><span>;</span>
                <span>if</span> <span>(</span>sum <span>==</span> k<span>)</span> <span>{</span>
                    count<span>++</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/8e9c5fee65a4f32abccd0e83ff203e39.svg#card=math&amp;code=O(N^2)&amp;height=23&amp;width=49" alt="" loading="lazy">，这里 <img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg#card=math&amp;code=N&amp;height=16&amp;width=15" alt="" loading="lazy">  是数组的长度；</li>
<li>空间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/5e079a28737d5dd019a3b8f6133ee55e.svg#card=math&amp;code=O(1)&amp;height=20&amp;width=34" alt="" loading="lazy">。</li>
</ul>
<h2 id="方法三-前缀和"> 方法三：前缀和</h2>
<ul>
<li>构建前缀和数组，以便快速计算区间和；</li>
<li>注意在计算区间和的时候，下标有偏移。</li>
</ul>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>subarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>// 计算前缀和数组</span>
        <span>int</span><span>[</span><span>]</span> preSum <span>=</span> <span>new</span> <span>int</span><span>[</span>len <span>+</span> <span>1</span><span>]</span><span>;</span>
        preSum<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            preSum<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>=</span> preSum<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>

        <span>int</span> count <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> left <span>=</span> <span>0</span><span>;</span> left <span>&lt;</span> len<span>;</span> left<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> right <span>=</span> left<span>;</span> right <span>&lt;</span> len<span>;</span> right<span>++</span><span>)</span> <span>{</span>
                <span>// 区间和 [left..right]，注意下标偏移</span>
                <span>if</span> <span>(</span>preSum<span>[</span>right <span>+</span> <span>1</span><span>]</span> <span>-</span> preSum<span>[</span>left<span>]</span> <span>==</span> k<span>)</span> <span>{</span>
                    count<span>++</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/8e9c5fee65a4f32abccd0e83ff203e39.svg#card=math&amp;code=O(N^2)&amp;height=23&amp;width=49" alt="" loading="lazy">，这里 <img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg#card=math&amp;code=N&amp;height=16&amp;width=15" alt="" loading="lazy">  是数组的长度；</li>
<li>空间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/33697ce7dfa48ba80980d298c8089378.svg#card=math&amp;code=O(N)&amp;height=20&amp;width=41" alt="" loading="lazy">。</li>
</ul>
<h2 id="方法四-前缀和-哈希表优化"> 方法四：前缀和 + 哈希表优化</h2>
<ul>
<li>使用哈希表加速运算；</li>
</ul>
<p>这个思路不是很容易想到，需要多做一些类似的问题慢慢培养感觉。</p>
<ul>
<li>同类问题有：
<ul>
<li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener noreferrer">「力扣」第 1 题：两数之和<i>Content not supported</i></a>；</li>
<li><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener noreferrer">「力扣」第 1248 题： 统计「优美子数组」<i>Content not supported</i></a>；</li>
<li><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener noreferrer">「力扣」第 454 题：四数相加 II<i>Content not supported</i></a>。</li>
</ul>
</li>
</ul>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashMap</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Map</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>subarraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>// key：前缀和，value：key 对应的前缀和的个数</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> preSumFreq <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>// 对于下标为 0 的元素，前缀和为 0</span>
        preSumFreq<span>.</span><span>put</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>;</span>

        <span>int</span> preSum <span>=</span> <span>0</span><span>;</span>
        <span>int</span> count <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            preSum <span>+=</span> num<span>;</span>

            <span>// 先获得前缀和为 preSum - k 的个数，加到计数变量里</span>
            <span>if</span> <span>(</span>preSumFreq<span>.</span><span>containsKey</span><span>(</span>preSum <span>-</span> k<span>)</span><span>)</span> <span>{</span>
                count <span>+=</span> preSumFreq<span>.</span><span>get</span><span>(</span>preSum <span>-</span> k<span>)</span><span>;</span>
            <span>}</span>

            <span>// 然后维护 preSumFreq 的定义</span>
            preSumFreq<span>.</span><span>put</span><span>(</span>preSum<span>,</span> preSumFreq<span>.</span><span>getOrDefault</span><span>(</span>preSum<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/33697ce7dfa48ba80980d298c8089378.svg#card=math&amp;code=O(N)&amp;height=20&amp;width=41" alt="" loading="lazy">，这里 <img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg#card=math&amp;code=N&amp;height=16&amp;width=15" alt="" loading="lazy">  是数组的长度；</li>
<li>空间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/33697ce7dfa48ba80980d298c8089378.svg#card=math&amp;code=O(N)&amp;height=20&amp;width=41" alt="" loading="lazy">。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="前缀和" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:28.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1248 题：统计「优美子数组」（中等）</title>
    <id>https://suanfa8.com/presum-hashtable/solutions/1248-count-number-of-nice-subarrays/</id>
    <link href="https://suanfa8.com/presum-hashtable/solutions/1248-count-number-of-nice-subarrays/"/>
    <updated>2022-08-08T06:57:46.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener noreferrer">1248. 统计「优美子数组」<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 nums 和一个整数 k。</p>
<p>如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>
<p>请返回这个数组中「优美子数组」的数目。</p>
<p>示例 1：</p>
<div><pre><code>输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例 2：</p>
<div><pre><code>输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例 3：</p>
<div><pre><code>输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
输出：16
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示</strong>：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h2 id="方法-前缀和"> 方法：前缀和</h2>
<ul>
<li><code>count</code> 是哈希表，它记录了：<code>key</code> ：前缀里包含的奇数个数，<code>value</code> ：出现了多少次。</li>
</ul>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>numberOfSubarrays</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span><span>[</span><span>]</span> count <span>=</span> <span>new</span> <span>int</span><span>[</span>len <span>+</span> <span>1</span><span>]</span><span>;</span>
        count<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>int</span> preSum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            <span>// preSum += (num % 2 == 1 ? 1 : 0);</span>
            preSum <span>+=</span> <span>(</span>num <span>&amp;</span> <span>1</span><span>)</span><span>;</span>
            count<span>[</span>preSum<span>]</span><span>++</span><span>;</span>
            <span>if</span> <span>(</span>preSum <span>>=</span> k<span>)</span> <span>{</span>
                res <span>+=</span> count<span>[</span>preSum <span>-</span> k<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="前缀和" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:28.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1314 题：矩阵区域和（简单）</title>
    <id>https://suanfa8.com/presum-hashtable/solutions/1314-matrix-block-sum/</id>
    <link href="https://suanfa8.com/presum-hashtable/solutions/1314-matrix-block-sum/"/>
    <updated>2022-01-13T16:19:20.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/matrix-block-sum/" target="_blank" rel="noopener noreferrer">1314. 矩阵区域和<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/matrix-block-sum/solution/qian-zhui-he-ju-zhen-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">前缀和矩阵<i>Content not supported</i></a>。</li>
</ul>
<p>参考「力扣」第 304 题：<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener noreferrer">“二维区域和检索 - 矩阵不可变”<i>Content not supported</i></a> 的做法。</p>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个 <code>m x n</code> 的矩阵 <code>mat</code> 和一个整数 <code>k</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和：</p>
<ul>
<li><code>i - k &lt;= r &lt;= i + k,</code></li>
<li><code>j - k &lt;= c &lt;= j + k</code> 且</li>
<li><code>(r, c)</code> 在矩阵内。</li>
</ul>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[12,21,16],[27,45,33],[24,39,28]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
输出：[[45,45,45],[45,45,45],[45,45,45]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n, k &lt;= 100</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<ul>
<li>先计算前缀和矩阵；</li>
<li>再计算有效区域的左上角以及右下角的坐标；</li>
<li>再使用前缀和矩阵以 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span> 复杂度计算区域之和。</li>
</ul>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>/**
     * 前缀和矩阵
     */</span>
    <span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> preSum<span>;</span>

    <span>public</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>matrixBlockSum</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> mat<span>,</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
        <span>// 行数和列数不用特判，因为题目已经说了不为 0</span>
        <span>int</span> rows <span>=</span> mat<span>.</span>length<span>;</span>
        <span>int</span> cols <span>=</span> mat<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>

        <span>// 初始化的时候多设置一行，多设置一列</span>
        preSum <span>=</span> <span>new</span> <span>int</span><span>[</span>rows <span>+</span> <span>1</span><span>]</span><span>[</span>cols <span>+</span> <span>1</span><span>]</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rows<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> cols<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                preSum<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>=</span> preSum<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>+</span> preSum<span>[</span>i<span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>-</span> preSum<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>+</span> mat<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span>rows<span>]</span><span>[</span>cols<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rows<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> cols<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>// 左上角横纵坐标</span>
                <span>int</span> row1 <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>i <span>-</span> <span>K</span><span>,</span> <span>0</span><span>)</span><span>;</span>
                <span>int</span> col1 <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>j <span>-</span> <span>K</span><span>,</span> <span>0</span><span>)</span><span>;</span>

                <span>// 右下角横纵坐标</span>
                <span>int</span> row2 <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>i <span>+</span> <span>K</span><span>,</span> rows <span>-</span> <span>1</span><span>)</span><span>;</span>
                <span>int</span> col2 <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>j <span>+</span> <span>K</span><span>,</span> cols <span>-</span> <span>1</span><span>)</span><span>;</span>
                res<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>sumRegion</span><span>(</span>row1<span>,</span> col1<span>,</span> row2<span>,</span> col2<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>sumRegion</span><span>(</span><span>int</span> row1<span>,</span> <span>int</span> col1<span>,</span> <span>int</span> row2<span>,</span> <span>int</span> col2<span>)</span> <span>{</span>
        <span>return</span> preSum<span>[</span>row2 <span>+</span> <span>1</span><span>]</span><span>[</span>col2 <span>+</span> <span>1</span><span>]</span>
                <span>-</span> preSum<span>[</span>row1<span>]</span><span>[</span>col2 <span>+</span> <span>1</span><span>]</span>
                <span>-</span> preSum<span>[</span>row2 <span>+</span> <span>1</span><span>]</span><span>[</span>col1<span>]</span>
                <span>+</span> preSum<span>[</span>row1<span>]</span><span>[</span>col1<span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">MN</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">M</span></span></span></span> 是矩阵的行数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是矩阵的列数；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">MN</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="前缀和" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:28.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 23 题：合并 K 个排序链表</title>
    <id>https://suanfa8.com/heap/solutions/0023-merge-k-sorted-lists/</id>
    <link href="https://suanfa8.com/heap/solutions/0023-merge-k-sorted-lists/"/>
    <updated>2022-01-12T23:38:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener noreferrer">23. 合并 K 个排序链表<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/" target="_blank" rel="noopener noreferrer">贪心算法、优先队列 + 分治法（Python 代码、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：lists = []
输出：[]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：lists = [[]]
输出：[]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<h2 id="方法-优先队列"> 方法：优先队列</h2>
<p>这是一道类似于教科书上例题的问题。这里我们举生活中的例子来理解求解思路，其实一点都不难。</p>
<p>假设有如下生活情境：假设你是一名体育老师，有 3 个班的学生，他们已经按照身高从矮到高排好成了 3 列纵队，现在要把这 3 个班的学生也按照身高从矮到高排列一列纵队。</p>
<p>我们可以这么做：</p>
<ol>
<li>
<p>让 3 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身，其余同学只能看到比前面同学脑袋高出的那部分；</p>
</li>
<li>
<p>每一次队首的 3 名同学，请出最矮的同学出列到“队伍 4”（即我们最终认为排好序的队列），出列的这一列的后一名同学向前走一步；</p>
</li>
<li>
<p>重复第 2 步，直到 3 个班的同学全部出列完毕。</p>
</li>
</ol>
<p>Python2 代码：</p>
<p>注意：以下代码在 Python2 中可以通过，Python3 中的 heapq 不支持传入自定义对象，不过可以绕一个弯子，把索引号传进去就可以了</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Comparator</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>PriorityQueue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>ListNode</span> <span>mergeKLists</span><span>(</span><span>ListNode</span><span>[</span><span>]</span> lists<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> lists<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>PriorityQueue</span><span><span>&lt;</span><span>ListNode</span><span>></span></span> minHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>len<span>,</span> <span>Comparator</span><span>.</span><span>comparingInt</span><span>(</span>o <span>-></span> o<span>.</span>val<span>)</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>ListNode</span> head <span>:</span> lists<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                minHeap<span>.</span><span>offer</span><span>(</span>head<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>ListNode</span> dummyNode <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        <span>ListNode</span> curNode <span>=</span> dummyNode<span>;</span>
        <span>while</span> <span>(</span><span>!</span>minHeap<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>// 注意：这里我们选择的操作是先从优先队列里拿出最小的元素，然后再添加</span>
            <span>// 事实上，如果优先队列有提供 replace 操作，应该优先选择 replace</span>
            <span>ListNode</span> top <span>=</span> minHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            curNode<span>.</span>next <span>=</span> top<span>;</span>

            curNode <span>=</span> curNode<span>.</span>next<span>;</span>

            <span>if</span> <span>(</span>top<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                minHeap<span>.</span><span>offer</span><span>(</span>top<span>.</span>next<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> dummyNode<span>.</span>next<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>mergeKLists</span><span>(</span>self<span>,</span> lists<span>)</span><span>:</span>
        <span>"""
        :type lists: List[ListNode]
        :rtype: ListNode
        """</span>
        <span>import</span> heapq
        l <span>=</span> <span>[</span><span>]</span>
        size <span>=</span> <span>len</span><span>(</span>lists<span>)</span>

        <span>for</span> index <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
            <span>if</span> lists<span>[</span>index<span>]</span><span>:</span>
                heapq<span>.</span>heappush<span>(</span>l<span>,</span> <span>(</span>lists<span>[</span>index<span>]</span><span>.</span>val<span>,</span> index<span>)</span><span>)</span>

        dummy_node <span>=</span> ListNode<span>(</span><span>-</span><span>1</span><span>)</span>
        cur <span>=</span> dummy_node

        <span>while</span> l<span>:</span>
            _<span>,</span> index <span>=</span> heapq<span>.</span>heappop<span>(</span>l<span>)</span>

            head <span>=</span> lists<span>[</span>index<span>]</span>

            cur<span>.</span><span>next</span> <span>=</span> head
            cur <span>=</span> cur<span>.</span><span>next</span>
            <span>if</span> head<span>.</span><span>next</span><span>:</span>
                heapq<span>.</span>heappush<span>(</span>l<span>,</span> <span>(</span>head<span>.</span><span>next</span><span>.</span>val<span>,</span> index<span>)</span><span>)</span>
                lists<span>[</span>index<span>]</span> <span>=</span> head<span>.</span><span>next</span>
                head<span>.</span><span>next</span> <span>=</span> <span>None</span>

        <span>return</span> dummy_node<span>.</span><span>next</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python2">
```python
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        import heapq
        l = []
        for head in lists:
            if head:
                heapq.heappush(l, (head.val, head))
        dummy_node = ListNode(-1)
        cur = dummy_node
<div><pre><code>    while l:
        _, head = heapq.heappop(l)
        cur.next = head
        cur = cur.next
        if head.next:
            heapq.heappush(l, (head.next.val, head.next))

    return dummy_node.next
</code></pre>
</div><div><pre><code>&lt;/CodeGroupItem&gt;
&lt;/CodeGroup&gt;



</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="优先队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:05.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 215 题：数组第 k 大的元素（中等）</title>
    <id>https://suanfa8.com/heap/solutions/0215-kth-largest-element-in-an-array/</id>
    <link href="https://suanfa8.com/heap/solutions/0215-kth-largest-element-in-an-array/"/>
    <updated>2022-01-12T23:38:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>中文网址：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener noreferrer">215. 数组中的第 K 个最大元素<i>Content not supported</i></a> ；</li>
<li>题解地址：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/" target="_blank" rel="noopener noreferrer">通过 partition 减治 + 优先队列（Java）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<hr>
<h2 id="思路分析"> 思路分析</h2>
<p>优先队列的思路是很朴素的。由于找第 <code>K</code> 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 <code>K</code> 个元素的最小堆：</p>
<ul>
<li>如果当前堆不满，直接添加；</li>
<li>堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新遍历到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</li>
</ul>
<p>说明：这里最合适的操作其实是 <code>replace()</code>，即直接把新读进来的元素放在堆顶，然后执行下沉（<code>siftDown()</code>）操作。Java 当中的 <code>PriorityQueue</code> 没有提供这个操作，只好先 <code>poll()</code> 再 <code>offer()</code>。</p>
<p>优先队列的写法就很多了，这里只例举一个有代表性的，其它的写法大同小异，没有本质差别。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Comparator</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>PriorityQueue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>// 使用一个含有 k 个元素的最小堆，PriorityQueue 底层是动态数组，为了防止数组扩容产生消耗，可以先指定数组的长度</span>
        <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> minHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>k<span>,</span> <span>Comparator</span><span>.</span><span>comparingInt</span><span>(</span>a <span>-></span> a<span>)</span><span>)</span><span>;</span>
        <span>// Java 里没有 heapify ，因此我们逐个将前 k 个元素添加到 minHeap 里</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> k<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            minHeap<span>.</span><span>offer</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> k<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 看一眼，不拿出，因为有可能没有必要替换</span>
            <span>Integer</span> topElement <span>=</span> minHeap<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
            <span>// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>></span> topElement<span>)</span> <span>{</span>
                <span>// Java 没有 replace()，所以得先 poll() 出来，然后再放回去</span>
                minHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                minHeap<span>.</span><span>offer</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> minHeap<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.07153em;">K</span><span>)</span></span></span></span>，遍历数据 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，堆内元素调整 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.07153em;">K</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.07153em;">K</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="优先队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:05.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 451 题：根据字符出现频率排序（中等）</title>
    <id>https://suanfa8.com/heap/solutions/0451-sort-characters-by-frequency/</id>
    <link href="https://suanfa8.com/heap/solutions/0451-sort-characters-by-frequency/"/>
    <updated>2022-01-12T23:38:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener noreferrer">451. 根据字符出现频率排序<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入:
&quot;tree&quot;

输出:
&quot;eert&quot;

解释:
&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。
因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入:
&quot;cccaaa&quot;

输出:
&quot;cccaaa&quot;


解释:
&#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。
注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>示例 3:</strong></p>
<div><pre><code>输入:
&quot;Aabb&quot;

输出:
&quot;bbAa&quot;

解释:
此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。
注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 5 * 10^5</code></li>
<li><code>s</code> consists of uppercase and lowercase English letters and digits.</li>
</ul>
<h2 id="方法一-排序-哈希表"> 方法一：排序 + 哈希表</h2>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Comparator</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashMap</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Map</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>String</span> <span>frequencySort</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> s<span>;</span>
        <span>}</span>
        <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Character</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            map<span>.</span><span>put</span><span>(</span>c<span>,</span> map<span>.</span><span>get</span><span>(</span>c<span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>1</span> <span>:</span> map<span>.</span><span>get</span><span>(</span>c<span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>Comparator</span><span><span>&lt;</span><span>Character</span><span>></span></span> comparator <span>=</span> <span>(</span>o1<span>,</span> o2<span>)</span> <span>-></span> <span>{</span>
            <span>if</span> <span>(</span>map<span>.</span><span>get</span><span>(</span>o2<span>)</span> <span>-</span> map<span>.</span><span>get</span><span>(</span>o1<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                <span>// 要注意：如果出现频次相同，要按字母顺序排序， "loveleetcode" 就是一个很好的测试用例</span>
                <span>return</span> o1<span>.</span><span>compareTo</span><span>(</span>o2<span>)</span><span>;</span>
            <span>}</span>
            <span>// 注意顺序</span>
            <span>return</span> map<span>.</span><span>get</span><span>(</span>o2<span>)</span> <span>-</span> map<span>.</span><span>get</span><span>(</span>o1<span>)</span><span>;</span>
        <span>}</span><span>;</span>
        <span>Character</span><span>[</span><span>]</span> cArr <span>=</span> <span>new</span> <span>Character</span><span>[</span>len<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            cArr<span>[</span>i<span>]</span> <span>=</span> s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>cArr<span>,</span> comparator<span>)</span><span>;</span>

        <span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            stringBuilder<span>.</span><span>append</span><span>(</span>cArr<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> stringBuilder<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="方法二-优先队列"> 方法二：优先队列</h2>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>frequencySort</span><span>(</span>self<span>,</span> s<span>:</span> <span>str</span><span>)</span> <span>-</span><span>></span> <span>str</span><span>:</span>
        size <span>=</span> <span>len</span><span>(</span>s<span>)</span>
        <span>if</span> size <span>&lt;=</span> <span>1</span><span>:</span>
            <span>return</span> s

        <span>hash</span> <span>=</span> <span>dict</span><span>(</span><span>)</span>
        <span>for</span> alpha <span>in</span> s<span>:</span>
            <span>hash</span><span>[</span>alpha<span>]</span> <span>=</span> <span>hash</span><span>.</span>setdefault<span>(</span>alpha<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>

        <span>import</span> heapq
        h <span>=</span> <span>[</span><span>]</span>
        <span>for</span> alpha<span>,</span> counter <span>in</span> <span>hash</span><span>.</span>items<span>(</span><span>)</span><span>:</span>
            heapq<span>.</span>heappush<span>(</span>h<span>,</span> <span>(</span><span>-</span>counter<span>,</span> alpha<span>)</span><span>)</span>

        res <span>=</span> <span>''</span>
        hash_table_len <span>=</span> <span>len</span><span>(</span><span>hash</span><span>.</span>items<span>(</span><span>)</span><span>)</span>

        <span>for</span> _ <span>in</span> <span>range</span><span>(</span>hash_table_len<span>)</span><span>:</span>
            counter<span>,</span> alpha <span>=</span> heapq<span>.</span>heappop<span>(</span>h<span>)</span>
            res <span>+=</span> alpha <span>*</span> <span>(</span><span>-</span>counter<span>)</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>说明：Python 提供的 <code>heapq</code> 是最小堆。</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="优先队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:05.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1046 题：最后一块石头的重量（中等）</title>
    <id>https://suanfa8.com/heap/solutions/1046-last-stone-weight/</id>
    <link href="https://suanfa8.com/heap/solutions/1046-last-stone-weight/"/>
    <updated>2022-01-12T23:38:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener noreferrer">1046. 最后一块石头的重量<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/last-stone-weight/solution/shi-yong-you-xian-dui-lie-mo-ni-wen-ti-java-by-liw/" target="_blank" rel="noopener noreferrer">使用优先队列模拟问题（Java）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例：</strong></p>
<div><pre><code>输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>由于需要<strong>动态维护数据的有序性</strong>（支持增加、删除），这里使用优先队列是最合适的数据结构。知道了这一点以后，根据题目意思模拟就好了。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>PriorityQueue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>lastStoneWeight</span><span>(</span><span>int</span><span>[</span><span>]</span> stones<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> stones<span>.</span>length<span>;</span>
        <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> maxHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>len<span>,</span> <span>(</span>o1<span>,</span> o2<span>)</span> <span>-></span> <span>-</span>o1 <span>+</span> o2<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> stone <span>:</span> stones<span>)</span> <span>{</span>
            maxHeap<span>.</span><span>offer</span><span>(</span>stone<span>)</span><span>;</span>
        <span>}</span>

        <span>while</span> <span>(</span>maxHeap<span>.</span><span>size</span><span>(</span><span>)</span> <span>>=</span> <span>2</span><span>)</span> <span>{</span>
            <span>Integer</span> head1 <span>=</span> maxHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>Integer</span> head2 <span>=</span> maxHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>head1<span>.</span><span>equals</span><span>(</span>head2<span>)</span><span>)</span> <span>{</span>
                <span>continue</span><span>;</span>
            <span>}</span>
            maxHeap<span>.</span><span>offer</span><span>(</span>head1 <span>-</span> head2<span>)</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>maxHeap<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>
        <span>return</span> maxHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，（粗略计算，忽略常数倍数和常数项）每个元素入队一次，出队和入队调整堆的复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，优先队列的大小。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="优先队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:05.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1296 题：划分数组为连续数字的集合（中等）</title>
    <id>https://suanfa8.com/heap/solutions/1296-divide-array-in-sets-of-k-consecutive-numbers/</id>
    <link href="https://suanfa8.com/heap/solutions/1296-divide-array-in-sets-of-k-consecutive-numbers/"/>
    <updated>2022-01-12T23:38:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/" target="_blank" rel="noopener noreferrer">1296. 划分数组为连续数字的集合<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/solution/you-xian-dui-lie-by-liweiwei1419-2/" target="_blank" rel="noopener noreferrer">优先队列（适合 Java 代码，C++ 和 Python 不支持 remove 操作，故不适用）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，请你判断是否可以把这个数组划分成一些由 <code>k</code> 个连续数字组成的集合。</p>
<p>如果可以，请返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span><span>,</span> k <span>=</span> <span>4</span>
输出：<span>true</span>
解释：数组可以分成 <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span> 和 <span>[</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
输出：true
解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [3,3,2,2,1,1], k = 3
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：nums = [1,2,3,4], k = 3
输出：false
解释：数组不能分成几个大小为 3 的子数组。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.136em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>**注意：**此题目与 846 重复：https://leetcode-cn.com/problems/hand-of-straights/</p>
<hr>
<p>说明：我这种写法 C++ 和 Python 的优先队列因为不支持 <code>remove</code> 操作（<code>remove</code> 操作是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span> 复杂度），因此需要考虑使用二分搜索树 + 计数方法去做，具体方法请参考 <a href="/u/happy_yuxuan/">@Victor</a> 写的 <a href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/solution/weeklycontest168-q2-hua-fen-shu-zu-wei-lian-xu-shu/" target="_blank" rel="noopener noreferrer">[WeeklyContest]168 Q2 划分数组为连续数字的集合<i>Content not supported</i></a>。</p>
<p>首先，很容易判断，如果数组的长度不是 <code>k</code> 的倍数，一定不会有符合题意的集合。</p>
<p>其次，注意到这 <code>k</code> 个数一定是连续的数，因此，如果存在符合题意，任意拿出一个集合，如果这个集合里最小的数是 <code>i</code> ，那么集合里剩下的数依次是 <code>i + 1, i + 2, ..., i + (k - 1)</code> 。</p>
<p>为此，需要一个数据结构，能够帮助我们动态删除元素。</p>
<p>一开始想到使用哈希表。因为还需要有序性，因此用二分搜索树或者优先队列都是可以的。但如果使用二分搜索树，相同元素放入集合里就会被认为只有一个，因此<strong>优先队列</strong>是最合适的数据结构。</p>
<p>先把数组中所有的数放入优先队列（最小堆）中。</p>
<ul>
<li>每次从队首<strong>出队</strong>一个数 <code>i</code>，就需要依次从堆中再移除 <code>i + 1, i + 2, ..., i + (k - 1)</code> ，只要移除失败，就可以直接返回 <code>false</code>；</li>
<li>如果每次都能移除成功，最后优先队列就会为空，直接返回 <code>true</code> 即可。</li>
</ul>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>PriorityQueue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>isPossibleDivide</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>%</span> k <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> minHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>len<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            minHeap<span>.</span><span>offer</span><span>(</span>num<span>)</span><span>;</span>
        <span>}</span>

        <span>while</span> <span>(</span><span>!</span>minHeap<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Integer</span> top <span>=</span> minHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>

            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> k<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>// 从 1 开始，正好需要移除 k - 1 个元素</span>
                <span>// i 正好就是相对于 top 的偏移</span>
                <span>// 注意：这个 remove 操作会线性去扫 top + i 的索引，时间复杂度是 O(N)</span>
                <span>if</span> <span>(</span><span>!</span>minHeap<span>.</span><span>remove</span><span>(</span>top <span>+</span> i<span>)</span><span>)</span> <span>{</span>
                    <span>// 如果移除失败，说明划分不存在，直接返回 false 即可</span>
                    <span>return</span> <span>false</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>
<p>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span style="margin-right:0.10903em;">N</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度，如果是 <code>heapify</code> 建堆，时间复杂度可以达到 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span> ，只不过 Java 的优先队列不支持 <code>heapify</code>。（这里感谢 <a href="/u/happy_yuxuan/">@Victor</a> 指出我原来的错误）。另外 <code>remove</code> 操作是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span> 复杂度，因此总的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span><span style="margin-right:0.10903em;">N</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span>；</p>
</li>
<li>
<p>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，优先队列的长度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span>。</p>
</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="优先队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:07:05.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">线段树北美讲题大纲</title>
    <id>https://suanfa8.com/data-structure-advance/segment-tree/intro/</id>
    <link href="https://suanfa8.com/data-structure-advance/segment-tree/intro/"/>
    <updated>2022-01-13T20:06:40.000Z</updated>
    <content type="html"><![CDATA[<p>北美讲题大纲</p>
<h2 id="线段树入门"> 线段树入门</h2>
<p>时间：2020 年 6 月 6 日</p>
<ul>
<li>只介绍「线段树」基础知识，不做深入讨论；</li>
<li>参考资料：liuyubobobo 老师的 GitHub <a href="https://github.com/liuyubobobo/Play-with-Data-Structures/tree/master/09-Segment-Tree" target="_blank" rel="noopener noreferrer">《玩转数据结构》代码仓库<i>Content not supported</i></a>。</li>
</ul>
<p>为什么介绍线段树？谷歌公司要考，它思想简单，代码实现有一点复杂。</p>
<hr>
<h2 id="_1-前置知识-前缀和数组"> 1. 前置知识：前缀和数组</h2>
<ul>
<li><code>preSum[i]</code> 表示 <code>nums[0..i]</code> 里全部元素的和（一个数代表了原始数组的一个前缀区间的和）；</li>
<li>前缀和数组，就是一堆前缀和，可以用于：<strong>快速计算区间和</strong>（查询区间和 O(1)O(1)O(1)）；</li>
<li>区间 <code>[i..j]</code> 的和： <code>preSum[j] - preSum[i - 1]</code>。</li>
</ul>
<hr>
<p>Java 代码：</p>
<div><pre><code>int len = nums.length;
// 计算前缀和数组
int[] preSum = new int[len + 1];
preSum[0] = 0;

for (int i = 0; i &lt; len; i++) {
  preSum[i + 1] = preSum[i] + nums[i];
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li><strong>缺点：前缀和数组，在有更新需求的前提下，不能高效地工作。</strong></li>
</ul>
<hr>
<h2 id="_2-线段树"> 2. 线段树</h2>
<h3 id="_2-1-线段树的用途"> 2.1 线段树的用途</h3>
<p>线段树只回答了以下两个问题，不回答区间里有「删除」和「添加」操作的场景。</p>
<ul>
<li>区间和查询</li>
<li>单点（区间）更新</li>
</ul>
<hr>
<h3 id="_2-2-前缀和数组与线段树都是原始数组的预处理数组"> 2.2 前缀和数组与线段树都是原始数组的预处理数组</h3>
<ul>
<li>有了前缀和数组，就可以把原始数组丢弃了；</li>
<li>有了线段树（数组），也可以把原始数组丢弃了。</li>
</ul>
<p>可以认为都是对原始数组的预处理数组，把一些需要用到的值提前计算出来，思想：空间换时间。</p>
<hr>
<h3 id="_2-3-如何构建线段树、如何实现区间查询、如何实现区间更新"> 2.3 如何构建线段树、如何实现区间查询、如何实现区间更新</h3>
<hr>
<h3 id="_2-4-线段树总结-与已有知识的联系"> 2.4 线段树总结（与已有知识的联系）</h3>
<ul>
<li>线段树一定是二叉树，是平衡二叉树，最后一层不满；</li>
<li>线段树不是完全二叉树、更不是满二叉树；</li>
<li><strong>树可以建立在数组上</strong>：① 并查集； ② 堆 （完全二叉树、满二叉树）；</li>
<li>后序遍历构建二叉树；</li>
<li>递归、分治、深度优先遍历；</li>
<li>前缀和预处理的思路是：线性结构；线段树预处理的思路是：树结构。</li>
</ul>
<hr>
<h3 id="_2-5-练习"> 2.5 练习</h3>
<ul>
<li>「力扣」第 307 题： <a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener noreferrer">区域和检索 - 数组可修改<i>Content not supported</i></a>；</li>
<li>其它「力扣」上标签为「线段树」（segment-tree）的问题。</li>
</ul>
<hr>
<h3 id="_2-6-扩展"> 2.6 扩展</h3>
<ul>
<li>区间更新：懒加载策略；</li>
<li>树状数组（回答前缀和、单点（区间）更新）</li>
<li>线段树 &gt;= 树状数组（binary-indexed-tree）</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="线段树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:04:30.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 41 题：缺失的第一个正数（困难）</title>
    <id>https://suanfa8.com/hash-table/solutions/0041-first-missing-positive/</id>
    <link href="https://suanfa8.com/hash-table/solutions/0041-first-missing-positive/"/>
    <updated>2022-01-13T16:02:10.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener noreferrer">41. 缺失的第一个正数（困难）<i>Content not supported</i></a> ；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">原地哈希（哈希函数为：f(nums[i]) = nums[i] - 1）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="视频题解"> 📺 视频题解</h2>
<p>视频讲解：<a href="https://www.bilibili.com/video/BV167411N7vd" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a>。</p>
<p>说明：</p>
<ul>
<li><strong>建议倍速观看</strong>，核心思想不难，三分钟以后才进入正题，为了叙述完整所以讲得比较多；</li>
<li>方法一和方法二都很容易想到，可以直接跳到「方法三」。</li>
</ul>
<div><p>视频讲解</p>
<p>📺 这道题在 <a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">题解<i>Content not supported</i></a> 和 <a href="https://www.bilibili.com/video/BV167411N7vd" target="_blank" rel="noopener noreferrer">B 站<i>Content not supported</i></a> 可以收看视频讲解，可以点击下面的视频右上角「去 bilibili 观看」，选择快速播放，获得更好的观看体验。</p>
</div>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=92262117&bvid=BV167411N7vd&cid=157532455&page=1" frameborder="no" scrolling="no"></iframe>
</div>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [1,2,0]
输出：3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [3,4,-1,1]
输出：2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [7,8,9,11,12]
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>5</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
<h2 id="一句话题解"> 一句话题解</h2>
<p>本题的难点在：只能使用常数级别的额外空间，在这个限制下本题的思路有一个非正式的名称：原地哈希。</p>
<h2 id="方法一-哈希表-空间复杂度不符合要求"> 方法一：哈希表（空间复杂度不符合要求）</h2>
<ul>
<li>按照刚才我们读例子的思路，其实我们只需从最小的正整数 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 开始，依次判断 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span>、 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>3</span></span></span></span> 、<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>4</span></span></span></span> 直到数组的长度 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是否在数组中；</li>
<li>如果当前考虑的数不在这个数组中，我们就找到了这个缺失的最小正整数；</li>
<li>由于我们需要依次判断某一个正整数是否在这个数组里，我们可以先把这个数组中所有的元素放进哈希表。接下来再遍历的时候，就可以以 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span> 的时间复杂度判断某个正整数是否在这个数组；</li>
<li>由于题目要求我们<strong>只能使用常数级别的空间</strong>，而哈希表的大小与数组的长度是线性相关的，因此空间复杂度不符合题目要求。</li>
</ul>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Set</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>firstMissingPositive</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> hashSet <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            hashSet<span>.</span><span>add</span><span>(</span>num<span>)</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> len <span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>!</span>hashSet<span>.</span><span>contains</span><span>(</span>i<span>)</span><span>)</span><span>{</span>
                <span>return</span> i<span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> len <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 表示数组的长度。第 1 次遍历了数组，第 2 次遍历了区间 <code>[1, len]</code> 里的元素。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，把 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 个数存在哈希表里面，使用了 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 个空间。</li>
</ul>
<h2 id="方法二-二分查找-时间复杂度不符合要求"> 方法二：二分查找（时间复杂度不符合要求）</h2>
<ul>
<li>根据刚才的分析，这个问题其实就是要我们查找一个元素，而查找一个元素，如果是在有序数组中查找，会快一些；</li>
<li>因此我们可以将数组先排序，再使用二分查找法从最小的正整数 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 开始查找，找不到就返回这个正整数；</li>
<li>这个思路需要先对数组排序，而排序使用的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，是不符合这个问题的时间复杂度要求。</li>
</ul>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>firstMissingPositive</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> res <span>=</span> <span>binarySearch</span><span>(</span>nums<span>,</span> i<span>)</span><span>;</span>
            <span>if</span> <span>(</span>res <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
                <span>return</span> i<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> len <span>+</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> left <span>=</span> <span>0</span><span>;</span>
        <span>int</span> right <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span>left <span>&lt;=</span> right<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> <span>(</span>left <span>+</span> right<span>)</span> <span>>>></span> <span>1</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>==</span> target<span>)</span> <span>{</span>
                <span>return</span> mid<span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 表示数组的长度。时间复杂度主要消耗在排序上，排序使用 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。二分查找使用每一步使用的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，整体上仍然是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</li>
</ul>
<p>说明：评论区 <a href="/u/pingfan108/">@pingfan108</a> 朋友给出了排序以后不用二分的做法，可以点击 <a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/463831/" target="_blank" rel="noopener noreferrer">这里<i>Content not supported</i></a> 查看，特此表示感谢。</p>
<h2 id="方法三-将数组视为哈希表"> 方法三：将数组视为哈希表</h2>
<p>最早知道这个思路是在《剑指 Offe》这本书上看到的，感兴趣的朋友不妨做一下这道问题：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 03. 数组中重复的数字<i>Content not supported</i></a>。下面简要叙述：</p>
<ul>
<li>由于题目要求我们「<strong>只能使用常数级别的空间</strong>」，而要找的数一定在 <code>[1, N + 1]</code> 左闭右闭（这里 <code>N</code> 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，<strong>哈希表其实本身也是一个数组</strong>；</li>
<li>我们要找的数就在 <code>[1, N + 1]</code> 里，最后 <code>N + 1</code> 这个元素我们不用找。因为在前面的 <code>N</code> 个元素都找不到的情况下，我们才返回 <code>N + 1</code>；</li>
<li>那么，我们可以采取这样的思路：就把 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 这个数放到下标为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的位置， <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 这个数放到下标为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</li>
<li>这个思想就相当于<strong>我们自己编写哈希函数</strong>，这个哈希函数的规则特别简单，那就是数值为 <code>i</code> 的数映射到下标为 <code>i - 1</code> 的位置。</li>
</ul>
<p>我们来看一下这个算法是如何应用在示例 2 上的。</p>
<p><img src="https://pic.leetcode-cn.com/1e4f3f1c9a6fb37c2aa515069508f5f3ef9d72cc55b586790f9bec9705052d17-0041-14.png" alt="0041-14.png" loading="lazy"></p>
<p>动画演示：</p>
<Presentation id="presentation-64a56960" data-code="%0A!%5B0041-5.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F936d814a9b139dd1786b4be78efd79ea02b5607389245d0acfdb261b1a29883a-0041-5.png)%0A%0A---%0A%0A!%5B0041-6.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Feaf8ed6ccdb63847242aedb2250a6c5758bbbbe3daa2429773490171aa51ab19-0041-6.png)%0A%0A---%0A%0A!%5B0041-7.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fa5f21de4c627ff5c96bab5ec6c1b90b5ed766db9e22bee8442334e978771adb4-0041-7.png)%0A%0A---%0A%0A!%5B0041-8.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F29d2ddba41a56529ad69e24c856c40b1d152d66617ea584fef15f796fd66895b-0041-8.png)%0A%0A---%0A%0A!%5B0041-9.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fa713946cca9f30a898d6184019cdd5654170cabd75aa629fa064e1437c9187c9-0041-9.png)%0A%0A---%0A%0A!%5B0041-10.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fa33b4b19891f2fcb90267acc355e37b32247ec9b21699d42496349e242c4d7db-0041-10.png)%0A%0A---%0A%0A!%5B0041-11.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fdddeb078e879354a6dd10c67f4b1ff0aca29c381f472b16bca829313ea194b3d-0041-11.png)%0A%0A---%0A%0A!%5B0041-12.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F0719d21c21ffcb0a702783830ace526e7798afa7a36058747a7f44f3bf0e41cf-0041-12.png)%0A" theme="auto"></Presentation><p><strong>参考代码 3</strong>：</p>
<p><strong>注意</strong>：理解下面代码 <code>nums[nums[i] - 1] != nums[i]</code> 的作用。</p>
<p>这里感谢用户 <a href="/u/rmokerone/">@rmokerone</a> 提供 C++ 版本的代码。</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>firstMissingPositive</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>></span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>&lt;=</span> len <span>&amp;&amp;</span> nums<span>[</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>]</span> <span>!=</span> nums<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                <span>// 满足在指定范围内、并且没有放在正确的位置上，才交换</span>
                <span>// 例如：数值 3 应该放在索引 2 的位置上</span>
                <span>swap</span><span>(</span>nums<span>,</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>,</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>// [1, -1, 3, 4]</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span><span>)</span> <span>{</span>
                <span>return</span> i <span>+</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 都正确则返回数组长度 + 1</span>
        <span>return</span> len <span>+</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>from</span> typing <span>import</span> List


<span>class</span> <span>Solution</span><span>:</span>

    <span># 3 应该放在索引为 2 的地方</span>
    <span># 4 应该放在索引为 3 的地方</span>

    <span>def</span> <span>firstMissingPositive</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        size <span>=</span> <span>len</span><span>(</span>nums<span>)</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
            <span># 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方</span>
            <span>while</span> <span>1</span> <span>&lt;=</span> nums<span>[</span>i<span>]</span> <span>&lt;=</span> size <span>and</span> nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>]</span><span>:</span>
                self<span>.</span>__swap<span>(</span>nums<span>,</span> i<span>,</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>)</span>

        <span>for</span> i <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
            <span>if</span> i <span>+</span> <span>1</span> <span>!=</span> nums<span>[</span>i<span>]</span><span>:</span>
                <span>return</span> i <span>+</span> <span>1</span>

        <span>return</span> size <span>+</span> <span>1</span>

    <span>def</span> <span>__swap</span><span>(</span>self<span>,</span> nums<span>,</span> index1<span>,</span> index2<span>)</span><span>:</span>
        nums<span>[</span>index1<span>]</span><span>,</span> nums<span>[</span>index2<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>,</span> nums<span>[</span>index1<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p>说明：Python 里可以这样写 <code>nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]</code> ，但是这里赋值有先后顺序，写成 <code>nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i],</code> 就会出错。建议封装成单独的函数，避免出错。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度。</li>
</ul>
<p>说明：<code>while</code> 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。</p>
<p>最极端的一种情况是，在第 1 个位置经过这个 <code>while</code> 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 <code>for</code> 循环后面的部分的 <code>while</code> 的循环体都不会被执行。</p>
<p>平均下来，每个数只需要看一次就可以了，<code>while</code> 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析</strong>。</p>
<p>最后再遍历了一次数组，最坏情况下要把数组里的所有的数都看一遍，因此时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。</p>
<ul>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</li>
</ul>
<h2 id="同类问题"> 同类问题</h2>
<table>
<thead>
<tr>
<th>问题</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener noreferrer">442. 数组中重复的数据<i>Content not supported</i></a></td>
<td><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/solution/chou-ti-yuan-li-ji-yu-yi-huo-yun-suan-jiao-huan-li/" target="_blank" rel="noopener noreferrer">题解<i>Content not supported</i></a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener noreferrer">448. 找到所有数组中消失的数字<i>Content not supported</i></a></td>
<td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/tong-pai-xu-ji-yu-yi-huo-yun-suan-jiao-huan-liang-/" target="_blank" rel="noopener noreferrer">题解<i>Content not supported</i></a></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="原地哈希" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:04:14.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 50 题：Pow(x, n)</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0050-powx-n/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0050-powx-n/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener noreferrer">50. Pow(x, n)<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/powx-n/solution/ba-zhi-shu-bu-fen-kan-zuo-er-jin-zhi-shu-python-da/" target="_blank" rel="noopener noreferrer">自顶向下（递归）与自顶向上（递推）<i>Content not supported</i></a>。</li>
</ul>
<p>今天要和大家分享的是「力扣」第 50 题：Pow(x, n)。这题有一个名称叫「快速幂」，我们这里只分享「递归」和「非递归」的写法，其中 <strong>「递归」对应「当指数为奇数时，把指数分解成偶数 + 1，当指数为偶数时，把指数除以 2」，「非递归」对应把指数转化成二进制</strong>。「快速幂」还有矩阵的求法，感兴趣的朋友可以在网络上自行搜索（我也不会）。</p>
<h2 id="题目描述"> 题目描述</h2>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：x = 2.00000, n = 10
输出：1024.00000
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：x = 2.10000, n = 3
输出：9.26100
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>−</span><span>100.0</span><span style="margin-right:0.2778em;"></span><span>&lt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.5782em;vertical-align:-0.0391em;"></span><span>x</span><span style="margin-right:0.2778em;"></span><span>&lt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>100.0</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>n</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8004em;vertical-align:-0.136em;"></span><span><span>x</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span>​</li>
</ul>
<h2 id="把指数部分看做二进制数-python-代码"> 把指数部分看做二进制数（Python 代码）</h2>
<p>当指数为负数的时候，可以转化为底数取导数，指数取相反数的情况，这一点并不难理解。</p>
<p>为了避免一次又一次将底数相乘，我们采用这样“偷懒”的策略，比如要计算 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>5</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>18</span></span></span></span></span></span></span></span></span></span></span></span>，其实我们只要算出 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>5</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span>，然后再自己乘自己就好了，这样就可以避免做 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>9</span></span></span></span> 次“<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>×</span><span>5</span></span></span></span>” 的运算。（这种思想有点像“记忆化递归”。）</p>
<p>那么有一种机制就能帮助我们找到一个整数的合适的“分解”，那么就是将一个整数看成它的二进制形式。就那上面的例子来说，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>18</span></span></span></span> 的二进制表示为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>10010</span><span><span>)</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即：</p>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>18</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.9474em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8641em;"></span><span><span>2</span><span><span><span><span style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>那么：</p>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8641em;"></span><span><span>5</span><span><span><span><span style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>18</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1.1202em;vertical-align:-0.0833em;"></span><span><span>5</span><span><span><span><span style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span><span>2</span><span><span><span><span style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span style="height:2.5em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.0369em;"></span><span><span>5</span><span><span><span><span style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span><span>2</span><span><span><span><span style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span style="height:2.5em;"></span><span><span>1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>于是，我们可以把指数 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>n</span></span></span></span> 做“二进制分解”，<strong>在底数不断自身乘以自身的过程中，将最终结果需要的部分保存下来</strong>。</p>
<p><img src="https://pic.leetcode-cn.com/ab780b00a05f762c87ae4c68e74ef8d3a8b961a98762c02b61585d8f8c61747c-image.png" alt="image.png" loading="lazy"></p>
<p>写得比较晦涩，相信聪明的你看我写的代码一定能看懂。</p>
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>myPow</span><span>(</span>self<span>,</span> x<span>:</span> <span>float</span><span>,</span> n<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>float</span><span>:</span>

        <span>if</span> n <span>&lt;</span> <span>0</span><span>:</span>
            x <span>=</span> <span>1</span> <span>/</span> x
            n <span>=</span> <span>-</span>n

        res <span>=</span> <span>1</span>
        <span>while</span> n<span>:</span>
            <span>if</span> n <span>&amp;</span> <span>1</span><span>:</span>
                res <span>*=</span> x
            x <span>*=</span> x
            n <span>>></span><span>=</span> <span>1</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 52 题：N-Queens II（困难）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0052-n-queens-ii/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0052-n-queens-ii/"/>
    <updated>2022-08-08T06:57:46.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/n-queens-ii/description/" target="_blank" rel="noopener noreferrer">52. N 皇后 II<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/n-queens-ii/solution/gen-ju-di-46-ti-quan-pai-lie-de-hui-su-suan-fa-s-2/" target="_blank" rel="noopener noreferrer">根据第 46 题“全排列”的“回溯算法”思路使用位图作为状态<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tp9xllpkj20k208ydga.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：n = 4
输出：2
解释：如上图所示，4 皇后问题存在两个不同的解法。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：n = 1
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 9</code></li>
</ul>
<h2 id="方法一-根据第-46-题-全排列-的-回溯算法-思路使用位图作为状态"> 方法一：根据第 46 题“全排列”的“回溯算法”思路使用位图作为状态</h2>
<p><strong>思路分析</strong>：</p>
<p>本思路是基于根据我为 <a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener noreferrer">「力扣」第 51 题：“N 皇后”<i>Content not supported</i></a> 编写的题解 <a href="https://leetcode-cn.com/problems/n-queens/solution/gen-ju-di-46-ti-quan-pai-lie-de-hui-su-suan-fa-si-/" target="_blank" rel="noopener noreferrer">《根据第 46 题“全排列”的“回溯算法”思路编写“N 皇后”问题（Java）》<i>Content not supported</i></a> ，该题解详细介绍了本思路的由来。如果没有看过的朋友建议看一下。</p>
<p>因为不需要生成棋盘，即不需要得到具体的 <code>[1, 2, ..., n]</code> 的一个全排列，因此我们可以舍去数组 <code>nums</code> 的生成，只使用行、主对角线、副对角线三个辅助变量完成 N 皇后问题所有可能性的计算。</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>int</span> <span>totalNQueens</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>int</span> col <span>=</span> <span>0</span><span>;</span>
        <span>int</span> master <span>=</span> <span>0</span><span>;</span>
        <span>int</span> slave <span>=</span> <span>0</span><span>;</span>

        <span>backtrack</span><span>(</span><span>0</span><span>,</span> n<span>,</span> col<span>,</span> master<span>,</span> slave<span>)</span><span>;</span>
        <span>return</span> <span>this</span><span>.</span>count<span>;</span>
    <span>}</span>


    <span>private</span> <span>void</span> <span>backtrack</span><span>(</span><span>int</span> row<span>,</span> <span>int</span> n<span>,</span>
                           <span>int</span> col<span>,</span>
                           <span>int</span> master<span>,</span>
                           <span>int</span> slave<span>)</span> <span>{</span>

        <span>if</span> <span>(</span>row <span>==</span> n<span>)</span> <span>{</span>
            <span>this</span><span>.</span>count<span>++</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>// 针对每一列，尝试是否可以放置</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span><span>(</span>col <span>>></span> i<span>)</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span>
                    <span>&amp;&amp;</span> <span>(</span><span>(</span>master <span>>></span> <span>(</span>row <span>+</span> i<span>)</span><span>)</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span>
                    <span>&amp;&amp;</span> <span>(</span><span>(</span>slave <span>>></span> <span>(</span>row <span>-</span> i <span>+</span> n <span>-</span> <span>1</span><span>)</span><span>)</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                col <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span><span>;</span>
                master <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>+</span> i<span>)</span><span>)</span><span>;</span>
                slave <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>-</span> i <span>+</span> n <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>

                <span>backtrack</span><span>(</span>row <span>+</span> <span>1</span><span>,</span> n<span>,</span> col<span>,</span> master<span>,</span> slave<span>)</span><span>;</span>

                slave <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>-</span> i <span>+</span> n <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
                master <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>+</span> i<span>)</span><span>)</span><span>;</span>
                col <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    count <span>=</span> <span>0</span>

    <span>def</span> <span>totalNQueens</span><span>(</span>self<span>,</span> n<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>if</span> n <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>0</span>

        col <span>=</span> <span>0</span>
        master <span>=</span> <span>0</span>
        slave <span>=</span> <span>0</span>

        self<span>.</span>__backtrack<span>(</span><span>0</span><span>,</span> n<span>,</span> col<span>,</span> master<span>,</span> slave<span>)</span>
        <span>return</span> self<span>.</span>count

    <span>def</span> <span>__backtrack</span><span>(</span>self<span>,</span> row<span>,</span> n<span>,</span> col<span>,</span> master<span>,</span> slave<span>)</span><span>:</span>
        <span>if</span> row <span>==</span> n<span>:</span>
            self<span>.</span>count <span>+=</span> <span>1</span>
            <span>return</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>n<span>)</span><span>:</span>
            <span>if</span> <span>(</span><span>(</span>col <span>>></span> i<span>)</span> <span>&amp;</span> <span>1</span> <span>==</span> <span>0</span><span>)</span> \
                    <span>and</span> <span>(</span><span>(</span>master <span>>></span> <span>(</span>row <span>+</span> i<span>)</span><span>)</span> <span>&amp;</span> <span>1</span> <span>==</span> <span>0</span><span>)</span> \
                    <span>and</span> <span>(</span><span>(</span>slave <span>>></span> <span>(</span>row <span>-</span> i <span>+</span> n <span>-</span> <span>1</span><span>)</span><span>)</span> <span>&amp;</span> <span>1</span> <span>==</span> <span>0</span><span>)</span><span>:</span>
                col <span>^</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span>
                master <span>^</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>+</span> i<span>)</span><span>)</span>
                slave <span>^</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>-</span> i <span>+</span> n <span>-</span> <span>1</span><span>)</span><span>)</span>
                self<span>.</span>__backtrack<span>(</span>row <span>+</span> <span>1</span><span>,</span> n<span>,</span> col<span>,</span> master<span>,</span> slave<span>)</span>
                slave <span>^</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>-</span> i <span>+</span> n <span>-</span> <span>1</span><span>)</span><span>)</span>
                master <span>^</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span>row <span>+</span> i<span>)</span><span>)</span>
                col <span>^</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>下面介绍一种我在网络上搜索到的方法（反正我是想不到的），该方法可以说把位图的性质应用得非常透彻了。</p>
<h2 id="方法二-不回溯-并且充分利用二进制位图的思想和二进制技巧"> 方法二：“不回溯”并且充分利用二进制位图的思想和二进制技巧</h2>
<p>我们想一下，方法一还有哪些地方可以快一点？</p>
<ul>
<li>回溯：因为我们并不关心具体棋盘的生成，所以其实“回溯”是没有必要的，只要递归能走到第 n 层，就表示搜索到一个棋盘；</li>
<li>在 <code>for</code> 循环中一个位置一个位置遍历探测可以放置的位置太慢了，既然我们用到二进制位图，有 <a href="https://leetcode-cn.com/problems/number-of-1-bits" target="_blank" rel="noopener noreferrer">「力扣」第 191 题：“位 1 的个数”<i>Content not supported</i></a> 的经验，即使用 <code>n &amp; (n - 1)</code> 可以很快消去一个数的二进制表示的最低位的那个 1，类似的技巧就可以应用在这一题；具体请看我在参考代码 2 中的注释。</li>
</ul>
<p><strong>参考代码 2</strong>：</p>
<p>注意 1：下面的写法中国 <code>master</code>、<code>slave</code> 的二进制表示中为 <code>1</code> 的数位表示“从左向右”的数的这个位置已经有“皇后”占位了。因此我们 只需要它们的低 n 位即可，不要和方法 1 的 <code>2 * n -1</code> 混淆，它们的意义不一样。</p>
<p>注意 2：二进制数数位是“从右向左”，而我们数组的数位是“从左向右”，明确这一点，就能比较好地理解 <code>(master | p) &lt;&lt; 1</code> 这个操作；</p>
<p>注意 3：<code>n &amp; (-n)</code> 保留了一个数的二进制表示最低位的 1 和它右边的所有的 0，这一点可以在纸上举例理解；</p>
<p>注意 4：“状态”重置在这个方法里是“隐式”的，因为基本数值变量在方法传递的时候是“值传递”，因此传递到下一层都是“复制”，每一个方法的“状态”变量可以认为都是新的，因此没有必要“重置”；</p>
<p>注意 5：如果参考代码 2 当中还有没有解释清楚的地方，可以看下面这张图理解。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpa0unjmj20gs0c2jry.jpg" alt="image.png" loading="lazy">{:width=300}
{:align=center}</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>int</span> <span>totalNQueens</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>int</span> col <span>=</span> <span>0</span><span>;</span>
        <span>int</span> master <span>=</span> <span>0</span><span>;</span>
        <span>int</span> slave <span>=</span> <span>0</span><span>;</span>

        <span>backtrack</span><span>(</span><span>0</span><span>,</span> n<span>,</span> col<span>,</span> master<span>,</span> slave<span>)</span><span>;</span>
        <span>return</span> <span>this</span><span>.</span>count<span>;</span>
    <span>}</span>


    <span>private</span> <span>void</span> <span>backtrack</span><span>(</span><span>int</span> row<span>,</span> <span>int</span> n<span>,</span>
                           <span>int</span> col<span>,</span>
                           <span>int</span> master<span>,</span>
                           <span>int</span> slave<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>row <span>==</span> n<span>)</span> <span>{</span>
            <span>// 已经排出了 n 个数，结算</span>
            <span>this</span><span>.</span>count<span>++</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>// 第 1 步：col | master | slave，将列、主对角线、副对角线上的已经放置的元素做一次合并</span>
        <span>// 很可能 col、master、slave 三个位置都被占（如上图），这不要紧，我们只关心没有被占的位置</span>
        <span>// 第 2 步：我们关心的是 0，但是探测 1 容易，因此，让 0 变 1 ， 1 变 0</span>
        <span>// 由此带来一个问题，高位 0 全变成 1 了，因此引入第 3 步</span>
        <span>// 第 3 步：&amp; (1 &lt;&lt; n) - 1) 是只取低 n 位，1 &lt;&lt; n 表示第 n + 1 位是 1 ，低 n 位全是 0</span>
        <span>// 这里 mask 中 1 表示可以放置的位置，0 表示不能放置的位置</span>
        <span>int</span> mask <span>=</span> <span>(</span><span>~</span><span>(</span>col <span>|</span> master <span>|</span> slave<span>)</span> <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> n<span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>mask <span>></span> <span>0</span><span>)</span> <span>{</span> <span>// 只有有位置为 1 ，表示至少有 1 个元素可以放置</span>
            <span>// 找到从低位到高位（从右向左）第 1 个二进制位为 1 的数</span>
            <span>// 这个操作保留了 1 和后面的 0</span>
            <span>int</span> p <span>=</span> mask <span>&amp;</span> <span>(</span><span>-</span>mask<span>)</span><span>;</span>

            <span>// col | p 表示占住这一列</span>
            <span>// (master | p) &lt;&lt; 1 表示下一行右边的那个位置（主对角线方向）被占，</span>
            <span>// 因为位运算占位的操作是从右边向左边，因此需要左移</span>
            <span>// 同理理解 (slave | p) >> 1)</span>

            <span>// 注意：该方法是隐式回溯，基本数值类型在方法传递的时候是值传递，相当于完成了状态重置</span>
            <span>backtrack</span><span>(</span>row <span>+</span> <span>1</span><span>,</span> n<span>,</span> col <span>|</span> p<span>,</span> <span>(</span>master <span>|</span> p<span>)</span> <span>&lt;&lt;</span> <span>1</span><span>,</span> <span>(</span>slave <span>|</span> p<span>)</span> <span>>></span> <span>1</span><span>)</span><span>;</span>

            <span>// 把低位的第 1 个 1 变成 0 ，让下一层循环探测下一个 1</span>
            mask <span>&amp;=</span> <span>(</span>mask <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><hr>
<p><strong>参考代码</strong>：</p>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Stack</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>boolean</span><span>[</span><span>]</span> marked<span>;</span>
    <span>private</span> <span>int</span> count<span>;</span>

    <span>public</span> <span>int</span> <span>totalNQueens</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span> <span>||</span> n <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> n<span>;</span>
        <span>}</span>
        <span>int</span><span>[</span><span>]</span> board <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            board<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
        <span>permuta</span><span>(</span>board<span>)</span><span>;</span>
        <span>return</span> count<span>;</span>
    <span>}</span>

    <span>// 生成一个 [0,1,...,n-1] 的全排列</span>
    <span>private</span> <span>void</span> <span>permuta</span><span>(</span><span>int</span><span>[</span><span>]</span> board<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> board<span>.</span>length<span>;</span>
        marked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>len<span>]</span><span>;</span>
        <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> pre <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>findPermutation</span><span>(</span>board<span>,</span> <span>0</span><span>,</span> len<span>,</span> pre<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>findPermutation</span><span>(</span><span>int</span><span>[</span><span>]</span> board<span>,</span> <span>int</span> usedCount<span>,</span> <span>int</span> len<span>,</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> pre<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>usedCount <span>==</span> len<span>)</span> <span>{</span>
            <span>// 判断是否是符合要求的棋盘布局</span>
            <span>if</span> <span>(</span><span>noDanger</span><span>(</span>pre<span>,</span> len<span>)</span><span>)</span> <span>{</span>
                count<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>!</span>marked<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                marked<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
                pre<span>.</span><span>push</span><span>(</span>board<span>[</span>i<span>]</span><span>)</span><span>;</span>
                <span>findPermutation</span><span>(</span>board<span>,</span> usedCount <span>+</span> <span>1</span><span>,</span> len<span>,</span> pre<span>)</span><span>;</span>
                marked<span>[</span>i<span>]</span> <span>=</span> <span>false</span><span>;</span>
                pre<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>

        <span>}</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>noDanger</span><span>(</span><span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> pre<span>,</span> <span>int</span> len<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> board <span>=</span> <span>new</span> <span>int</span><span>[</span>len<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            board<span>[</span>i<span>]</span> <span>=</span> pre<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> len<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>// 得到所有不同的 i j 的组合，是一个组合问题，按顺序来就行</span>
                <span>// System.out.println(i + "\t" + j);</span>
                <span>if</span> <span>(</span>i <span>-</span> j <span>==</span> board<span>[</span>i<span>]</span> <span>-</span> board<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                    <span>return</span> <span>false</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>i <span>-</span> j <span>==</span> <span>-</span><span>(</span>board<span>[</span>i<span>]</span> <span>-</span> board<span>[</span>j<span>]</span><span>)</span><span>)</span> <span>{</span>
                    <span>return</span> <span>false</span><span>;</span>
                <span>}</span>
            <span>}</span>

        <span>}</span>
        <span>// 走到这里表示通过检验</span>
        <span>// System.out.println(Arrays.toString(board));</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Solution</span> solution <span>=</span> <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> totalNQueens <span>=</span> solution<span>.</span><span>totalNQueens</span><span>(</span><span>8</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>totalNQueens<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 67 题：二进制求和（简单）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0067-add-binary/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0067-add-binary/"/>
    <updated>2022-08-08T06:57:46.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener noreferrer">67. 二进制求和<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/add-binary/solution/mo-shi-er-jin-zhi-shu-shi-jia-fa-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">模拟「二进制」竖式加法<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>每个字符串仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成。</li>
<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>
<li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>思路很简单，就是模拟一个「二进制」的竖式加法。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpa8b3a7j20km0awwep.jpg" alt="image.png" loading="lazy">{:width=400}
{:align=center}</p>
<p>我个人觉得这道题单纯是为了考察了我们对于所使用语言的字符串 API 的熟悉程度。写法不唯一，下面以 Java 为例编写参考代码。</p>
<p>在 Java 语言中，如果需要频繁地针对字符串进行操作，应该使用可变的字符序列对象 <code>StringBuilder</code>（这里有一个常见的面试问题：<code>StringBuilder</code> 与 <code>StringBuffer</code> 的区别），并且 <code>StringBuilder</code> 对象也为我们提供了一些好用的操作字符序列的方法（反转，删除、在某一个位置插入一个字符）。</p>
<p>编码中要注意的一点是：如果两个字符的长度不等，需要在短的那个字符串的<strong>左边</strong>补“0”。</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>String</span> <span>addBinary</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>
        <span>int</span> aLen <span>=</span> a<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> bLen <span>=</span> b<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> maxLen <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>aLen<span>,</span> bLen<span>)</span><span>;</span>

        <span>// 从个位开始加，个位在字符串的右边</span>
        <span>// 代码访问从左到右，因此先反转一下</span>
        <span>StringBuilder</span> sbA <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>a<span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>;</span>
        <span>StringBuilder</span> sbB <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>b<span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>;</span>

        <span>// 让两个字符补齐成一样的长度</span>
        <span>while</span> <span>(</span>sbA<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> maxLen<span>)</span> <span>{</span>
            sbA<span>.</span><span>append</span><span>(</span><span>"0"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>while</span> <span>(</span>sbB<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> maxLen<span>)</span> <span>{</span>
            sbB<span>.</span><span>append</span><span>(</span><span>"0"</span><span>)</span><span>;</span>
        <span>}</span>

        <span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>// 进位，初始时进位为 0</span>
        <span>int</span> carry <span>=</span> <span>0</span><span>;</span>
        <span>// 当前字符的 ASCII 值减去 '0' 的 ASCII 值，相当于将这个字符转换成数值</span>
        <span>int</span> num1<span>;</span>
        <span>int</span> num2<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> maxLen<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            num1 <span>=</span> sbA<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
            num2 <span>=</span> sbB<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
            <span>if</span> <span>(</span>carry <span>+</span> num1 <span>+</span> num2 <span>></span> <span>1</span><span>)</span> <span>{</span>
                <span>// 因为是二进制，所以多余 2 的部分要减去</span>
                res<span>.</span><span>append</span><span>(</span>carry <span>+</span> num1 <span>+</span> num2 <span>-</span> <span>2</span><span>)</span><span>;</span>
                <span>// 表示要进位</span>
                carry <span>=</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                res<span>.</span><span>append</span><span>(</span>carry <span>+</span> num1 <span>+</span> num2<span>)</span><span>;</span>
                carry <span>=</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 对于最高位还要进位的情况，需要单独判断</span>
        <span>if</span> <span>(</span>carry <span>==</span> <span>1</span><span>)</span> <span>{</span>
            res<span>.</span><span>append</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 最后不要忘记再反转一次</span>
        <span>return</span> res<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> a <span>=</span> <span>"1010"</span><span>;</span>
        <span>String</span> b <span>=</span> <span>"1011"</span><span>;</span>
        <span>Solution</span> solution <span>=</span> <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> addBinary <span>=</span> solution<span>.</span><span>addBinary</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>addBinary<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>max</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>))</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">M</span></span></span></span> 是字符串 <code>a</code> 的长度，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是字符串 <code>b</code> 的长度。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>max</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>))</span></span></span></span>，保存结果需要 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>max</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span> 长度的可变字符序列对象，如果最高位需要进位，还需要加 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>，不过在复杂度计算中忽略这个 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>。</li>
</ul>
<p>上面的代码“翻转”了两次，显得有点啰嗦，我们可以使用两个指针，分别从字符串的末尾开始向前遍历，同时在借用 <code>StringBuilder</code> 对象的 <code>insert</code> 方法，从右向左依次得出计算结果，就真的非常接近我们手写“竖式加法”的过程了。下面是参考代码。</p>
<p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>String</span> <span>addBinary</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>
        <span>int</span> i <span>=</span> a<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
        <span>int</span> j <span>=</span> b<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>

        <span>// 保存结果的可变的字符序列对象</span>
        <span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>// 当前和</span>
        <span>int</span> curSum<span>;</span>
        <span>int</span> carry <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>i <span>>=</span> <span>0</span> <span>||</span> j <span>>=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 当前和至少是那个进位</span>
            curSum <span>=</span> carry<span>;</span>
            <span>if</span> <span>(</span>i <span>>=</span> <span>0</span><span>)</span> <span>{</span>
                curSum <span>+=</span> a<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
                i<span>--</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>j <span>>=</span> <span>0</span><span>)</span> <span>{</span>
                curSum <span>+=</span> b<span>.</span><span>charAt</span><span>(</span>j<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
                j<span>--</span><span>;</span>
            <span>}</span>

            <span>// 判断是否需要进位，即确定 carry 的值</span>
            <span>if</span> <span>(</span>curSum <span>></span> <span>1</span><span>)</span> <span>{</span>
                curSum <span>-=</span> <span>2</span><span>;</span>
                carry <span>=</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                carry <span>=</span> <span>0</span><span>;</span>
            <span>}</span>

            <span>// 只写结果的值，进位作为下一轮的初始值</span>
            res<span>.</span><span>insert</span><span>(</span><span>0</span><span>,</span> curSum<span>)</span><span>;</span>
        <span>}</span>

        <span>// 这里不要忘记如果全部加完以后还要进位，要把最高位加上 1</span>
        <span>if</span> <span>(</span>carry <span>==</span> <span>1</span><span>)</span> <span>{</span>
            res<span>.</span><span>insert</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> a <span>=</span> <span>"1010"</span><span>;</span>
        <span>String</span> b <span>=</span> <span>"1011"</span><span>;</span>
        <span>Solution2</span> solution2 <span>=</span> <span>new</span> <span>Solution2</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> addBinary <span>=</span> solution2<span>.</span><span>addBinary</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>addBinary<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>max</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>))</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">M</span></span></span></span> 是字符串 <code>a</code> 的长度，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是字符串 <code>b</code> 的长度。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>max</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>))</span></span></span></span>，保存结果需要 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>max</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span> 长度的可变字符序列对象，如果最高位需要进位，还需要加 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>，不过在复杂度计算中忽略这个 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 136 题：只出现一次的数字</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0136-single-number/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0136-single-number/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener noreferrer">136. 只出现一次的数字<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: [2,2,1]
输出: 1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: [4,1,2,1,2]
输出: 4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: nums = [1]
Output: 1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code></li>
<li>Each element in the array appears twice except for one element which appears only once.</li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>// 第 56 题：数组中数字出现的次数 P275</span>
<span>// 参考资料：</span>
<span>// 1、https://blog.csdn.net/derrantcm/article/details/46771717</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>// 考察位运算：或、与、异或、非，以及无符号左移 >>></span>
    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>findNumbersAppearanceOnce</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span><span>2</span><span>]</span><span>;</span>
        <span>assert</span> len <span>>=</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> nums<span>;</span>
        <span>}</span>
        <span>// 那两个只出现一次的数的异或运算的结果</span>
        <span>int</span> xor <span>=</span> <span>xor</span><span>(</span>nums<span>)</span><span>;</span>

        <span>// 关键在这里</span>
        <span>// 找到这个 xor 的二进制表示第 1 个是 1 的数位是第几位</span>
        <span>int</span> binaryFirstNotZero <span>=</span> <span>binaryFirstNotZero</span><span>(</span>xor<span>)</span><span>;</span>

        <span>// 接下来分别对两组进行异或</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 如果这个数右移这么多位是 1 的分在一组，是 0 的分在另外一组，遍历的时候，就进行异或运算</span>
            <span>if</span> <span>(</span><span>(</span>nums<span>[</span>i<span>]</span> <span>>>></span> binaryFirstNotZero <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                res<span>[</span><span>0</span><span>]</span> <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                res<span>[</span><span>1</span><span>]</span> <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>// 得到一个数组经过异或运算的结果 xor</span>
    <span>// 异或 的英文翻译就是 xor</span>
    <span>private</span> <span>int</span> <span>xor</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> xor <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            xor <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> xor<span>;</span>
    <span>}</span>

    <span>// 得到一个整数的二进制表示从右到左第 1 个非零的位数是第几位</span>
    <span>private</span> <span>int</span> <span>binaryFirstNotZero</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>// 这里的 1 把它看成二进制的 1，即 00000001</span>
        <span>while</span> <span>(</span><span>(</span>num <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> index <span>&lt;</span> <span>32</span><span>)</span> <span>{</span>
            num <span>>>>=</span> <span>1</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>
        <span>// 走到这里满足 (num &amp; 1) == 1</span>
        <span>return</span> index<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>findNumsAppearOnce</span><span>(</span>self<span>,</span> nums<span>)</span><span>:</span>
        <span>"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        l <span>=</span> <span>len</span><span>(</span>nums<span>)</span>
        <span>if</span> l <span>&lt;</span> <span>2</span><span>:</span>
            <span>raise</span> Exception<span>(</span><span>'程序出错'</span><span>)</span>
        <span>if</span> l <span>==</span> <span>2</span><span>:</span>
            <span>return</span> nums

        <span># 全部相与一遍</span>
        xor <span>=</span> <span>0</span>
        <span>for</span> num <span>in</span> nums<span>:</span>
            xor <span>^</span><span>=</span> num

        <span># 最末尾的 1 从右向左边数在第几位</span>
        counter <span>=</span> <span>0</span>
        <span>while</span> xor <span>&amp;</span> <span>1</span> <span>==</span> <span>0</span><span>:</span>
            xor <span>>></span><span>=</span> <span>1</span>
            counter <span>+=</span> <span>1</span>

        res <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>]</span>
        <span>for</span> num <span>in</span> nums<span>:</span>
            <span>if</span> <span>(</span>num <span>>></span> counter<span>)</span> <span>&amp;</span> <span>1</span> <span>==</span> <span>1</span><span>:</span>
                res<span>[</span><span>1</span><span>]</span> <span>^</span><span>=</span> num
            <span>else</span><span>:</span>
                res<span>[</span><span>0</span><span>]</span> <span>^</span><span>=</span> num
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 201 题：数字范围按位与</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0201-bitwise-and-of-numbers-range/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0201-bitwise-and-of-numbers-range/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener noreferrer">201. 数字范围按位与<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你两个整数 <code>left</code> 和 <code>right</code> ，表示区间 <code>[left, right]</code> ，返回此区间内所有数字 <strong>按位与</strong> 的结果（包含 <code>left</code> 、<code>right</code> 端点）。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：left = 5, right = 7
输出：4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：left = 0, right = 0
输出：0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：left = 1, right = 2147483647
输出：0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.10764em;">f</span><span>t</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span style="margin-right:0.02778em;">r</span><span>i</span><span style="margin-right:0.03588em;">g</span><span>h</span><span>t</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
<p>分析：位运算的问题，干脆就把它记住。</p>
<p>思路：相邻的两个数末尾相与一定等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>。于是就有如下写法：</p>
<p>Java 代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution2</span> <span>{</span>
    <span>/**
     * 真的是很酷！
     *
     * @param m
     * @param n
     * @return
     */</span>
    <span>public</span> <span>int</span> <span>rangeBitwiseAnd</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
        <span>int</span> count <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>m <span>!=</span> n<span>)</span> <span>{</span>
            m <span>>>=</span> <span>1</span><span>;</span>
            n <span>>>=</span> <span>1</span><span>;</span>
            count<span>++</span><span>;</span>
        <span>}</span>
        <span>return</span> m <span>&lt;&lt;</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>于是我们可以一步到位，利用 <code>n &amp;= (n - 1)</code> 运算依次消去“大于” <code>m</code> 的部分的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>。</p>
<p>Java 代码：</p>
<div><pre><code><span>/**
 * https://blog.csdn.net/DERRANTCM/article/details/47997613
 *
 * @author liwei
 * @date 18/6/29 下午9:37
 */</span>
<span>public</span> <span>class</span> <span>Solution3</span> <span>{</span>

    <span>/**
     * 利用了 n &amp;= (n - 1) 一下能消死一大片
     *
     * @param m
     * @param n
     * @return
     */</span>
    <span>public</span> <span>int</span> <span>rangeBitwiseAnd</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
        <span>while</span> <span>(</span>n <span>></span> m<span>)</span> <span>{</span>
            n <span>&amp;=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> n<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 342 题：4 的幂</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0342-power-of-four/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0342-power-of-four/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener noreferrer">342. 4 的幂<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 4^x</code></p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：n = 16
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：n = 5
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：n = 1
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>n</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 442 题：数组中重复的数据</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0442-find-all-duplicates-in-an-array/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0442-find-all-duplicates-in-an-array/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener noreferrer">442. 数组中重复的数据<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/solution/chou-ti-yuan-li-ji-yu-yi-huo-yun-suan-jiao-huan-li/" target="_blank" rel="noopener noreferrer">“抽屉原理” + 基于“异或运算”交换两个变量的值<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回。</p>
<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [1,1,2]
输出：[1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [1]
输出：[]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中的每个元素出现 <strong>一次</strong> 或 <strong>两次</strong></li>
</ul>
<h3 id="特别注意-基于-异或运算-交换两个变量的值-这种操作仅仅只是用于解题-千万不要在工作中使用这样的代码-会有一些坑-重点是-使得代码难以阅读和被他人理解。没有必要为了节约空间去牺牲代码的可读性。"> 特别注意：基于“异或运算”交换两个变量的值，这种操作仅仅只是用于解题，千万不要在工作中使用这样的代码，会有一些坑，重点是：使得代码难以阅读和被他人理解。没有必要为了节约空间去牺牲代码的可读性。</h3>
<h2 id=""> <br></h2>
<p>方法：“抽屉原理” + 基于“异或运算”交换两个变量的值</p>
<p>思路分析：“桶排序”的思想是“抽屉原理”，即“一个萝卜一个坑”，8 个萝卜要放在 7 个坑里，则至少有 1 个坑里至少有 2 个萝卜。</p>
<p>“抽屉原理”的思想很简单，但是借助它我们可以完成一些比较难的问题，例如：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener noreferrer">「力扣」第 41 题：缺失的第一个正数（困难）<i>Content not supported</i></a>。还有一个与本题（标注为“中等”）类似的问题：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener noreferrer">「力扣」第 448 题： 找到所有数组中消失的数字（简单）<i>Content not supported</i></a>，就很神奇，同样是“抽屉原理”，可以解决的问题涵盖了“简单”、“中等”、“困难”三个等级。</p>
<p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p>
<ul>
<li>让数值 1 就放在索引位置 0 处；</li>
<li>让数值 2 就放在索引位置 1 处；</li>
<li>让数值 3 就放在索引位置 2 处；</li>
</ul>
<p>……</p>
<p>一次遍历以后，那些“无处安放”的元素就是我们要找的“出现两次的元素”。</p>
<p>为了不使用额外的空间，这里使用到的一个技巧是“基于异或运算交换两个变量的值”：交换两个整数，除了引入一个新的变量，写出一个“轮换”的赋值表达式以外，还有两种比较 tricky 的做法，下面给出结论。</p>
<p>“异或运算”是不进位的二进制加法，它有如下性质：</p>
<blockquote>
<p>如果 <code>a ^ b = c</code> ，那么 <code>a ^ c = b</code> 与 <code>b ^ c = a</code> 同时成立，利用这一条，可以用于交换两个变量的值。</p>
</blockquote>
<p>于是，交换两个变量的值，例如 <code>a</code> 和 <code>b</code>，不使用第三个变量，有两种不同的方法：</p>
<table>
<thead>
<tr>
<th>基于异或运算</th>
<th>基于加减法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a = a ^ b</code><br><code>b = a ^ b</code><br><code>a = a ^ b</code></td>
<td><code>a = a + b</code><i>Content not supported</i><code>b = a - b</code><i>Content not supported</i><code>a = a - b</code></td>
</tr>
</tbody>
</table>
<p>我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边依次是 <code>a</code>、<code>b</code>、<code>a</code>。</p>
<p>在这里特别感谢用户 <a href="/u/davidlaid/">@davidlaid</a> 给出的意见：</p>
<blockquote>
<ul>
<li>对于异或运算实现的交换方法，如果调用 <code>swap(nums, i, i)</code>，那么最终的结果会变为 <code>0</code>。</li>
<li>对于加减法实现的交换方法，有可能发生溢出。</li>
</ul>
</blockquote>
<p>调用 <code>swap(nums, i, i)</code>，那么最终的结果会变为 <code>0</code> 这是因为，如果是在数组中，自己和自己交换，只有 1 个空间，这个数会在异或运算的过程中变为 <code>0</code>，因此单独判断一下就好了。我个人还是比价少用这个技巧的，如果题目中限制了不能使用额外的存储空间，才用“基于异或运算实现的交换方法”。</p>
<p><strong>参考代码</strong>：</p>
<p>注意：因为这里数组的数值和索引有一个偏差，所以我将交换数组元素的方法做了一个封装，这样可以降低编码出错的概率，供大家参考。</p>
<p>调用 <code>swap</code> 方法使用了栈空间，但是如果不这么写，代码很容易出错，也不符合编码规范，我个人觉得知道这个知识点就可以了。</p>
<p>还是强调两点：</p>
<p>1、<strong>上面介绍的通过异或运算交换两个变量的做法，不要在平常工程当中用，节约不了多少空间</strong>；</p>
<p>2、<strong>尽量抽取方法以体现主干逻辑</strong>，尽管不符合本题意思。</p>
<p>写代码性能虽然很重要，但在很多时候，为了一点点性能，丢失可读性是没有必要的。</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>findDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>nums<span>[</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>]</span> <span>!=</span> nums<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span> <span>!=</span> i<span>)</span> <span>{</span>
                res<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index1 <span>==</span> index2<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index1<span>]</span> <span>^</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> nums<span>[</span>index1<span>]</span> <span>^</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index1<span>]</span> <span>^</span> nums<span>[</span>index2<span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 421 题：数组中两个数的最大异或值（中等）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0421-maximum-xor-of-two-numbers-in-an-array/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0421-maximum-xor-of-two-numbers-in-an-array/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener noreferrer">421. 数组中两个数的最大异或值<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/li-yong-yi-huo-yun-suan-de-xing-zhi-tan-xin-suan-f/" target="_blank" rel="noopener noreferrer">利用异或运算的性质 + 贪心算法（Python 代码、Java 代码）<i>Content not supported</i></a> 。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p>**进阶：**你可以在 <code>O(n)</code> 的时间解决这个问题吗？</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [0]
输出：0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [2,4]
输出：6
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：nums = [8,10,2]
输出：10
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 5：</strong></p>
<div><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
输出：127
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
</ul>
<hr>
<ul>
<li>提示：点击上面的题解链接，可以看到我制作的幻灯片轮播图。</li>
</ul>
<h2 id="异或运算的性质"> 异或运算的性质</h2>
<p>解决这个问题，我们首先需要利用异或运算的一个性质：</p>
<blockquote>
<p>如果 <code>a ^ b = c</code> 成立，那么<code>a ^ c = b</code> 与 <code>b ^ c = a</code> 均成立。</p>
</blockquote>
<p>即<strong>如果有三个数，满足其中两个数的异或值等于另一个值，那么这三个数的顺序可以任意调换</strong>。</p>
<ul>
<li>那么如何理解这个性质呢？因为异或运算其实就是<strong>二进制下不进位的加法</strong>，你不妨自己举几个例子，在草稿纸上验证一下。</li>
</ul>
<h2 id="如何应用到本题"> 如何应用到本题？</h2>
<p>这道题找最大值的思路是这样的：因为两两异或可以得到一个值，在所有的两两异或得到的值中，一定有一个最大值，我们推测这个最大值应该是什么样的？即根据“最大值”的存在性解题（一定存在）。在这里要强调一下：</p>
<blockquote>
<p><strong>我们只用关心这个最大的异或值需要满足什么性质，进而推出这个最大值是什么，而不必关心这个异或值是由哪两个数得来的。</strong></p>
</blockquote>
<p>（上面这句话很重要，如果读者一开始看不明白下面的思考，不妨多看几遍我上面写的这句话。）</p>
<p>于是有如下思考：</p>
<p>1、二进制下，我们希望一个数尽可能大，即希望越高位上越能够出现“1”，这样这个数就是所求的最大数，这是贪心算法的思想。</p>
<p>2、于是，我们可以从最高位开始，到最低位，首先假设高位是 “1”，把这 n 个数全部遍历一遍，看看这一位是不是真的可以是“1”，否则这一位就得是“0”，判断的依据是上面“异或运算的性质”，即下面的第 3 点；</p>
<p>3、如果 <code>a ^ b = max</code> 成立 ，<code>max</code> 表示当前得到的“最大值”，那么一定有 <code>max ^ b = a</code> 成立。我们可以先假设当前数位上的值为 “1”，再把当前得到的数与这个 n 个数的<strong>前缀</strong>（因为是从高位到低位看，所以称为“前缀”）进行异或运算，放在一个哈希表中，再依次把所有<strong>前缀</strong>与这个假设的“最大值”进行异或以后得到的结果放到哈希表里查询一下，如果查得到，就说明这个数位上可以是“1”，否则就只能是 0（看起来很晕，可以看代码理解）。</p>
<p>一种极端的情况是，这 n 个数在某一个数位上全部是 0 ，那么任意两个数异或以后都只能是 0，那么假设当前数位是 1 这件事情就不成立。</p>
<p>4、如何得到前缀，可以用掩码（mask），掩码可以进行如下构造，将掩码与原数依次进行“与”运算，就能得到前缀。</p>
<div><pre><code><span>10000000000000000000000000000000</span>
<span>11000000000000000000000000000000</span>
<span>11100000000000000000000000000000</span>
<span>11110000000000000000000000000000</span>
<span>11111000000000000000000000000000</span>
<span>11111100000000000000000000000000</span>
<span>11111110000000000000000000000000</span>
<span>11111111000000000000000000000000</span>
<span>11111111100000000000000000000000</span>
<span>11111111110000000000000000000000</span>
<span>11111111111000000000000000000000</span>
<span>11111111111100000000000000000000</span>
<span>11111111111110000000000000000000</span>
<span>11111111111111000000000000000000</span>
<span>11111111111111100000000000000000</span>
<span>11111111111111110000000000000000</span>
<span>11111111111111111000000000000000</span>
<span>11111111111111111100000000000000</span>
<span>11111111111111111110000000000000</span>
<span>11111111111111111111000000000000</span>
<span>11111111111111111111100000000000</span>
<span>11111111111111111111110000000000</span>
<span>11111111111111111111111000000000</span>
<span>11111111111111111111111100000000</span>
<span>11111111111111111111111110000000</span>
<span>11111111111111111111111111000000</span>
<span>11111111111111111111111111100000</span>
<span>11111111111111111111111111110000</span>
<span>11111111111111111111111111111000</span>
<span>11111111111111111111111111111100</span>
<span>11111111111111111111111111111110</span>
<span>11111111111111111111111111111111</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>以题目中的数组 <code>[3, 10, 5, 25, 2, 8]</code> 为例，下面讲解这个最大的两两异或值是如何得到的，这里为了方便演示，只展示一个数二进制的低 8 位。</p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/421-1.png" alt="LeetCode 第 421 题：数组中两个数的最大异或值-1" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/421-2.png" alt="LeetCode 第 421 题：数组中两个数的最大异或值-2" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/421-3.png" alt="LeetCode 第 421 题：数组中两个数的最大异或值-3" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/421-4.png" alt="LeetCode 第 421 题：数组中两个数的最大异或值-4" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/421-5.png" alt="LeetCode 第 421 题：数组中两个数的最大异或值-5" loading="lazy"></p>
<p><img src="https://liweiwei1419.github.io/images/leetcode-solution/421-6.png" alt="LeetCode 第 421 题：数组中两个数的最大异或值-6" loading="lazy"></p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>findMaximumXOR</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        res <span>=</span> <span>0</span>
        mask <span>=</span> <span>0</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>31</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>:</span>
            mask <span>|</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span>

            <span># 当前得到的所有前缀都放在这个哈希表中</span>
            s <span>=</span> <span>set</span><span>(</span><span>)</span>
            <span>for</span> num <span>in</span> nums<span>:</span>
                s<span>.</span>add<span>(</span>mask <span>&amp;</span> num<span>)</span>

            <span># 先“贪心地”假设这个数位上是 “1” ，如果全部前缀都看完，都不符合条件，这个数位上就是 “0”</span>
            temp <span>=</span> res <span>|</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span>

            <span>for</span> prefix <span>in</span> s<span>:</span>
                <span>if</span> temp <span>^</span> prefix <span>in</span> s<span>:</span>
                    res <span>=</span> temp
                    <span>break</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Set</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>// 先确定高位，再确定低位（有点贪心算法的意思），才能保证这道题的最大性质</span>
    <span>// 一位接着一位去确定这个数位的大小</span>
    <span>// 利用性质： a ^ b = c ，则 a ^ c = b，且 b ^ c = a</span>

    <span>public</span> <span>int</span> <span>findMaximumXOR</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>int</span> mask <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>31</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
            <span>// 注意点1：注意保留前缀的方法，mask 是这样得来的</span>
            <span>// 用异或也是可以的 mask = mask ^ (1 &lt;&lt; i);</span>
            mask <span>=</span> mask <span>|</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span><span>;</span>

            <span>// System.out.println(Integer.toBinaryString(mask));</span>
            <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
                <span>// 注意点2：这里使用 &amp; ，保留前缀的意思（从高位到低位）</span>
                set<span>.</span><span>add</span><span>(</span>num <span>&amp;</span> mask<span>)</span><span>;</span>
            <span>}</span>

            <span>// 这里先假定第 n 位为 1 ，前 n-1 位 res 为之前迭代求得</span>
            <span>int</span> temp <span>=</span> res <span>|</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> i<span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Integer</span> prefix <span>:</span> set<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>set<span>.</span><span>contains</span><span>(</span>prefix <span>^</span> temp<span>)</span><span>)</span> <span>{</span>
                    res <span>=</span> temp<span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> nums <span>=</span> <span>{</span><span>3</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>25</span><span>,</span> <span>2</span><span>,</span> <span>8</span><span>}</span><span>;</span>
        <span>Solution2</span> solution2 <span>=</span> <span>new</span> <span>Solution2</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> maximumXOR <span>=</span> solution2<span>.</span><span>findMaximumXOR</span><span>(</span>nums<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>maximumXOR<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，把整个数组看了 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>32</span></span></span></span> 次，即 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>32</span><span style="margin-right:0.10903em;">N</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，使用了一个哈希表，这个哈希表最多存 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>32</span></span></span></span> 个前缀，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>32</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 477 题：汉明距离总和（中等）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0477-total-hamming-distance/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0477-total-hamming-distance/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener noreferrer">477. 汉明距离总和<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>两个整数的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin" target="_blank" rel="noopener noreferrer">汉明距离<i>Content not supported</i></a> 指的是这两个数字的二进制数对应位不同的数量。</p>
<p>给你一个整数数组 <code>nums</code>，请你计算并返回 <code>nums</code> 中任意两个数之间 <strong>汉明距离的总和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [4,14,2]
输出：6
解释：在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [4,14,4]
输出：4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>
<li>给定输入的对应答案符合 <strong>32-bit</strong> 整数范围</li>
</ul>
<p><strong>参考代码</strong>：</p>
<p>某一位上 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的数量乘上 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 的数量就是这一位对结果的贡献，当某一位上全是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> 时就没有继续计算下去的必要了。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>totalHammingDistance</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>
        <span>int</span> mask <span>=</span> <span>1</span><span>;</span>
        <span>int</span> total <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>32</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 在这个数位上有多少个 1</span>
            <span>int</span> oneCount <span>=</span> <span>0</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>(</span>num <span>&amp;</span> mask<span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
                    oneCount<span>++</span><span>;</span>
                <span>}</span>
            <span>}</span>
            total <span>+=</span> <span>(</span><span>(</span>len <span>-</span> oneCount<span>)</span> <span>*</span> oneCount<span>)</span><span>;</span>
            mask <span>&lt;&lt;=</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> total<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 868 题：二进制间距（简单）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/0868-binary-gap/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/0868-binary-gap/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/binary-gap/" target="_blank" rel="noopener noreferrer">868. 二进制间距<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的 <strong>最长距离</strong> 。如果不存在两个相邻的 1，返回 <code>0</code> 。</p>
<p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>&quot;1001&quot;</code> 中的两个 <code>1</code> 的距离为 3 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：n = 22
输出：2
解释：
22 的二进制是 &quot;10110&quot; 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：n = 5
输出：2
解释：
5 的二进制是 &quot;101&quot; 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：n = 6
输出：1
解释：
6 的二进制是 &quot;110&quot; 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：n = 8
输出：0
解释：
8 的二进制是 &quot;1000&quot; 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>示例 5：</strong></p>
<div><pre><code>输入：n = 1
输出：0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ul>
<p><strong>注意</strong>：这里设置 <code>pre</code> 初值为 -1 的小技巧，即 <code>pre</code> 一定要被赋值以后，才能参与计算。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>transpose</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>A</span><span>)</span> <span>{</span>
        <span>int</span> row <span>=</span> <span>A</span><span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>row <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>
        <span>}</span>
        <span>int</span> col <span>=</span> <span>A</span><span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
        <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix <span>=</span> <span>new</span> <span>int</span><span>[</span>col<span>]</span><span>[</span>row<span>]</span><span>;</span>
        <span>// 遍历还是按照原来的方式遍历</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> row<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> col<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>// 按照转置的方式填写转置矩阵就可以了</span>
                matrix<span>[</span>j<span>]</span><span>[</span>i<span>]</span> <span>=</span> <span>A</span><span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> matrix<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1457 题： 二叉树中的伪回文路径（中等）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/1457-pseudo-palindromic-paths-in-a-binary-tree/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/1457-pseudo-palindromic-paths-in-a-binary-tree/"/>
    <updated>2022-08-08T06:57:46.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目地址：<a href="https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener noreferrer">1457. 二叉树中的伪回文路径<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>
<p>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。</p>
<p><strong>示例 1</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpap79owj2063043t8m.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [2,3,1,3,1,null,1]
输出：2
解释：上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。
     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tpark83lj205705g746.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [2,1,1,1,3,null,null,null,null,null,1]
输出：1
解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。
     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：root = [9]
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>给定二叉树的节点数目在 <code>1</code> 到 <code>10^5</code> 之间。</li>
<li>节点值在 <code>1</code> 到 <code>9</code> 之间。</li>
</ul>
<h3 id="思路分析"> 思路分析</h3>
<ul>
<li>伪回文的意思是：要么出现的字母都能两两配对，要么除了两两配对的字符以外，还有一个字符是「落单」的；</li>
<li>题目说的是从根结点到叶子结点的一个路径，因此我们使用「先序遍历」；</li>
<li>异或有这样的特点：异或两次以后为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>；</li>
<li>状态压缩的好处是：易于复制，像这道问题，可以作为参数传递下去，Java 中参数的传递是「值传递」；</li>
<li><code>(status &amp; (status - 1))</code> 是位运算的一个性质，需要记住的，表示把二进制表示下最低位的 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 变成 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>。</li>
</ul>
<p><strong>参考代码 1</strong>：</p>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayDeque</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Deque</span></span><span>;</span>


<span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>int</span> <span>pseudoPalindromicPaths</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>dfs</span><span>(</span>root<span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>return</span> count<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>int</span> status<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>

        status <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> node<span>.</span>val<span>)</span><span>;</span>

        <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>status <span>==</span> <span>0</span> <span>||</span> <span>(</span>status <span>&amp;</span> <span>(</span>status <span>-</span> <span>1</span><span>)</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                count<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>dfs</span><span>(</span>node<span>.</span>left<span>,</span> status<span>)</span><span>;</span>

        <span>}</span>

        <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>dfs</span><span>(</span>node<span>.</span>right<span>,</span> status<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是二叉树的结点的个数；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里需要的空间是递归树的高度。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 1371 题：每个元音包含偶数次的最长子字符串（中等）</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/1371-find-the-longest-substring-containing-vowels-in-even-counts/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/1371-find-the-longest-substring-containing-vowels-in-even-counts/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts" target="_blank" rel="noopener noreferrer">1371. 每个元音包含偶数次的最长子字符串<i>Content not supported</i></a>。</li>
</ul>
<p>今天要和大家分享的是「状态压缩」的两道问题。我再准备一段时间，再和大家分享「动态规划」里「状压 dp」相关的问题，这两道问题是一个热身。</p>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。</p>
<p>示例 1：</p>
<div><pre><code>输入：s = &quot;eleetminicoworoep&quot;
输出：13
解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例 2：</p>
<div><pre><code>输入：s = &quot;leetcodeisgreat&quot;
输出：5
解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例 3：</p>
<div><pre><code>输入：s = &quot;bcbcbc&quot;
输出：6
解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code>；</li>
<li><code>s 只包含小写英文字母</code>。</li>
</ul>
<h3 id="算法思想"> 算法思想</h3>
<p>前缀和 -&gt; 区间和（对于异或也是类似的道理）、哈希表、动态规划、状态压缩。</p>
<h3 id="思路分析"> 思路分析：</h3>
<ol>
<li>
<p>「出现两次」联想到异或和两次抵消；</p>
</li>
<li>
<p>「子字符串」表示连续，连续的问题通常想到「滑动窗口」或者是「前缀和」，这里的和也指异或和；子串中 <code>a</code>、<code>e</code>、<code>i</code>、<code>o</code>、<code>u</code> 只出现偶数次，等价于：在这个子串里异或和为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span>；</p>
</li>
<li>
<p>由于要记录「最长的」符合要求的子串的长度，于是只需要记录第一次出现的「前缀异或和」，以后再次出现的相同的「异或前缀和」的时候，将下标相减（注意考虑边界情况）。</p>
<p>因此把所有的「前缀异或和」信息保存在一个哈希表里，由于这里所有的前缀异或和状态有限（<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>32</span></span></span></span>），用数组或者哈希表均可；</p>
</li>
<li>
<p>定义成「异或前缀和」是因为中间遍历的那些元音字符相同的，在异或运算下都抵消了，这是符合题目的要求的：「中间遍历的那些字符出现偶数次元音字符」；</p>
</li>
<li>
<p>这个哈希表的 <code>key</code> 是前缀异或和对应的整数 <code>cur</code>， <code>value</code> 是当前遍历到的下标，初始化的时候赋值为一个特殊值，表示当前的前缀异或和没有出现；</p>
</li>
<li>
<p><code>cur</code> 记录了遍历到当前下标 <code>i</code> 的 <code>a</code>、<code>e</code>、<code>i</code>、<code>o</code>、<code>u</code> 的情况，是一个「前缀和」的概念，并且是「异或前缀和」；</p>
</li>
<li>
<p>把前缀异或和的信息表示在一个二进制只有 5 位的整数 <code>cur</code> 里，方便以后查找；</p>
</li>
<li>
<p>把状态信息返回在一个整数里面的操作叫做「状态压缩」，状态压缩的好处是，便于查找和比对，不好的地方是调试相对困难。</p>
</li>
</ol>
<p>以下两种写法一样：</p>
<p><strong>参考代码 1</strong>：</p>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>findTheLongestSubstring</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>// dp 定义：状态为 i 的前缀异或和第 1 次出现的</span>
        <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span><span>32</span><span>]</span><span>;</span>
        <span>// -1 表示未赋值</span>
        <span>Arrays</span><span>.</span><span>fill</span><span>(</span>dp<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>

        <span>// 前缀异或和</span>
        <span>int</span> bitMap <span>=</span> <span>0</span><span>;</span>
        dp<span>[</span>bitMap<span>]</span> <span>=</span> <span>0</span><span>;</span>

        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>

        <span>char</span><span>[</span><span>]</span> charArray <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>char</span> c <span>=</span> charArray<span>[</span>i<span>]</span><span>;</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'a'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>1</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'e'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'i'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>2</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'o'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>3</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'u'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>4</span><span>)</span><span>;</span>
            <span>}</span>

            <span>// 先记录信息，然后再计算长度的时候，就需要 + 1</span>
            <span>if</span> <span>(</span>dp<span>[</span>bitMap<span>]</span> <span>>=</span> <span>0</span><span>)</span> <span>{</span>
                res <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>res<span>,</span> i <span>-</span> dp<span>[</span>bitMap<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>bitMap<span>]</span> <span>=</span> i <span>+</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p><strong>参考代码 2</strong>：</p>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution2</span> <span>{</span>

    <span>public</span> <span>int</span> <span>findTheLongestSubstring</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span><span>32</span><span>]</span><span>;</span>
        <span>Arrays</span><span>.</span><span>fill</span><span>(</span>dp<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>

        <span>int</span> bitMap <span>=</span> <span>0</span><span>;</span>
        dp<span>[</span>bitMap<span>]</span> <span>=</span> <span>0</span><span>;</span>

        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>

        <span>char</span><span>[</span><span>]</span> chars <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>char</span> c <span>:</span> chars<span>)</span> <span>{</span>
            index<span>++</span><span>;</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'a'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>1</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'e'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'i'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>2</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'o'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>3</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'u'</span><span>)</span> <span>{</span>
                bitMap <span>^=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>4</span><span>)</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>(</span>dp<span>[</span>bitMap<span>]</span> <span>>=</span> <span>0</span><span>)</span> <span>{</span>
                <span>// 由于此时 index 已经 ++，因此是 index - dp[bitMap]</span>
                res <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>res<span>,</span> index <span>-</span> dp<span>[</span>bitMap<span>]</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>bitMap<span>]</span> <span>=</span> index<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是输入数组的长度，遍历一次得到结果；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，状态数组的长度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span>。</li>
</ul>
<p>参考资料：https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">《剑指 Offer》（第 2 版）面试题56 - I. 数组中数字出现的次数</title>
    <id>https://suanfa8.com/bit-manipulation/solutions/56-1-shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</id>
    <link href="https://suanfa8.com/bit-manipulation/solutions/56-1-shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/"/>
    <updated>2022-01-13T16:24:35.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 56 - I. 数组中数字出现的次数<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span>，空间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</p>
<p>示例 1：</p>
<div><pre><code>输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>示例 2：</p>
<div><pre><code>输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>限制：</p>
<ul>
<li><code>2 &lt;= nums &lt;= 10000</code></li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>singleNumbers</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>

        <span>// 考察位运算：或、与、异或、非，以及无符号左移 >>></span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span><span>2</span><span>]</span><span>;</span>
        <span>assert</span> len <span>>=</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> nums<span>;</span>
        <span>}</span>
        <span>// 那两个只出现一次的数的异或运算的结果</span>
        <span>int</span> xor <span>=</span> <span>xor</span><span>(</span>nums<span>)</span><span>;</span>
        <span>// 找到这个 xor 的二进制表示第 1 个是 1 的数位是第几位</span>
        <span>int</span> binaryFirstNotZero <span>=</span> <span>binaryFirstNotZero</span><span>(</span>xor<span>)</span><span>;</span>
        <span>// 接下来分别对两组进行异或</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 如果这个数右移这么多位是 1 的分在一组，是 0 的分在另外一组，遍历的时候，就进行异或运算</span>
            <span>if</span> <span>(</span><span>(</span>nums<span>[</span>i<span>]</span> <span>>>></span> binaryFirstNotZero <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                res<span>[</span><span>0</span><span>]</span> <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                res<span>[</span><span>1</span><span>]</span> <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>/**
     * 得到一个数组经过异或运算的结果 xor，异或 的英文翻译就是 xor
     *
     * @param nums
     * @return
     */</span>
    <span>private</span> <span>int</span> <span>xor</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> xor <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            xor <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> xor<span>;</span>
    <span>}</span>

    <span>// 得到一个整数的二进制表示从右到左第 1 个非零的位数是第几位</span>
    <span>private</span> <span>int</span> <span>binaryFirstNotZero</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>// 这里的 1 把它看成二进制的 1，即 00000001</span>
        <span>while</span> <span>(</span><span>(</span>num <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> index <span>&lt;</span> <span>32</span><span>)</span> <span>{</span>
            num <span>>>>=</span> <span>1</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>
        <span>// 走到这里满足 (num &amp; 1) == 1</span>
        <span>return</span> index<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>from</span> typing <span>import</span> List


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>singleNumbers</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>)</span> <span>-</span><span>></span> List<span>[</span><span>int</span><span>]</span><span>:</span>
        size <span>=</span> <span>len</span><span>(</span>nums<span>)</span>
        <span>if</span> size <span>&lt;</span> <span>2</span><span>:</span>
            <span>raise</span> Exception<span>(</span><span>'程序出错'</span><span>)</span>
        <span>if</span> size <span>==</span> <span>2</span><span>:</span>
            <span>return</span> nums

        <span># 全部相与一遍</span>
        xor <span>=</span> <span>0</span>
        <span>for</span> num <span>in</span> nums<span>:</span>
            xor <span>^</span><span>=</span> num

        <span># 最末尾的 1 从右向左边数在第几位</span>
        counter <span>=</span> <span>0</span>
        <span>while</span> xor <span>&amp;</span> <span>1</span> <span>==</span> <span>0</span><span>:</span>
            xor <span>>></span><span>=</span> <span>1</span>
            counter <span>+=</span> <span>1</span>

        res <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>]</span>
        <span>for</span> num <span>in</span> nums<span>:</span>
            <span>if</span> <span>(</span>num <span>>></span> counter<span>)</span> <span>&amp;</span> <span>1</span> <span>==</span> <span>1</span><span>:</span>
                res<span>[</span><span>1</span><span>]</span> <span>^</span><span>=</span> num
            <span>else</span><span>:</span>
                res<span>[</span><span>0</span><span>]</span> <span>^</span><span>=</span> num
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="位运算" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:52.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 8 题：字符串转换整数 (atoi)（中等）</title>
    <id>https://suanfa8.com/array/solutions/0008-string-to-integer-atoi/</id>
    <link href="https://suanfa8.com/array/solutions/0008-string-to-integer-atoi/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener noreferrer">8. 字符串转换整数 (atoi)<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/jin-liang-bu-shi-yong-ku-han-shu-nai-xin-diao-shi-/" target="_blank" rel="noopener noreferrer">尽量不使用库函数、一次遍历（Java）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ul>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span>[</span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>]</span></span></span></span> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span></span></span></span> 的整数应该被固定为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span></span></span></span> ，大于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 的整数应该被固定为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 。</li>
<li>返回整数作为最终结果。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：s = &quot;42&quot;
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）
         ^
第 3 步：&quot;42&quot;（读入 &quot;42&quot;）
           ^
解析得到整数 42 。
由于 &quot;42&quot; 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：s = &quot;   -42&quot;
输出：-42
解释：
第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）
            ^
第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）
             ^
第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）
               ^
解析得到整数 -42 。
由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：s = &quot;4193 with words&quot;
输出：4193
解释：
第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）
         ^
第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 &quot;4193&quot; 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：s = &quot;words and 987&quot;
输出：0
解释：
第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）
         ^
第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-2^31, 2^31 - 1] 内，最终结果为 0 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>示例 5：</strong></p>
<div><pre><code>输入：s = &quot;-91283472332&quot;
输出：-2147483648
解释：
第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）
         ^
第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）
          ^
第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-2^31, 2^31 - 1] 的下界，最终结果被截断为 -2^31 = -2147483648 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>这个问题其实没有考察算法的知识，模拟的是日常开发中对于原始数据的处理（例如「参数校验」等场景），如果面试中遇到类似的问题，应先仔细阅读题目文字说明和示例，有疑惑的地方和需要和面试官确认，在编码的时候需要耐心和细心地调试。</p>
<p>其实很多时候，业务需求就是类似这样的问题，工作中如果遇到：</p>
<p>1、有现成的工具和类库需尽量使用，因为它们是性能更优，且经过更严格测试，是相对可靠的；
2、能抽取成工具类、工具方法的尽量抽取，以突出主干逻辑、方便以后代码复用；
3、不得不写得比较繁琐、冗长的时候，需要写清楚注释、体现逻辑层次，以便上线以后排查问题和后续维护。</p>
<p>在这里我罗列几个要点：</p>
<ul>
<li>根据示例 1，需要去掉前导空格；</li>
<li>根据示例 2，需要判断第 1 个字符为 <code>+</code> 和 <code>-</code> 的情况，因此，可以设计一个变量 <code>sign</code>，初始化的时候为 <code>1</code>，如果遇到 <code>-</code> ，将 <code>sign</code> 修正为 <code>-1</code>；</li>
<li>判断是否是数字，可以使用字符的 ASCII 码数值进行比较，即 <code>0 &lt;= c &lt;= '9'</code>；</li>
<li>根据示例 3 和示例 4 ，在遇到第 1 个不是数字的字符的情况下，转换停止，退出循环；</li>
<li>根据示例 5，如果转换以后的数字超过了 <code>int</code> 类型的范围，需要截取。这里不能将结果 <code>res</code> 变量设计为 <code>long</code> 类型，<strong>注意</strong>：由于输入的字符串转换以后也有可能超过 <code>long</code> 类型，因此需要在循环内部就判断是否越界，只要越界就退出循环，这样也可以减少不必要的计算；</li>
<li>由于涉及下标访问，因此全程需要考虑数组下标是否越界的情况。</li>
</ul>
<p><strong>特别注意</strong>：</p>
<p>1、由于题目中说「环境只能保存 32 位整数」，因此这里在每一轮循环之前先要检查乘以 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>10</span></span></span></span> 以后是否溢出，具体细节请见编码。</p>
<p>2、Java 、Python 和 C++ 字符串的设计都是不可变的，即使用 <code>trim()</code> 会产生新的变量，因此我们<strong>尽量不使用库函数，使用一个变量 <code>index</code> 去做遍历，这样遍历完成以后就得到转换以后的数值</strong>。</p>
<p><strong>参考代码 1</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>myAtoi</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>// str.charAt(i) 方法回去检查下标的合法性，一般先转换成字符数组</span>
        <span>char</span><span>[</span><span>]</span> charArray <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>

        <span>// 1、去除前导空格</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> len <span>&amp;&amp;</span> charArray<span>[</span>index<span>]</span> <span>==</span> <span>' '</span><span>)</span> <span>{</span>
            index<span>++</span><span>;</span>
        <span>}</span>

        <span>// 2、如果已经遍历完成（针对极端用例 "      "）</span>
        <span>if</span> <span>(</span>index <span>==</span> len<span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>// 3、如果出现符号字符，仅第 1 个有效，并记录正负</span>
        <span>int</span> sign <span>=</span> <span>1</span><span>;</span>
        <span>char</span> firstChar <span>=</span> charArray<span>[</span>index<span>]</span><span>;</span>
        <span>if</span> <span>(</span>firstChar <span>==</span> <span>'+'</span><span>)</span> <span>{</span>
            index<span>++</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>firstChar <span>==</span> <span>'-'</span><span>)</span> <span>{</span>
            index<span>++</span><span>;</span>
            sign <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>

        <span>// 4、将后续出现的数字字符进行转换</span>
        <span>// 不能使用 long 类型，这是题目说的</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> len<span>)</span> <span>{</span>
            <span>char</span> currChar <span>=</span> charArray<span>[</span>index<span>]</span><span>;</span>
            <span>// 4.1 先判断不合法的情况</span>
            <span>if</span> <span>(</span>currChar <span>></span> <span>'9'</span> <span>||</span> currChar <span>&lt;</span> <span>'0'</span><span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>

            <span>// 题目中说：环境只能存储 32 位大小的有符号整数，因此，需要提前判：断乘以 10 以后是否越界</span>
            <span>if</span> <span>(</span>res <span>></span> <span>Integer</span><span>.</span>MAX_VALUE <span>/</span> <span>10</span> <span>||</span> <span>(</span>res <span>==</span> <span>Integer</span><span>.</span>MAX_VALUE <span>/</span> <span>10</span> <span>&amp;&amp;</span> <span>(</span>currChar <span>-</span> <span>'0'</span><span>)</span> <span>></span> <span>Integer</span><span>.</span>MAX_VALUE <span>%</span> <span>10</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>res <span>&lt;</span> <span>Integer</span><span>.</span>MIN_VALUE <span>/</span> <span>10</span> <span>||</span> <span>(</span>res <span>==</span> <span>Integer</span><span>.</span>MIN_VALUE <span>/</span> <span>10</span> <span>&amp;&amp;</span> <span>(</span>currChar <span>-</span> <span>'0'</span><span>)</span> <span>></span> <span>-</span><span>(</span><span>Integer</span><span>.</span>MIN_VALUE <span>%</span> <span>10</span><span>)</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>
            <span>}</span>

            <span>// 4.2 合法的情况下，才考虑转换，每一步都把符号位乘进去</span>
            res <span>=</span> res <span>*</span> <span>10</span> <span>+</span> sign <span>*</span> <span>(</span>currChar <span>-</span> <span>'0'</span><span>)</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Solution</span> solution <span>=</span> <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> str <span>=</span> <span>"2147483646"</span><span>;</span>
        <span>int</span> res <span>=</span> solution<span>.</span><span>myAtoi</span><span>(</span>str<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>res<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span>MIN_VALUE<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="C++">
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>
<span><span>#</span><span>include</span> <span>&lt;string></span></span>

<span>using</span> <span>namespace</span> std<span>;</span>

<span>class</span> <span>Solution</span> <span>{</span>
<span>public</span><span>:</span>
    <span>int</span> <span>myAtoi</span><span>(</span>string str<span>)</span> <span>{</span>
        <span>unsigned</span> <span>long</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>

        <span>// 去除前导空格</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> len<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>str<span>[</span>index<span>]</span> <span>!=</span> <span>' '</span><span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>
            index<span>++</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>index <span>==</span> len<span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>int</span> sign <span>=</span> <span>1</span><span>;</span>
        <span>// 处理第 1 个非空字符为正负符号，这两个判断需要写在一起</span>
        <span>if</span> <span>(</span>str<span>[</span>index<span>]</span> <span>==</span> <span>'+'</span><span>)</span> <span>{</span>
            index<span>++</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>str<span>[</span>index<span>]</span> <span>==</span> <span>'-'</span><span>)</span> <span>{</span>
            sign <span>=</span> <span>-</span><span>1</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>

        <span>// 根据题目限制，只能使用 int 类型</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> len<span>)</span> <span>{</span>
            <span>char</span> curChar <span>=</span> str<span>[</span>index<span>]</span><span>;</span>
            <span>if</span> <span>(</span>curChar <span>&lt;</span> <span>'0'</span> <span>||</span> curChar <span>></span> <span>'9'</span><span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>(</span>res <span>></span> INT_MAX <span>/</span> <span>10</span> <span>||</span> <span>(</span>res <span>==</span> INT_MAX <span>/</span> <span>10</span> <span>&amp;&amp;</span> <span>(</span>curChar <span>-</span> <span>'0'</span><span>)</span> <span>></span> INT_MAX <span>%</span> <span>10</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> INT_MAX<span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>res <span>&lt;</span> INT_MIN <span>/</span> <span>10</span> <span>||</span> <span>(</span>res <span>==</span> INT_MIN <span>/</span> <span>10</span> <span>&amp;&amp;</span> <span>(</span>curChar <span>-</span> <span>'0'</span><span>)</span> <span>></span> <span>-</span><span>(</span>INT_MIN <span>%</span> <span>10</span><span>)</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> INT_MIN<span>;</span>
            <span>}</span>

            res <span>=</span> res <span>*</span> <span>10</span> <span>+</span> sign <span>*</span> <span>(</span>curChar <span>-</span> <span>'0'</span><span>)</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 为字符串的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 13 题：罗马数字转整数（简单）</title>
    <id>https://suanfa8.com/array/solutions/0013-roman-to-integer/</id>
    <link href="https://suanfa8.com/array/solutions/0013-roman-to-integer/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener noreferrer">13. 罗马数字转整数<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/tong-guo-ha-xi-biao-cha-dui-ying-guan-xi-te-shu-zh/" target="_blank" rel="noopener noreferrer">通过哈希表查对应关系 + 特殊值处理（Python 代码、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<div><pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: s = &quot;III&quot;
输出: 3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: s = &quot;IV&quot;
输出: 4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3:</strong></p>
<div><pre><code>输入: s = &quot;IX&quot;
输出: 9
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4:</strong></p>
<div><pre><code>输入: s = &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 5:</strong></p>
<div><pre><code>输入: s = &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 15</code></li>
<li><code>s</code> 仅含字符 <code>('I', 'V', 'X', 'L', 'C', 'D', 'M')</code></li>
<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article" target="_blank" rel="noopener noreferrer">罗马数字 - Mathematics <i>Content not supported</i></a>。</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>注意到题目中说：</p>
<blockquote>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。</p>
</blockquote>
<p>特例就是它的反面：<strong>罗马数字中小的数字在大的数字的左边</strong>。这种情况特殊处理即可。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashMap</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Map</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>romanToInt</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>7</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'I'</span><span>,</span> <span>1</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'V'</span><span>,</span> <span>5</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'X'</span><span>,</span> <span>10</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'L'</span><span>,</span> <span>50</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'C'</span><span>,</span> <span>100</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'D'</span><span>,</span> <span>500</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>'M'</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
        <span>char</span><span>[</span><span>]</span> charArray <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> res <span>=</span> map<span>.</span><span>get</span><span>(</span>charArray<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> pre <span>=</span> map<span>.</span><span>get</span><span>(</span>charArray<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
            <span>int</span> cur <span>=</span> map<span>.</span><span>get</span><span>(</span>charArray<span>[</span>i<span>]</span><span>)</span><span>;</span>

            <span>if</span> <span>(</span>pre <span>&lt;</span> cur<span>)</span> <span>{</span>
                <span>// 这是唯一的一种需要注意的特殊情况，当前面的数字比当前数字要小的时候</span>
                <span>// 要用：当前数字 - 前面数字，因为前面数字加过了，所以要减去 2 倍</span>
                res <span>+=</span> <span>(</span>cur <span>-</span> <span>2</span> <span>*</span> pre<span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                res <span>+=</span> cur<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>romanToInt</span><span>(</span>self<span>,</span> s<span>:</span> <span>str</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>

        size <span>=</span> <span>len</span><span>(</span>s<span>)</span>
        <span>if</span> size <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>0</span>
        <span>map</span> <span>=</span> <span>{</span>
            <span>'I'</span><span>:</span> <span>1</span><span>,</span>
            <span>'V'</span><span>:</span> <span>5</span><span>,</span>
            <span>'X'</span><span>:</span> <span>10</span><span>,</span>
            <span>'L'</span><span>:</span> <span>50</span><span>,</span>
            <span>'C'</span><span>:</span> <span>100</span><span>,</span>
            <span>'D'</span><span>:</span> <span>500</span><span>,</span>
            <span>'M'</span><span>:</span> <span>1000</span>
        <span>}</span>

        res <span>=</span> <span>map</span><span>[</span>s<span>[</span><span>0</span><span>]</span><span>]</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> size<span>)</span><span>:</span>

            pre <span>=</span> <span>map</span><span>[</span>s<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>]</span>
            cur <span>=</span> <span>map</span><span>[</span>s<span>[</span>i<span>]</span><span>]</span>
            <span># 这是唯一的一种需要注意的特殊情况，当前面的数字比当前数字要小的时候</span>
            <span># 要用：当前数字 - 前面数字，因为前面数字加过了，所以要减去 2 倍</span>
            <span>if</span> pre <span>&lt;</span> cur<span>:</span>
                res <span>+=</span> <span>(</span>cur <span>-</span> <span>2</span> <span>*</span> pre<span>)</span>
            <span>else</span><span>:</span>
                res <span>+=</span> cur
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是罗马数字的字符个数，全部看过一遍以后，就得得到数字，故是线性时间复杂度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，这里哈希表的长度是固定的，且算法使用到的临时变量的个数也是常数，故空间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 66 题：加 1（简单）</title>
    <id>https://suanfa8.com/array/solutions/0066-plus-one/</id>
    <link href="https://suanfa8.com/array/solutions/0066-plus-one/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener noreferrer">66. 加一<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：digits = [0]
输出：[1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 100</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
</ul>
<h2 id="解题思路"> 解题思路</h2>
<p>注意可以<strong>提前终止</strong>。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>plusOne</span><span>(</span><span>int</span><span>[</span><span>]</span> digits<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> digits<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>;</span>
        <span>}</span>
        <span>int</span> carry <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> len <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
            <span>int</span> sum <span>=</span> digits<span>[</span>i<span>]</span> <span>+</span> carry<span>;</span>
            digits<span>[</span>i<span>]</span> <span>=</span> sum <span>%</span> <span>10</span><span>;</span>
            carry <span>=</span> sum <span>/</span> <span>10</span><span>;</span>
            <span>// 如果不产生进位，马上就可以返回了</span>
            <span>if</span> <span>(</span>carry <span>==</span> <span>0</span><span>)</span> <span>{</span>
                <span>return</span> digits<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>carry <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>int</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span>len <span>+</span> <span>1</span><span>]</span><span>;</span>
            res<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len <span>+</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                res<span>[</span>i<span>]</span> <span>=</span> digits<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
            <span>}</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>return</span> digits<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>plusOne</span><span>(</span>self<span>,</span> digits<span>)</span><span>:</span>
        <span>"""
        :type digits: List[int]
        :rtype: List[int]
        """</span>

        n <span>=</span> <span>len</span><span>(</span>digits<span>)</span>
        <span>if</span> n <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>None</span>
        <span># 从后向前</span>
        <span>for</span> index <span>in</span> <span>range</span><span>(</span>n <span>-</span> <span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>:</span>
            <span>if</span> digits<span>[</span>index<span>]</span> <span>&lt;</span> <span>9</span><span>:</span>
                digits<span>[</span>index<span>]</span> <span>+=</span> <span>1</span>
                <span>return</span> digits
            <span>else</span><span>:</span>
                digits<span>[</span>index<span>]</span> <span>=</span> <span>0</span>
        <span>return</span> <span>[</span><span>1</span><span>]</span> <span>+</span> digits

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></CodeGroupItem>
</CodeGroup>
```
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 67 题：二进制求和（简单）</title>
    <id>https://suanfa8.com/array/solutions/0067-add-binary/</id>
    <link href="https://suanfa8.com/array/solutions/0067-add-binary/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/add-binary" target="_blank" rel="noopener noreferrer">67. 二进制求和<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/add-binary/solution/mo-shi-er-jin-zhi-shu-shi-jia-fa-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">模拟「二进制」竖式加法<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>每个字符串仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成。</li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>a</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span>,</span><span style="margin-right:0.1667em;"></span><span>b</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>
<li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li>
</ul>
<h2 id="解题思路"> 解题思路</h2>
<p>从尾巴开始加。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>String</span> <span>addBinary</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>
        <span>int</span> aLen <span>=</span> a<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> bLen <span>=</span> b<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> maxLen <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>aLen<span>,</span> bLen<span>)</span><span>;</span>

        <span>// 从个位开始加，个位在字符串的右边</span>
        <span>// 代码访问从左到右，因此先反转一下</span>
        <span>StringBuilder</span> sbA <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>a<span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>;</span>
        <span>StringBuilder</span> sbB <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>b<span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>;</span>

        <span>// 让两个字符补齐成一样的长度</span>
        <span>while</span> <span>(</span>sbA<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> maxLen<span>)</span> <span>{</span>
            sbA<span>.</span><span>append</span><span>(</span><span>"0"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>while</span> <span>(</span>sbB<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> maxLen<span>)</span> <span>{</span>
            sbB<span>.</span><span>append</span><span>(</span><span>"0"</span><span>)</span><span>;</span>
        <span>}</span>

        <span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>// 进位，初始时进位为 0</span>
        <span>int</span> carry <span>=</span> <span>0</span><span>;</span>
        <span>// 当前字符的 ASCII 值减去 '0' 的 ASCII 值，相当于将这个字符转换成数值</span>
        <span>int</span> num1<span>;</span>
        <span>int</span> num2<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> maxLen<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            num1 <span>=</span> sbA<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
            num2 <span>=</span> sbB<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
            <span>if</span> <span>(</span>carry <span>+</span> num1 <span>+</span> num2 <span>></span> <span>1</span><span>)</span> <span>{</span>
                <span>// 因为是二进制，所以多余 2 的部分要减去</span>
                res<span>.</span><span>append</span><span>(</span>carry <span>+</span> num1 <span>+</span> num2 <span>-</span> <span>2</span><span>)</span><span>;</span>
                <span>// 表示要进位</span>
                carry <span>=</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                res<span>.</span><span>append</span><span>(</span>carry <span>+</span> num1 <span>+</span> num2<span>)</span><span>;</span>
                carry <span>=</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 对于最高位还要进位的情况，需要单独判断</span>
        <span>if</span> <span>(</span>carry <span>==</span> <span>1</span><span>)</span> <span>{</span>
            res<span>.</span><span>append</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 最后不要忘记再反转一次</span>
        <span>return</span> res<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>addBinary</span><span>(</span>self<span>,</span> a<span>,</span> b<span>)</span><span>:</span>
        <span>"""
        :type a: str
        :type b: str
        :rtype: str
        """</span>
        res <span>=</span> <span>''</span>
        <span># 分别表示两个数从后向前的索引，后对齐</span>
        i <span>=</span> <span>len</span><span>(</span>a<span>)</span> <span>-</span> <span>1</span>
        j <span>=</span> <span>len</span><span>(</span>b<span>)</span> <span>-</span> <span>1</span>
        <span># 表示进位标志</span>
        carry <span>=</span> <span>0</span>
        <span>while</span> i <span>>=</span> <span>0</span> <span>or</span> j <span>>=</span> <span>0</span><span>:</span>
            s <span>=</span> carry
            <span>if</span> i <span>>=</span> <span>0</span><span>:</span>
                s <span>+=</span> <span>ord</span><span>(</span>a<span>[</span>i<span>]</span><span>)</span> <span>-</span> <span>ord</span><span>(</span><span>'0'</span><span>)</span>
                i <span>-=</span> <span>1</span>
            <span>if</span> j <span>>=</span> <span>0</span><span>:</span>
                s <span>+=</span> <span>ord</span><span>(</span>b<span>[</span>j<span>]</span><span>)</span> <span>-</span> <span>ord</span><span>(</span><span>'0'</span><span>)</span>
                j <span>-=</span> <span>1</span>

            res <span>=</span> <span>str</span><span>(</span>s <span>%</span> <span>2</span><span>)</span> <span>+</span> res
            carry <span>=</span> s <span>//</span> <span>2</span>
        <span>if</span> carry <span>==</span> <span>1</span><span>:</span>
            <span>return</span> <span>'1'</span> <span>+</span> res
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 125 题：验证回文串（简单）</title>
    <id>https://suanfa8.com/array/solutions/0125-valid-palindrome/</id>
    <link href="https://suanfa8.com/array/solutions/0125-valid-palindrome/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/valid-palindrome" target="_blank" rel="noopener noreferrer">125. 验证回文串<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>**说明：**本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
解释：&quot;amanaplanacanalpanama&quot; 是回文串
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: &quot;race a car&quot;
输出: false
解释：&quot;raceacar&quot; 不是回文串
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>s</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
<li>字符串 <code>s</code> 由 ASCII 字符组成</li>
</ul>
<h2 id="解题思路"> 解题思路</h2>
<p>使用指针对撞的思想。</p>
<p><strong>参考代码 1</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>/**
     * "A man, a plan, a canal: Panama"
     *
     * @param s
     * @return
     */</span>
    <span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>int</span> index_i <span>=</span> <span>0</span><span>;</span>
        <span>int</span> index_j <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>

        <span>while</span> <span>(</span>index_i <span>&lt;=</span> index_j<span>)</span> <span>{</span>
            <span>String</span> i <span>=</span> s<span>.</span><span>charAt</span><span>(</span>index_i<span>)</span> <span>+</span> <span>""</span><span>;</span>
            <span>String</span> j <span>=</span> s<span>.</span><span>charAt</span><span>(</span>index_j<span>)</span> <span>+</span> <span>""</span><span>;</span>
            <span>if</span> <span>(</span><span>!</span>i<span>.</span><span>matches</span><span>(</span><span>"[0-9a-zA-Z]"</span><span>)</span><span>)</span> <span>{</span>
                index_i<span>++</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span><span>!</span>j<span>.</span><span>matches</span><span>(</span><span>"[0-9a-zA-Z]"</span><span>)</span><span>)</span> <span>{</span>
                index_j<span>--</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span><span>!</span>j<span>.</span><span>equalsIgnoreCase</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                index_i<span>++</span><span>;</span>
                index_j<span>--</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>参考代码 2</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>/**
     * "A man, a plan, a canal: Panama"
     *
     * @param s
     * @return
     */</span>
    <span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>// 去掉非数字和字母</span>
        <span>// 全部转换为小写</span>
        s <span>=</span> s<span>.</span><span>replaceAll</span><span>(</span><span>"[^0-9a-zA-Z]"</span><span>,</span> <span>""</span><span>)</span><span>;</span>
        <span>StringBuilder</span> reverse <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
            reverse<span>.</span><span>append</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> s<span>.</span><span>equalsIgnoreCase</span><span>(</span>reverse<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 136 题：只出现一次的数字（简单）</title>
    <id>https://suanfa8.com/array/solutions/0136-single-number/</id>
    <link href="https://suanfa8.com/array/solutions/0136-single-number/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener noreferrer">136. 只出现一次的数字<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: [2,2,1]
输出: 1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: [4,1,2,1,2]
输出: 4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: nums = [1]
Output: 1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code></li>
<li>Each element in the array appears twice except for one element which appears only once.</li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>singleNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            res <span>^=</span> num<span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>singleNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> res <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            res <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 137 题：只出现一次的数字 II（中等）</title>
    <id>https://suanfa8.com/array/solutions/0137-single-number-ii/</id>
    <link href="https://suanfa8.com/array/solutions/0137-single-number-ii/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/single-number-ii" target="_blank" rel="noopener noreferrer">137. 只出现一次的数字 II<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [2,2,3,2]
输出：3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [0,1,0,1,0,1,99]
输出：99
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>
</ul>
<p>**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>singleNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>int</span> mask <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>32</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> count <span>=</span> <span>0</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>(</span>num <span>&amp;</span> mask<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                    count<span>++</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>if</span> <span>(</span>count <span>%</span> <span>3</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                res <span>|=</span> mask<span>;</span>
            <span>}</span>
            mask <span>&lt;&lt;=</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 189 题：生成旋转数组（中等）</title>
    <id>https://suanfa8.com/array/solutions/0189-rotate-array/</id>
    <link href="https://suanfa8.com/array/solutions/0189-rotate-array/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/rotate-array/description/" target="_blank" rel="noopener noreferrer">189. 旋转数组<i>Content not supported</i></a> 。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<div><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>示例 2:</strong></p>
<div><pre><code>输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释:
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>n</span><span style="margin-right:0.03588em;">g</span><span>t</span><span>h</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.136em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>void</span> <span>rotate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>// [1, 2, 3, 4, 5, 6, 7] 向右旋转 7 位相当于不旋转</span>
        <span>if</span> <span>(</span>k <span>%</span> len <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>

        k <span>=</span> k <span>%</span> len<span>;</span>

        <span>// 第 1 步：前 len - k 位反转</span>
        <span>// 第 2 步：后 k 位反转</span>
        <span>// 第 3 步：整体反转</span>
        <span>reverse</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> len <span>-</span> k <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>reverse</span><span>(</span>nums<span>,</span> len <span>-</span> k<span>,</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>reverse</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>reverse</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> left<span>,</span> <span>int</span> right<span>)</span> <span>{</span>
        <span>while</span> <span>(</span>left <span>&lt;</span> right<span>)</span> <span>{</span>
            <span>swap</span><span>(</span>nums<span>,</span> left<span>,</span> right<span>)</span><span>;</span>
            left<span>++</span><span>;</span>
            right<span>--</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> index1<span>,</span> <span>int</span> index2<span>)</span> <span>{</span>
        <span>int</span> temp <span>=</span> nums<span>[</span>index1<span>]</span><span>;</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>;</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> temp<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>rotate</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>,</span> k<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>None</span><span>:</span>
        <span># 先处理极端情况</span>
        <span>if</span> k <span>%</span> <span>len</span><span>(</span>nums<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>

        k <span>=</span> k <span>%</span> <span>len</span><span>(</span>nums<span>)</span>

        <span># 做下面 3 个逆转动作的时候，注意边界条件</span>
        <span># 技巧就是举具体的例子</span>
        self<span>.</span>__reverse<span>(</span>nums<span>,</span> <span>0</span><span>,</span> <span>len</span><span>(</span>nums<span>)</span> <span>-</span> <span>1</span><span>)</span>
        self<span>.</span>__reverse<span>(</span>nums<span>,</span> <span>0</span><span>,</span> k <span>-</span> <span>1</span><span>)</span>
        self<span>.</span>__reverse<span>(</span>nums<span>,</span> k<span>,</span> <span>len</span><span>(</span>nums<span>)</span> <span>-</span> <span>1</span><span>)</span>

    <span>def</span> <span>__reverse</span><span>(</span>self<span>,</span> nums<span>,</span> index1<span>,</span> index2<span>)</span><span>:</span>
        <span>"""
        将数组 [index1,index2] 区间内的元素进行逆转
        :param nums:
        :param index1:
        :param index2:
        :return:
        """</span>

        <span>while</span> index1 <span>&lt;</span> index2<span>:</span>
            nums<span>[</span>index1<span>]</span><span>,</span> nums<span>[</span>index2<span>]</span> <span>=</span> nums<span>[</span>index2<span>]</span><span>,</span> nums<span>[</span>index1<span>]</span>
            index1 <span>+=</span> <span>1</span>
            index2 <span>-=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="字符串" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 240 题：搜索二维矩阵 II（中等）</title>
    <id>https://suanfa8.com/array/solutions/0240-search-a-2d-matrix-ii/</id>
    <link href="https://suanfa8.com/array/solutions/0240-search-a-2d-matrix-ii/"/>
    <updated>2022-08-08T06:57:46.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener noreferrer">240. 搜索二维矩阵 II<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener noreferrer">减而治之、二分查找<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2toatyu0bj20b60b63yu.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2toaw5ilij20b60b6wet.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 300</code></li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>9</span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>ma</span><span>t</span><span style="margin-right:0.02778em;">r</span><span>i</span><span>x</span><span>[</span><span>i</span><span>]</span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span></li>
<li>每行的所有元素从左到右升序排列</li>
<li>每列的所有元素从上到下升序排列</li>
<li><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.9501em;vertical-align:-0.136em;"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>9</span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.1944em;"></span><span>t</span><span>a</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.03588em;">g</span><span>e</span><span>t</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span>1</span><span><span>0</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>这道题比较容易想到的是还继续利用矩阵中的行和列有序的特性，使用二分查找法。下面介绍的这个方法，我认为是最优解，虽然它的时间复杂度并不是最优。</p>
<ul>
<li>
<p>如果我们要用二分查找法，可以发现，如果一行的开头那个元素就比目标元素大，那么这一行的所有元素，以及行号大于这一行的元素都不在考虑的范围内。</p>
</li>
<li>
<p>我们首先尝试从左上角开始走，发现横着走数值增大，竖着走数值也增大，目标数值这在两个方向上都有可能存在。那如果我们从右上角或者左下角除法，找目标元素，那就不一样了，于是有了下面的“排除法”。</p>
</li>
</ul>
<h2 id="方法一-减而治之"> 方法一：减而治之</h2>
<p>1、如果选择左下角为起点，以下展示了「减治」的过程。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2toazbe5pg21hc0u0jvw.gif" alt="0240-lower-left-corner.gif" loading="lazy"></p>
<p>总结出搜索的规律是：</p>
<ul>
<li>如果当前数比目标元素小，当前列就不可能存在目标值，「指针」就向右移一格（纵坐标加 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>）；</li>
<li>如果当前数比目标元素大，当前行就不可能存在目标值，「指针」就向上移一格（横坐标减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>）。</li>
</ul>
<p>在编码的过程中要注意数组下标越界的问题。</p>
<p><strong>参考代码 1</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>searchMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> rows <span>=</span> matrix<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>rows <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>int</span> cols <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>cols <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>


        <span>// 起点：左下角</span>
        <span>int</span> x <span>=</span> rows <span>-</span> <span>1</span><span>;</span>
        <span>int</span> y <span>=</span> <span>0</span><span>;</span>
        <span>// 不越界的条件是：行大于等于 0，列小于等于 cols - 1</span>
        <span>while</span> <span>(</span>x <span>>=</span> <span>0</span> <span>&amp;&amp;</span> y <span>&lt;</span> cols<span>)</span> <span>{</span>
            <span>// 打开注释，可以用于调试的代码</span>
            <span>// System.out.println("沿途走过的数字：" + matrix[x][y]);</span>
            <span>if</span> <span>(</span>matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>></span> target<span>)</span> <span>{</span>
                x<span>--</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                y<span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>searchMatrix</span><span>(</span>self<span>,</span> matrix<span>,</span> target<span>)</span><span>:</span>
        <span># 特判</span>
        rows <span>=</span> <span>len</span><span>(</span>matrix<span>)</span>
        <span>if</span> rows <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>False</span>

        cols <span>=</span> <span>len</span><span>(</span>matrix<span>[</span><span>0</span><span>]</span><span>)</span>
        <span>if</span> cols <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>False</span>

        <span># 起点：左下角</span>
        x <span>=</span> rows <span>-</span> <span>1</span>
        y <span>=</span> <span>0</span>
        <span># 不越界的条件是：行大于等于 0，列小于等于 cols - 1</span>

        <span>while</span> x <span>>=</span> <span>0</span> <span>and</span> y <span>&lt;</span> cols<span>:</span>
            <span>if</span> matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>></span> target<span>:</span>
                x <span>-=</span> <span>1</span>
            <span>elif</span> matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>&lt;</span> target<span>:</span>
                y <span>+=</span> <span>1</span>
            <span>else</span><span>:</span>
                <span>return</span> <span>True</span>
        <span>return</span> <span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">M</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">M</span></span></span></span> 是这个矩阵的行数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是这个矩阵的列数，我们看到，这种算法是 <strong>不回头</strong> 的，至多走 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7667em;vertical-align:-0.0833em;"></span><span style="margin-right:0.10903em;">M</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 步就能搜索到目标数值，或者判定目标数值在矩阵中不存在；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，算法使用了常数个变量。</li>
</ul>
<p>2、如果选择右上角为起点，以下展示了「减治」的过程。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tob25z2hg21hc0u0aei.gif" alt="0240-top-right-corner.gif" loading="lazy"></p>
<p>总结出「搜索」的规律是：</p>
<ul>
<li>如果当前数比目标元素大，当前列就不可能存在目标值，「指针』就向左移一格（纵坐标减 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>）；</li>
<li>如果当前数比目标元素小，当前行就不可能存在目标值，「指针」就向下移一格（横坐标加 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>）。</li>
</ul>
<p>在编码的过程中同样要注意数组下标越界的问题。</p>
<p><strong>参考代码 2</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>searchMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>// 特判</span>
        <span>int</span> rows <span>=</span> matrix<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>rows <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>int</span> cols <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>cols <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>// 起点：右上角</span>
        <span>int</span> x <span>=</span> <span>0</span><span>;</span>
        <span>int</span> y <span>=</span> cols <span>-</span> <span>1</span><span>;</span>

        <span>// 不越界的条件是：行小于等于 rows - 1，列大于等于 0</span>
        <span>while</span> <span>(</span>x <span>&lt;</span> rows <span>&amp;&amp;</span> y <span>>=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 打开注释，可以用于调试的代码</span>
            <span>// System.out.println("沿途走过的数字：" + matrix[x][y]);</span>
            <span>if</span> <span>(</span>matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>></span> target<span>)</span> <span>{</span>
                y<span>--</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                x<span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>searchMatrix</span><span>(</span>self<span>,</span> matrix<span>,</span> target<span>)</span><span>:</span>
        <span># 特判</span>
        rows <span>=</span> <span>len</span><span>(</span>matrix<span>)</span>
        <span>if</span> rows <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>False</span>

        cols <span>=</span> <span>len</span><span>(</span>matrix<span>[</span><span>0</span><span>]</span><span>)</span>
        <span>if</span> cols <span>==</span> <span>0</span><span>:</span>
            <span>return</span> <span>False</span>

        <span># 起点：右上</span>
        x <span>=</span> <span>0</span>
        y <span>=</span> cols <span>-</span><span>1</span>

        <span># 不越界的条件是：行小于等于 rows - 1，列大于等于 0</span>
        <span>while</span> x <span>&lt;</span> rows <span>and</span> y <span>>=</span> <span>0</span><span>:</span>
            <span>if</span> matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>></span> target<span>:</span>
                y <span>-=</span> <span>1</span>
            <span>elif</span> matrix<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>&lt;</span> target<span>:</span>
                x <span>+=</span> <span>1</span>
            <span>else</span><span>:</span>
                <span>return</span> <span>True</span>
        <span>return</span> <span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<p>（同上）。</p>
<p>说明：这个搜索的过程也可以使用二分查找法加快，时间复杂度优化到 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">M</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.01968em;">l</span><span>o</span><span>n</span><span style="margin-right:0.03588em;">g</span><span style="margin-right:0.10903em;">N</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">MN</span><span>)</span></span></span></span>，但是在编码的时候会稍显麻烦。</p>
<h2 id="方法二-二分查找"> 方法二：二分查找</h2>
<p>二分查找的思想是沿着对角线，行查找一下，列查找一下，如下图。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tob5lii0j20we0lcmzk.jpg" alt="image.png" loading="lazy"></p>
<p>事实上，因为对角线元素的右下方（包括对角线所在的那一行和那一列）的元素都大于等于对角线元素，因此对角线元素也存在一个最大索引，也可以用二分查找定位。</p>
<p><strong>参考代码 3</strong>：
<br></p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>int</span> <span>diagonalBinarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> diagonal<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> left <span>=</span> <span>0</span><span>;</span>
        <span>int</span> right <span>=</span> diagonal<span>;</span>
        <span>while</span> <span>(</span>left <span>&lt;</span> right<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> <span>(</span>left <span>+</span> right<span>)</span> <span>>>></span> <span>1</span><span>;</span>
            <span>if</span> <span>(</span>matrix<span>[</span>mid<span>]</span><span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                right <span>=</span> mid<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> left<span>;</span>
    <span>}</span>

    <span>// 下面两个二分查找没有使用模板，因为只是找一个数，而不是找这个数的边界</span>
    <span>// 用教科书上的二分查找法更简单</span>

    <span>private</span> <span>boolean</span> <span>rowBinarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> begin<span>,</span> <span>int</span> cols<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> left <span>=</span> begin<span>;</span>
        <span>int</span> right <span>=</span> cols<span>;</span>

        <span>while</span> <span>(</span>left <span>&lt;=</span> right<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> <span>(</span>left <span>+</span> right<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>matrix<span>[</span>begin<span>]</span><span>[</span>mid<span>]</span> <span>==</span> target<span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>matrix<span>[</span>begin<span>]</span><span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>colBinarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> begin<span>,</span> <span>int</span> rows<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>// 这里可以 + 1</span>
        <span>int</span> left <span>=</span> begin <span>+</span> <span>1</span><span>;</span>
        <span>int</span> right <span>=</span> rows<span>;</span>

        <span>while</span> <span>(</span>left <span>&lt;=</span> right<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> <span>(</span>left <span>+</span> right<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>matrix<span>[</span>mid<span>]</span><span>[</span>begin<span>]</span> <span>==</span> target<span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>matrix<span>[</span>mid<span>]</span><span>[</span>begin<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                left <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                right <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>searchMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>// 特判</span>
        <span>int</span> rows <span>=</span> matrix<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>rows <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>int</span> cols <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>cols <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>


        <span>int</span> minVal <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>rows<span>,</span> cols<span>)</span><span>;</span>
        <span>// 沿着对角线搜索第 1 个大于等于 target 的数的索引</span>
        <span>int</span> index <span>=</span> <span>diagonalBinarySearch</span><span>(</span>matrix<span>,</span> minVal <span>-</span> <span>1</span><span>,</span> target<span>)</span><span>;</span>
        <span>if</span> <span>(</span>matrix<span>[</span>index<span>]</span><span>[</span>index<span>]</span> <span>==</span> target<span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>// 沿着对角线朝两边搜索</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> index<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 行搜索传入列总数 - 1</span>
            <span>boolean</span> rowSearch <span>=</span> <span>rowBinarySearch</span><span>(</span>matrix<span>,</span> i<span>,</span> cols <span>-</span> <span>1</span><span>,</span> target<span>)</span><span>;</span>
            <span>// 列搜索传入行总数 - 1</span>
            <span>boolean</span> colSearch <span>=</span> <span>colBinarySearch</span><span>(</span>matrix<span>,</span> i<span>,</span> rows <span>-</span> <span>1</span><span>,</span> target<span>)</span><span>;</span>

            <span>if</span> <span>(</span>rowSearch <span>||</span> colSearch<span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br></div></div><p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>min</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">M</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>))</span></span></span></span>，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">M</span></span></span></span> 是这个矩阵的行数，<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是这个矩阵的列数。<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>min</span><span>(</span><span style="margin-right:0.10903em;">M</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span> 是主对角线上元素的个数。</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，算法使用了常数个变量。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="分治算法" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 387 题：字符串中的第一个唯一字符（简单）</title>
    <id>https://suanfa8.com/array/solutions/0387-first-unique-character-in-a-string/</id>
    <link href="https://suanfa8.com/array/solutions/0387-first-unique-character-in-a-string/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string" target="_blank" rel="noopener noreferrer">387. 字符串中的第一个唯一字符<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>Example 1:</strong></p>
<div><pre><code>Input: s = &quot;leetcode&quot;
Output: 0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 2:</strong></p>
<div><pre><code>Input: s = &quot;loveleetcode&quot;
Output: 2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: s = &quot;aabb&quot;
Output: -1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>把数组当做哈希表用。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>firstUniqChar</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> hashMap <span>=</span> <span>new</span> <span>int</span><span>[</span><span>26</span><span>]</span><span>;</span>
        <span>char</span><span>[</span><span>]</span> charArray <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>char</span> c <span>:</span> charArray<span>)</span> <span>{</span>
            hashMap<span>[</span>c <span>-</span> <span>'a'</span><span>]</span><span>++</span><span>;</span>
        <span>}</span>

        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>hashMap<span>[</span>charArray<span>[</span>i<span>]</span> <span>-</span> <span>'a'</span><span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                <span>return</span> i<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 448 题：找到所有数组中消失的数字（简单）</title>
    <id>https://suanfa8.com/array/solutions/0448-find-all-numbers-disappeared-in-an-array/</id>
    <link href="https://suanfa8.com/array/solutions/0448-find-all-numbers-disappeared-in-an-array/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener noreferrer">448. 找到所有数组中消失的数字<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/tong-pai-xu-ji-yu-yi-huo-yun-suan-jiao-huan-liang-/" target="_blank" rel="noopener noreferrer">桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [1,1]
输出：[2]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
</ul>
<p>**进阶：**你能在不使用额外空间且时间复杂度为 <code>O(n)</code> 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p>
<h2 id="桶排序-基于-异或运算-交换两个变量的值-python-代码、java-代码"> 桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）</h2>
<p><strong>思路分析</strong>：</p>
<ul>
<li>比较容易想到的思路是“桶排序”，“桶排序”的思想很简单，“一个萝卜一个坑”，但这道题比较让人头疼的是“不使用额外空间”。</li>
</ul>
<p>“桶排序”的思想，有些地方也把它叫做“抽屉原理”，以下介绍来自“百度百科”之<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fr=aladdin" target="_blank" rel="noopener noreferrer">“抽屉原理”<i>Content not supported</i></a>词条：</p>
<blockquote>
<p>抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。</p>
</blockquote>
<ul>
<li>“桶排序”的子步骤是“交换数组中两个位置的元素”，<strong>如果不使用额外的空间，可以使用“异或运算”代替</strong>。</li>
</ul>
<h3 id="方法一-桶排序-基于-异或运算-交换两个变量的值"> 方法一：桶排序 + 基于“异或运算”交换两个变量的值</h3>
<p>交换两个整数，有两种比较 tricky 的做法。下面给出结论。</p>
<p>“基于异或运算”是因为利用了“异或运算”是不进位的二进制加法。它有如下性质：</p>
<blockquote>
<p>如果 <code>a ^ b = c</code> ，那么 <code>a ^ c = b</code> 与 <code>b ^ c = a</code> 同时成立，利用这一条，可以用于交换两个变量的值。</p>
</blockquote>
<p>于是，交换两个变量的值，例如 <code>a</code> 和 <code>b</code>，不使用第三个变量，有两种不同的方法：</p>
<table>
<thead>
<tr>
<th>基于异或运算</th>
<th>基于加减法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a = a ^ b</code><br><code>b = a ^ b</code><br><code>a = a ^ b</code></td>
<td><code>a = a + b</code><i>Content not supported</i><code>b = a - b</code><i>Content not supported</i><code>a = a - b</code></td>
</tr>
</tbody>
</table>
<p>我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边依次是 <code>a</code>、<code>b</code>、<code>a</code>。</p>
<p><strong>参考代码 1</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>findDisappearedNumbers</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span> <span>&amp;&amp;</span> nums<span>[</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>]</span> <span>!=</span> nums<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>// System.out.println("桶排序以后的数组：" + Arrays.toString(nums));</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span><span>)</span> <span>{</span>
                res<span>.</span><span>add</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
        nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span> <span>^</span> nums<span>[</span>j<span>]</span><span>;</span>
        nums<span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span> <span>^</span> nums<span>[</span>j<span>]</span><span>;</span>
        nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span> <span>^</span> nums<span>[</span>j<span>]</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>findDisappearedNumbers</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>)</span> <span>-</span><span>></span> List<span>[</span><span>int</span><span>]</span><span>:</span>
        size <span>=</span> <span>len</span><span>(</span>nums<span>)</span>

        <span>for</span> i <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
            <span>while</span> nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span><span>:</span>
                <span>if</span> nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>]</span><span>:</span>
                    self<span>.</span>__swap<span>(</span>nums<span>,</span> i<span>,</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>)</span>
                <span>else</span><span>:</span>
                    <span>break</span>

        res <span>=</span> <span>[</span><span>]</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
            <span>if</span> nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span><span>:</span>
                res<span>.</span>append<span>(</span>i <span>+</span> <span>1</span><span>)</span>
        <span>return</span> res

    <span>def</span> <span>__swap</span><span>(</span>self<span>,</span> nums<span>,</span> index1<span>,</span> index2<span>)</span><span>:</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index1<span>]</span> <span>^</span> nums<span>[</span>index2<span>]</span>
        nums<span>[</span>index2<span>]</span> <span>=</span> nums<span>[</span>index1<span>]</span> <span>^</span> nums<span>[</span>index2<span>]</span>
        nums<span>[</span>index1<span>]</span> <span>=</span> nums<span>[</span>index1<span>]</span> <span>^</span> nums<span>[</span>index2<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，这里没有使用额外的空间。</li>
</ul>
<p>说明：同样的思路和技巧，可以解决<a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener noreferrer">「力扣」第 41 题：缺失的第一个正数<i>Content not supported</i></a>。</p>
<h3 id="方法二-位图-使用了-1-个额外空间-不符合题意-该方法仅作了解"> 方法二：位图（使用了 1 个额外空间，不符合题意，该方法仅作了解）</h3>
<p><strong>参考代码 2</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>findDisappearedNumbers</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> map <span>=</span> <span>1</span> <span>&lt;&lt;</span> len<span>;</span>

        <span>// 调试代码</span>
        <span>// System.out.println(Integer.toBinaryString(map));</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            map <span>|=</span> <span>1</span> <span>&lt;&lt;</span> <span>(</span>num <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>// 调试代码</span>
            <span>// System.out.println(Integer.toBinaryString(map));</span>
        <span>}</span>

        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span><span>(</span>map <span>>></span> i<span>)</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                res<span>.</span><span>add</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>from</span> typing <span>import</span> List


<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>findDisappearedNumbers</span><span>(</span>self<span>,</span> nums<span>:</span> List<span>[</span><span>int</span><span>]</span><span>)</span> <span>-</span><span>></span> List<span>[</span><span>int</span><span>]</span><span>:</span>
        size <span>=</span> <span>len</span><span>(</span>nums<span>)</span>

        <span># 位图</span>
        <span>map</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>(</span>size<span>)</span>

        <span># 调试代码</span>
        <span># print(bin(map))</span>

        <span>for</span> num <span>in</span> nums<span>:</span>
            <span>map</span> <span>|</span><span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>(</span>num <span>-</span> <span>1</span><span>)</span>
            <span># 调试代码</span>
            <span># print(bin(map))</span>

        res <span>=</span> <span>[</span><span>]</span>

        <span>for</span> index <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
            <span>if</span> <span>(</span><span>map</span> <span>>></span> index<span>)</span> <span>&amp;</span> <span>1</span> <span>==</span> <span>0</span><span>:</span>
                res<span>.</span>append<span>(</span>index <span>+</span> <span>1</span><span>)</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>，这里 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span></span></span></span> 是数组的长度；</li>
<li>空间复杂度：<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，这里使用了 1 个额外的空间。</li>
</ul>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 836 题：矩形重叠（简单）</title>
    <id>https://suanfa8.com/array/solutions/0836-rectangle-overlap/</id>
    <link href="https://suanfa8.com/array/solutions/0836-rectangle-overlap/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener noreferrer">836. 矩形重叠<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。</p>
<p>如果相交的面积为 <strong>正</strong> ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形 <code>rec1</code> 和 <code>rec2</code> 。如果它们重叠，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>rect1.length == 4</code></li>
<li><code>rect2.length == 4</code></li>
<li><code>-10^9 &lt;= rec1[i], rec2[i] &lt;= 10^9</code></li>
<li><code>rec1</code> 和 <code>rec2</code> 表示一个面积不为零的有效矩形</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>不是这种坐标系：</p>
<div><pre><code>（0,0）（0,1）（0,2）（0,3）

（1,0）（1,1）（1,2）（1,3）

（2,0）（2,1）（2,2）（2,3）

（3,0）（3,1）（3,2）（3,3）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>而是直角坐标系</p>
<div><pre><code>（3,0）（3,1）（3,2）（3,3）

（2,0）（2,1）（2,2）（2,3）

（1,0）（1,1）（1,2）（1,3）

（0,0）（0,1）（0,2）（0,3）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>思路：从判断两条线段是否有交点推广开来。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>boolean</span> <span>isRectangleOverlap</span><span>(</span><span>int</span><span>[</span><span>]</span> rec1<span>,</span> <span>int</span><span>[</span><span>]</span> rec2<span>)</span> <span>{</span>
        <span>boolean</span> rowsOk <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>rec1<span>[</span><span>0</span><span>]</span><span>,</span> rec2<span>[</span><span>0</span><span>]</span><span>)</span> <span>&lt;</span> <span>Math</span><span>.</span><span>min</span><span>(</span>rec1<span>[</span><span>2</span><span>]</span><span>,</span> rec2<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
        <span>boolean</span> colsOk <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>rec1<span>[</span><span>1</span><span>]</span><span>,</span> rec2<span>[</span><span>1</span><span>]</span><span>)</span> <span>&lt;</span> <span>Math</span><span>.</span><span>min</span><span>(</span>rec1<span>[</span><span>3</span><span>]</span><span>,</span> rec2<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
        <span>return</span> rowsOk <span>&amp;&amp;</span> colsOk<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 461 题：汉明距离（简单）</title>
    <id>https://suanfa8.com/array/solutions/0461-hamming-distance/</id>
    <link href="https://suanfa8.com/array/solutions/0461-hamming-distance/"/>
    <updated>2022-01-14T01:51:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/hamming-distance" target="_blank" rel="noopener noreferrer">461. 汉明距离<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" target="_blank" rel="noopener noreferrer">汉明距离<i>Content not supported</i></a> 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：x = 3, y = 1
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= x, y &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>hammingDistance</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
        <span>StringBuilder</span> xx <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>Integer</span><span>.</span><span>toBinaryString</span><span>(</span>x<span>)</span><span>)</span><span>;</span>
        <span>StringBuilder</span> yy <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>Integer</span><span>.</span><span>toBinaryString</span><span>(</span>y<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>xx<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> yy<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>StringBuilder</span> temp <span>=</span> xx<span>;</span>
            xx <span>=</span> yy<span>;</span>
            yy <span>=</span> temp<span>;</span>
        <span>}</span>
        <span>int</span> diff <span>=</span> yy<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> xx<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> diff<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            xx<span>.</span><span>insert</span><span>(</span><span>0</span><span>,</span><span>'0'</span><span>)</span><span>;</span>
        <span>}</span>
        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> yy<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>xx<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>!=</span> yy<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
                sum<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> sum<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Java">
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>hammingDistance</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
        <span>StringBuilder</span> xx <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>Integer</span><span>.</span><span>toBinaryString</span><span>(</span>x<span>)</span><span>)</span><span>;</span>
        <span>StringBuilder</span> yy <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>Integer</span><span>.</span><span>toBinaryString</span><span>(</span>y<span>)</span><span>)</span><span>;</span>

        <span>boolean</span> bothNegative <span>=</span> x <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> y <span>&lt;</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span>bothNegative<span>)</span> <span>{</span>
            <span>// 始终让 xx 是长度比较小的那个字符串，这样补齐总是在 x 的前面补 0</span>
            <span>if</span> <span>(</span>xx<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> yy<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                <span>StringBuilder</span> temp <span>=</span> xx<span>;</span>
                xx <span>=</span> yy<span>;</span>
                yy <span>=</span> temp<span>;</span>
            <span>}</span>
            <span>int</span> diff <span>=</span> yy<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> xx<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> diff<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                xx<span>.</span><span>insert</span><span>(</span><span>0</span><span>,</span> <span>'0'</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> yy<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>xx<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>!=</span> yy<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
                sum<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> sum<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></CodeGroupItem>
</CodeGroup>
```
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="数组" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:03:02.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 239 题：滑动窗口的最大值（困难）</title>
    <id>https://suanfa8.com/queue/solutions/0239-sliding-window-maximum/</id>
    <link href="https://suanfa8.com/queue/solutions/0239-sliding-window-maximum/"/>
    <updated>2022-01-13T14:54:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目地址：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">239. 滑动窗口最大值<i>Content not supported</i></a>；</li>
<li>题解地址：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/zui-da-suo-yin-dui-shuang-duan-dui-lie-cun-suo-yin/" target="_blank" rel="noopener noreferrer">最大索引堆 + 双端队列存索引值的思路分析（Python 代码、Java 代码）<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：nums = [1], k = 1
输出：[1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：nums = [1,-1], k = 1
输出：[1,-1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4：</strong></p>
<div><pre><code>输入：nums = [9,11], k = 2
输出：[11]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 5：</strong></p>
<div><pre><code>输入：nums = [4,-2], k = 2
输出：[4]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<hr>
<p>文字题解和参考代码请见：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/zui-da-suo-yin-dui-shuang-duan-dui-lie-cun-suo-yin/" target="_blank" rel="noopener noreferrer">最大索引堆 + 双端队列存索引值的思路分析（Python 代码、Java 代码）<i>Content not supported</i></a>。</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:02:31.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 621 题：任务调度器（中等）</title>
    <id>https://suanfa8.com/queue/solutions/0621-task-scheduler/</id>
    <link href="https://suanfa8.com/queue/solutions/0621-task-scheduler/"/>
    <updated>2022-01-13T14:54:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener noreferrer">621. 任务调度器<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2
输出：8
解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]
[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]
[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]
...
诸如此类
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2
输出：16
解释：一种可能的解决方案是：
     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= task.length &lt;= 104</code></li>
<li><code>tasks[i]</code> 是大写英文字母</li>
<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Comparator</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>PriorityQueue</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>int</span> <span>leastInterval</span><span>(</span><span>char</span><span>[</span><span>]</span> tasks<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> count <span>=</span> <span>new</span> <span>int</span><span>[</span><span>26</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>char</span> task <span>:</span> tasks<span>)</span> <span>{</span>
            count<span>[</span>task <span>-</span> <span>'A'</span><span>]</span><span>++</span><span>;</span>
        <span>}</span>

        <span>// 最大堆</span>
        <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> maxHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>26</span><span>,</span> <span>Comparator</span><span>.</span><span>reverseOrder</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>26</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 把次数大于 0 的任务加入最大堆</span>
            <span>if</span> <span>(</span>count<span>[</span>i<span>]</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
                maxHeap<span>.</span><span>offer</span><span>(</span>count<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>// 依次拿出执行次数最多的任务</span>
        <span>int</span> res <span>=</span> <span>0</span><span>;</span>
        <span>// 临时队列，用于存放需要冷却的任务</span>
        <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>maxHeap<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>// 注意：这里是 n + 1，即在 n + 1 个时间单位内，不能有重复任务</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n <span>+</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>!</span>maxHeap<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                    <span>int</span> front <span>=</span> maxHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                    <span>if</span> <span>(</span>front <span>></span> <span>1</span><span>)</span> <span>{</span>
                        <span>// 因为完成了一个任务，接下来还有 front - 1 次任务</span>
                        queue<span>.</span><span>add</span><span>(</span>front <span>-</span> <span>1</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                res<span>++</span><span>;</span>
                <span>if</span> <span>(</span>maxHeap<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>

            <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                maxHeap<span>.</span><span>offer</span><span>(</span>queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="广度优先遍历" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:02:31.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 622 题：设计循环队列（中等）</title>
    <id>https://suanfa8.com/queue/solutions/0622-design-circular-queue/</id>
    <link href="https://suanfa8.com/queue/solutions/0622-design-circular-queue/"/>
    <updated>2022-01-13T14:54:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener noreferrer">622. 设计循环队列<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/design-circular-queue/solution/shu-zu-shi-xian-de-xun-huan-dui-lie-by-liweiwei141/" target="_blank" rel="noopener noreferrer">数组实现的循环队列<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>
<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>
<li><code>isFull()</code>: 检查循环队列是否已满。</li>
</ul>
<p><strong>示例：</strong></p>
<div><pre><code>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>所有的值都在 0 至 1000 的范围内；</li>
<li>操作数将在 1 至 1000 的范围内；</li>
<li>请不要使用内置的队列库。</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>这道题说「循环」的意思是要求我们在数组里实现。使用链表的实现，创建结点和删除结点都是动态的，也就不存在需要循环利用的问题了。</p>
<p>在数组里的操作，我们参考「动态数组」的实现，是为了让每一步的操作复杂度都最低。</p>
<p>「<code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 <code>k</code> 」，这句话说明：题目 <strong>不要求我们实现动态扩容与动态缩容</strong>。</p>
<hr>
<p><strong>需要注意的地方</strong>：</p>
<ol>
<li>定义循环变量 <code>front</code> 和 <code>rear</code> 。一直保持这个定义，到底是先赋值还是先移动指针就很容易想清楚了。</li>
</ol>
<p><code>front</code>：指向队列头部第 1 个有效数据的位置；
<code>rear</code>：指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。</p>
<p>（说明：这个定义是依据“动态数组”的定义模仿而来。）</p>
<ol start="2">
<li><strong>为了避免「队列为空」和「队列为满」的判别条件冲突，我们有意浪费了一个位置。</strong></li>
</ol>
<p>浪费一个位置是指：循环数组中任何时刻一定至少有一个位置不存放有效元素。</p>
<ul>
<li>判别队列为空的条件是：<code>front == rear;</code></li>
<li>判别队列为满的条件是：<code>(rear + 1) % capacity == front;</code>。可以这样理解，当 <code>rear</code> 循环到数组的前面，要从后面追上 <code>front</code>，还差一格的时候，判定队列为满。</li>
</ul>
<ol start="3">
<li>因为有循环的出现，要特别注意处理数组下标可能越界的情况。指针后移的时候，下标 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>+</span><span>1</span></span></span></span>，并且为了防止数组下标越界要取模。</li>
</ol>
<Presentation id="presentation-64a56fec" data-code="%0A!%5B622-1.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F97e132e91a9db2ea1d6312f2bd996a100118604aa5efbf0e5c5c3c5a8a1b1c67-622-1.png)%0A%0A---%0A%0A!%5B622-2.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F8b716e72ad320ec867b174ceee042938db0159037ba06856b559acba415ae23b-622-2.png)%0A%0A---%0A%0A!%5B622-3.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F8c6f3aa490dd1252fec2432872427480bb6cdf6af43aca1d2f7f725616e56621-622-3.png)%0A%0A---%0A%0A!%5B622-4.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fd321064db6a8a0330cf859b8a978ef2ac635c1b0e9966095f50241737820ccef-622-4.png)%0A%0A---%0A%0A!%5B622-5.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fc306546646991bab8cb72d3cb30791b2f86df0ba46682d70b1cd083f5da31a95-622-5.png)%0A%0A---%0A%0A!%5B622-6.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fa6e70d6116d32806d74d5f70fc77caedf488473b7d68680c9dd7281334fa7b62-622-6.png)%0A%0A---%0A%0A!%5B622-7.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2Fcc20c68a7ad2b7a51e719d9c039b0380e68215d4a7d86867b1a17ee87af240ec-622-7.png)%0A%0A---%0A%0A!%5B622-8.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F46ca7de89cc94295ff692eca246558dd31134fbe92d02adaac28b0a7b8e2041c-622-8.png)%0A%0A---%0A%0A!%5B622-9.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F6a03091f66c4555b26aa5e8e0dca59618aa465381c96fda11cee27c0872d5a0a-622-9.png)%0A%0A---%0A%0A!%5B622-10.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F3e060bfce0e82ebd1f81e0b2974cf00523180e5b5d3f73b10a38cd24a307e4c0-622-10.png)%0A%0A---%0A%0A!%5B622-11.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F9aa511407d8d5a11df28b8d0321c722f164dd49b35b883ca5fcdbad508a67f01-622-11.png)%0A%0A---%0A%0A!%5B622-12.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F3d09cbe788369460e49daf5c7f6d10f62416d4b50a3debef916c3b903045bdaa-622-12.png)%0A%0A---%0A%0A!%5B622-13.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F908f818978673a7bf2ee24c67cddaa5bc20ed080de9eda0f88f9d5d14d1866fb-622-13.png)%0A%0A---%0A%0A!%5B622-14.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F877f22165e8849663fd066aa2668e07d3e159e644ef11ee817f0235a4cad742c-622-14.png)%0A" theme="auto"></Presentation><p>同类问题「力扣」第 641 题：<a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener noreferrer">设计循环双端队列<i>Content not supported</i></a> 可以顺便做一下。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>MyCircularQueue</span> <span>{</span>

    <span>private</span> <span>int</span> front<span>;</span>
    <span>private</span> <span>int</span> rear<span>;</span>
    <span>private</span> <span>int</span> capacity<span>;</span>
    <span>private</span> <span>int</span><span>[</span><span>]</span> arr<span>;</span>

    <span>/**
     * Initialize your data structure here. Set the size of the queue to be k.
     */</span>
    <span>public</span> <span>MyCircularQueue</span><span>(</span><span>int</span> k<span>)</span> <span>{</span>
        capacity <span>=</span> k <span>+</span> <span>1</span><span>;</span>
        arr <span>=</span> <span>new</span> <span>int</span><span>[</span>capacity<span>]</span><span>;</span>

        <span>// 在 front 出队，故设计在数组的头部，方便删除元素</span>
        <span>// 删除元素的时候，只索引 +1（注意取模）</span>


        <span>// 在 rear 入队，故设计在数组的尾部，方便插入元素</span>
        <span>// 插入元素的时候，先赋值，后索引 +1（注意取模）</span>
        front <span>=</span> <span>0</span><span>;</span>
        rear <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * Insert an element into the circular queue. Return true if the operation is successful.
     */</span>
    <span>public</span> <span>boolean</span> <span>enQueue</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isFull</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        arr<span>[</span>rear<span>]</span> <span>=</span> value<span>;</span>
        rear <span>=</span> <span>(</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> capacity<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * Delete an element from the circular queue. Return true if the operation is successful.
     */</span>
    <span>public</span> <span>boolean</span> <span>deQueue</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        front <span>=</span> <span>(</span>front <span>+</span> <span>1</span><span>)</span> <span>%</span> capacity<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * Get the front item from the queue.
     */</span>
    <span>public</span> <span>int</span> <span>Front</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> arr<span>[</span>front<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * Get the last item from the queue.
     */</span>
    <span>public</span> <span>int</span> <span>Rear</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> arr<span>[</span><span>(</span>rear <span>-</span> <span>1</span> <span>+</span> capacity<span>)</span> <span>%</span> capacity<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * Checks whether the circular queue is empty or not.
     */</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> front <span>==</span> rear<span>;</span>
    <span>}</span>

    <span>/**
     * Checks whether the circular queue is full or not.
     */</span>
    <span>public</span> <span>boolean</span> <span>isFull</span><span>(</span><span>)</span> <span>{</span>
        <span>// 注意：这是这个经典设计的原因</span>
        <span>return</span> <span>(</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> capacity <span>==</span> front<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>MyCircularQueue</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> k<span>:</span> <span>int</span><span>)</span><span>:</span>
        <span>"""
        Initialize your data structure here. Set the size of the queue to be k.
        """</span>
        self<span>.</span>front <span>=</span> <span>0</span>
        self<span>.</span>rear <span>=</span> <span>0</span>
        self<span>.</span>capacity <span>=</span> k <span>+</span> <span>1</span>
        self<span>.</span>arr <span>=</span> <span>[</span><span>0</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>self<span>.</span>capacity<span>)</span><span>]</span>

    <span>def</span> <span>enQueue</span><span>(</span>self<span>,</span> value<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Insert an element into the circular queue. Return true if the operation is successful.
        """</span>
        <span>if</span> self<span>.</span>isFull<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>False</span>
        self<span>.</span>arr<span>[</span>self<span>.</span>rear<span>]</span> <span>=</span> value
        self<span>.</span>rear <span>=</span> <span>(</span>self<span>.</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> self<span>.</span>capacity
        <span>return</span> <span>True</span>

    <span>def</span> <span>deQueue</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Delete an element from the circular queue. Return true if the operation is successful.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>False</span>

        self<span>.</span>front <span>=</span> <span>(</span>self<span>.</span>front <span>+</span> <span>1</span><span>)</span> <span>%</span> self<span>.</span>capacity
        <span>return</span> <span>True</span>

    <span>def</span> <span>Front</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>"""
        Get the front item from the queue.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>-</span><span>1</span>
        <span>return</span> self<span>.</span>arr<span>[</span>self<span>.</span>front<span>]</span>

    <span>def</span> <span>Rear</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>"""
        Get the last item from the queue.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>-</span><span>1</span>
        <span>return</span> self<span>.</span>arr<span>[</span><span>(</span>self<span>.</span>rear <span>-</span> <span>1</span> <span>+</span> self<span>.</span>capacity<span>)</span> <span>%</span> self<span>.</span>capacity<span>]</span>

    <span>def</span> <span>isEmpty</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Checks whether the circular queue is empty or not.
        """</span>
        <span>return</span> self<span>.</span>front <span>==</span> self<span>.</span>rear

    <span>def</span> <span>isFull</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Checks whether the circular queue is full or not.
        """</span>
        <span>return</span> <span>(</span>self<span>.</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> self<span>.</span>capacity <span>==</span> self<span>.</span>front
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="C++">
<div><pre><code>#include &lt;vector&gt;

using namespace std;

class MyCircularQueue {

private:
vector&lt;int&gt; arr;
int front;
int rear;
int capacity;

public:
/\*_ Initialize your data structure here. Set the size of the queue to be k. _/
MyCircularQueue(int k) {
capacity = k + 1;
arr.assign(capacity, 0);

        front = 0;
        rear = 0;
    }

    /** Insert an element into the circular queue. Return true if the operation is successful. */
    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        arr[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    /** Delete an element from the circular queue. Return true if the operation is successful. */
    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    /** Get the front item from the queue. */
    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }

    /** Get the last item from the queue. */
    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return arr[(rear - 1 + capacity) % capacity];
    }

    /** Checks whether the circular queue is empty or not. */
    bool isEmpty() {
        return front == rear;
    }

    /** Checks whether the circular queue is full or not. */
    bool isFull() {
        // 注意：这是这个经典设计的原因
        return (rear + 1) % capacity == front;
    }

};

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div></CodeGroupItem>
</CodeGroup>
```
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:02:31.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 630 题：课程表 III（困难）</title>
    <id>https://suanfa8.com/queue/solutions/0630-course-schedule-iii/</id>
    <link href="https://suanfa8.com/queue/solutions/0630-course-schedule-iii/"/>
    <updated>2022-01-13T14:54:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/course-schedule-iii/" target="_blank" rel="noopener noreferrer">630. 课程表 III<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code> 编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [durationi, lastDayi]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>durationi</code> 天课，并且必须在不晚于 <code>lastDayi</code> 的时候完成。</p>
<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>
<p>返回你最多可以修读的课程数目。</p>
<p><strong>示例 1：</strong></p>
<div><pre><code>输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出：3
解释：
这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。
第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：courses = [[1,2]]
输出：1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：courses = [[3,2],[4,3]]
输出：0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= courses.length &lt;= 104</code></li>
<li><code>1 &lt;= durationi, lastDayi &lt;= 104</code></li>
</ul>
<hr>
<p>参考资料 1：https://blog.csdn.net/sinat_14826343/article/details/73739638</p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:02:31.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 641 题：设计循环双端队列（中等）</title>
    <id>https://suanfa8.com/queue/solutions/0641-design-circular-deque/</id>
    <link href="https://suanfa8.com/queue/solutions/0641-design-circular-deque/"/>
    <updated>2022-01-13T14:54:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener noreferrer">641. 设计循环双端队列<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/design-circular-deque/solution/shu-zu-shi-xian-de-xun-huan-shuang-duan-dui-lie-by/" target="_blank" rel="noopener noreferrer">数组实现的循环双端队列<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>设计实现双端队列。
你的实现需要支持以下操作：</p>
<ul>
<li>MyCircularDeque(k)：构造函数,双端队列的大小为 k。</li>
<li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li>
<li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li>
<li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li>
<li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li>
<li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li>
<li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li>
<li>isEmpty()：检查双端队列是否为空。</li>
<li>isFull()：检查双端队列是否满了。</li>
</ul>
<p><strong>示例：</strong></p>
<div><pre><code>MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>所有值的范围为 [1, 1000]</li>
<li>操作次数的范围为 [1, 1000]</li>
<li>请不要使用内置的双端队列库。</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>这道题的前导问题是「力扣」第 622 题：<a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener noreferrer">设计循环队列<i>Content not supported</i></a>。</p>
<p>在实现上几乎是一模一样的，要注意的地方有：</p>
<ol>
<li>定义循环变量 <code>front</code> 和 <code>rear</code> 。一直保持这个定义，到底是先赋值还是先移动指针就很容易想清楚了。</li>
</ol>
<ul>
<li><code>front</code>：指向队列头部第 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 个有效数据的位置；</li>
<li><code>rear</code>：指向队列尾部（即最后 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 个有效数据）的 <strong>下一个位置</strong>，即下一个从队尾入队元素的位置。</li>
</ul>
<p><strong>说明</strong>：这个定义是依据「动态数组」的定义模仿而来。</p>
<ol start="2">
<li><strong>为了避免「队列为空」和「队列为满」的判别条件冲突，我们有意浪费了一个位置</strong>；</li>
</ol>
<p>浪费一个位置是指：循环数组中任何时刻一定至少有一个位置不存放有效元素。</p>
<ul>
<li>判别队列为空的条件是：<code>front == rear;</code>；</li>
<li>判别队列为满的条件是：<code>(rear + 1) % capacity == front;</code>。可以这样理解，当 <code>rear</code> 循环到数组的前面，要从后面追上 <code>front</code>，还差一格的时候，判定队列为满。</li>
</ul>
<ol start="3">
<li>因为有循环的出现，要特别注意处理数组下标可能越界的情况。</li>
</ol>
<ul>
<li>指针后移的时候，下标 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>+</span><span>1</span></span></span></span>，要取模；</li>
<li>指针前移的时候，为了循环到数组的末尾，需要先加上数组的长度，然后再对数组长度取模。</li>
</ul>
<Presentation id="presentation-64a56f74" data-code="%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%871.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-ARtfWP-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25871.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%872.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-NICWfH-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25872.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%873.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-tNIADj-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25873.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%874.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-sYopKa-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25874.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%875.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-yNAqJF-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25875.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%876.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-XhxXkp-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25876.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%877.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-EYVuUX-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25877.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%878.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-wVOHYx-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25878.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%879.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-yWeAuy-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%25879.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8710.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-dlaMTI-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258710.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8711.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-XzUgOO-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258711.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8712.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-wGqQuD-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258712.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8713.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-nHFtan-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258713.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8714.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-POFCwU-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258714.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8715.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-BwNcsi-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258715.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8716.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-ZbWxyF-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258716.png)%0A%0A---%0A%0A!%5B%E5%B9%BB%E7%81%AF%E7%89%8717.png%5D(https%3A%2F%2Fpic.leetcode-cn.com%2F1608007455-EAfGwZ-%25E5%25B9%25BB%25E7%2581%25AF%25E7%2589%258717.png)%0A" theme="auto"></Presentation><p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>public</span> <span>class</span> <span>MyCircularDeque</span> <span>{</span>

    <span>// 1、不用设计成动态数组，使用静态数组即可</span>
    <span>// 2、设计 head 和 tail 指针变量</span>
    <span>// 3、head == tail 成立的时候表示队列为空</span>
    <span>// 4、tail + 1 == head</span>

    <span>private</span> <span>int</span> capacity<span>;</span>
    <span>private</span> <span>int</span><span>[</span><span>]</span> arr<span>;</span>
    <span>private</span> <span>int</span> front<span>;</span>
    <span>private</span> <span>int</span> rear<span>;</span>

    <span>/**
     * Initialize your data structure here. Set the size of the deque to be k.
     */</span>
    <span>public</span> <span>MyCircularDeque</span><span>(</span><span>int</span> k<span>)</span> <span>{</span>
        capacity <span>=</span> k <span>+</span> <span>1</span><span>;</span>
        arr <span>=</span> <span>new</span> <span>int</span><span>[</span>capacity<span>]</span><span>;</span>

        <span>// 头部指向第 1 个存放元素的位置</span>
        <span>// 插入时，先减，再赋值</span>
        <span>// 删除时，索引 +1（注意取模）</span>
        front <span>=</span> <span>0</span><span>;</span>
        <span>// 尾部指向下一个插入元素的位置</span>
        <span>// 插入时，先赋值，再加</span>
        <span>// 删除时，索引 -1（注意取模）</span>
        rear <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * Adds an item at the front of Deque. Return true if the operation is successful.
     */</span>
    <span>public</span> <span>boolean</span> <span>insertFront</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isFull</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        front <span>=</span> <span>(</span>front <span>-</span> <span>1</span> <span>+</span> capacity<span>)</span> <span>%</span> capacity<span>;</span>
        arr<span>[</span>front<span>]</span> <span>=</span> value<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * Adds an item at the rear of Deque. Return true if the operation is successful.
     */</span>
    <span>public</span> <span>boolean</span> <span>insertLast</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isFull</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        arr<span>[</span>rear<span>]</span> <span>=</span> value<span>;</span>
        rear <span>=</span> <span>(</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> capacity<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * Deletes an item from the front of Deque. Return true if the operation is successful.
     */</span>
    <span>public</span> <span>boolean</span> <span>deleteFront</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>// front 被设计在数组的开头，所以是 +1</span>
        front <span>=</span> <span>(</span>front <span>+</span> <span>1</span><span>)</span> <span>%</span> capacity<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * Deletes an item from the rear of Deque. Return true if the operation is successful.
     */</span>
    <span>public</span> <span>boolean</span> <span>deleteLast</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>// rear 被设计在数组的末尾，所以是 -1</span>
        rear <span>=</span> <span>(</span>rear <span>-</span> <span>1</span> <span>+</span> capacity<span>)</span> <span>%</span> capacity<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * Get the front item from the deque.
     */</span>
    <span>public</span> <span>int</span> <span>getFront</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> arr<span>[</span>front<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * Get the last item from the deque.
     */</span>
    <span>public</span> <span>int</span> <span>getRear</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>// 当 rear 为 0 时防止数组越界</span>
        <span>return</span> arr<span>[</span><span>(</span>rear <span>-</span> <span>1</span> <span>+</span> capacity<span>)</span> <span>%</span> capacity<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * Checks whether the circular deque is empty or not.
     */</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> front <span>==</span> rear<span>;</span>
    <span>}</span>

    <span>/**
     * Checks whether the circular deque is full or not.
     */</span>
    <span>public</span> <span>boolean</span> <span>isFull</span><span>(</span><span>)</span> <span>{</span>
        <span>// 注意：这个设计是非常经典的做法</span>
        <span>return</span> <span>(</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> capacity <span>==</span> front<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>class</span> <span>MyCircularDeque</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> k<span>:</span> <span>int</span><span>)</span><span>:</span>
        <span>"""
        Initialize your data structure here. Set the size of the deque to be k.
        """</span>
        self<span>.</span>front <span>=</span> <span>0</span>
        self<span>.</span>rear <span>=</span> <span>0</span>
        self<span>.</span>capacity <span>=</span> k <span>+</span> <span>1</span>
        self<span>.</span>arr <span>=</span> <span>[</span><span>0</span> <span>for</span> _ <span>in</span> <span>range</span><span>(</span>self<span>.</span>capacity<span>)</span><span>]</span>

    <span>def</span> <span>insertFront</span><span>(</span>self<span>,</span> value<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Adds an item at the front of Deque. Return true if the operation is successful.
        """</span>
        <span>if</span> self<span>.</span>isFull<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>False</span>
        self<span>.</span>front <span>=</span> <span>(</span>self<span>.</span>front <span>-</span> <span>1</span> <span>+</span> self<span>.</span>capacity<span>)</span> <span>%</span> self<span>.</span>capacity
        self<span>.</span>arr<span>[</span>self<span>.</span>front<span>]</span> <span>=</span> value
        <span>return</span> <span>True</span>

    <span>def</span> <span>insertLast</span><span>(</span>self<span>,</span> value<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Adds an item at the rear of Deque. Return true if the operation is successful.
        """</span>
        <span>if</span> self<span>.</span>isFull<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>False</span>
        self<span>.</span>arr<span>[</span>self<span>.</span>rear<span>]</span> <span>=</span> value
        self<span>.</span>rear <span>=</span> <span>(</span>self<span>.</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> self<span>.</span>capacity
        <span>return</span> <span>True</span>

    <span>def</span> <span>deleteFront</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Deletes an item from the front of Deque. Return true if the operation is successful.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>False</span>
        self<span>.</span>front <span>=</span> <span>(</span>self<span>.</span>front <span>+</span> <span>1</span><span>)</span> <span>%</span> self<span>.</span>capacity
        <span>return</span> <span>True</span>

    <span>def</span> <span>deleteLast</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Deletes an item from the rear of Deque. Return true if the operation is successful.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>False</span>
        self<span>.</span>rear <span>=</span> <span>(</span>self<span>.</span>rear <span>-</span> <span>1</span> <span>+</span> self<span>.</span>capacity<span>)</span> <span>%</span> self<span>.</span>capacity<span>;</span>
        <span>return</span> <span>True</span>

    <span>def</span> <span>getFront</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>"""
        Get the front item from the deque.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>-</span><span>1</span>
        <span>return</span> self<span>.</span>arr<span>[</span>self<span>.</span>front<span>]</span>

    <span>def</span> <span>getRear</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>"""
        Get the last item from the deque.
        """</span>
        <span>if</span> self<span>.</span>isEmpty<span>(</span><span>)</span><span>:</span>
            <span>return</span> <span>-</span><span>1</span>
        <span>return</span> self<span>.</span>arr<span>[</span><span>(</span>self<span>.</span>rear <span>-</span> <span>1</span> <span>+</span> self<span>.</span>capacity<span>)</span> <span>%</span> self<span>.</span>capacity<span>]</span>

    <span>def</span> <span>isEmpty</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Checks whether the circular deque is empty or not.
        """</span>
        <span>return</span> self<span>.</span>front <span>==</span> self<span>.</span>rear

    <span>def</span> <span>isFull</span><span>(</span>self<span>)</span> <span>-</span><span>></span> <span>bool</span><span>:</span>
        <span>"""
        Checks whether the circular deque is full or not.
        """</span>
        <span>return</span> <span>(</span>self<span>.</span>rear <span>+</span> <span>1</span><span>)</span> <span>%</span> self<span>.</span>capacity <span>==</span> self<span>.</span>front
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="C++">
```C++
#include <iostream>
#include <vector>
<p>using namespace std;</p>
<p>class MyCircularDeque {</p>
<p>private:
vector<int> arr;
int front;
int rear;
int capacity;</p>
<p>public:
/*_ Initialize your data structure here. Set the size of the deque to be k. _/
MyCircularDeque(int k) {
capacity = k + 1;
arr.assign(capacity, 0);</p>
<div><pre><code>    front = 0;
    rear = 0;
}

/** Adds an item at the front of Deque. Return true if the operation is successful. */
bool insertFront(int value) {
    if (isFull()) {
        return false;
    }
    front = (front - 1 + capacity) % capacity;
    arr[front] = value;
    return true;
}

/** Adds an item at the rear of Deque. Return true if the operation is successful. */
bool insertLast(int value) {
    if (isFull()) {
        return false;
    }
    arr[rear] = value;
    rear = (rear + 1) % capacity;
    return true;
}

/** Deletes an item from the front of Deque. Return true if the operation is successful. */
bool deleteFront() {
    if (isEmpty()) {
        return false;
    }
    // front 被设计在数组的开头，所以是 +1
    front = (front + 1) % capacity;
    return true;
}

/** Deletes an item from the rear of Deque. Return true if the operation is successful. */
bool deleteLast() {
    if (isEmpty()) {
        return false;
    }
    // rear 被设计在数组的末尾，所以是 -1
    rear = (rear - 1 + capacity) % capacity;
    return true;
}

/** Get the front item from the deque. */
int getFront() {
    if (isEmpty()) {
        return -1;
    }
    return arr[front];
}

/** Get the last item from the deque. */
int getRear() {
    if (isEmpty()) {
        return -1;
    }
    // 当 rear 为 0 时防止数组越界
    return arr[(rear - 1 + capacity) % capacity];
}

/** Checks whether the circular deque is empty or not. */
bool isEmpty() {
    return front == rear;
}

/** Checks whether the circular deque is full or not. */
bool isFull() {
    // 注意：这个设计是非常经典的做法
    return (rear + 1) % capacity == front;
}
</code></pre>
</div><p>};</p>
<p>/**</p>
<ul>
<li>Your MyCircularDeque object will be instantiated and called as such:</li>
<li>MyCircularDeque* obj = new MyCircularDeque(k);</li>
<li>bool param_1 = obj-&gt;insertFront(value);</li>
<li>bool param_2 = obj-&gt;insertLast(value);</li>
<li>bool param_3 = obj-&gt;deleteFront();</li>
<li>bool param_4 = obj-&gt;deleteLast();</li>
<li>int param_5 = obj-&gt;getFront();</li>
<li>int param_6 = obj-&gt;getRear();</li>
<li>bool param_7 = obj-&gt;isEmpty();</li>
<li>bool param_8 = obj-&gt;isFull();
*/</li>
</ul>
<div><pre><code>&lt;/CodeGroupItem&gt;
&lt;/CodeGroup&gt;


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:02:31.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 933 题：最近的请求次数（简单）</title>
    <id>https://suanfa8.com/queue/solutions/0933-number-of-recent-calls/</id>
    <link href="https://suanfa8.com/queue/solutions/0933-number-of-recent-calls/"/>
    <updated>2022-01-13T14:54:23.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/number-of-recent-calls/" target="_blank" rel="noopener noreferrer">933. 最近的请求次数<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/number-of-recent-calls/solution/jie-shi-yi-xia-ti-yi-by-liweiwei1419/" target="_blank" rel="noopener noreferrer">解释一下题意<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>写一个 <code>RecentCounter</code> 类来计算特定时间范围内最近的请求。</p>
<p>请你实现 <code>RecentCounter</code> 类：</p>
<ul>
<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>
<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>
</ul>
<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>
<p><strong>示例：</strong></p>
<div><pre><code>输入：
[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= t &lt;= 10^9</code></li>
<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>
<li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>解释一下示例：</p>
<div><pre><code>示例：

输入：inputs = [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;],
     inputs = [[],[1],[100],[3001],[3002]]
输出：[null,1,2,3,3]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>1、输入两个都叫 <code>inputs</code> 不用管，上下行是对应的；</p>
<p>2、<code>RecentCounter</code> 表示初始化计数器，因此什么都不操作，对应 <code>[]</code>；</p>
<p>3、然后底下的 <code>[1],[100],[3001],[3002]</code> 表示在 1 毫秒、100 毫秒、3001 毫秒、3002 毫秒这些时刻分别执行了一次 ping 操作；</p>
<p>4、计时从 0 毫秒开始，“任何处于 <code>[t - 3000, t]</code> 时间范围之内”这句话的意思是，从当前时刻 <code>t</code> 开始算起，3000 毫秒之前到现在执行的 ping 操作总数，要求我们统计出来；</p>
<p>5、<code>t - 3000 &lt; 0</code> 的时候怎么办？就返回从 0 时刻到 3000 毫秒时刻执行的 ping 的操作总次数。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>public</span> <span>class</span> <span>RecentCounter</span> <span>{</span>

    <span>private</span> <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue<span>;</span>

    <span>public</span> <span>RecentCounter</span><span>(</span><span>)</span> <span>{</span>
        queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>ping</span><span>(</span><span>int</span> t<span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> t <span>-</span> queue<span>.</span><span>peek</span><span>(</span><span>)</span> <span>></span> <span>3000</span><span>)</span> <span>{</span>
            queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        queue<span>.</span><span>offer</span><span>(</span>t<span>)</span><span>;</span>
        <span>return</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>from</span> collections <span>import</span> deque


<span>class</span> <span>RecentCounter</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>queue <span>=</span> deque<span>(</span><span>)</span>

    <span>def</span> <span>ping</span><span>(</span>self<span>,</span> t<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>while</span> self<span>.</span>queue <span>and</span> t <span>-</span> self<span>.</span>queue<span>[</span><span>0</span><span>]</span> <span>></span> <span>3000</span><span>:</span>
            self<span>.</span>queue<span>.</span>popleft<span>(</span><span>)</span>
        self<span>.</span>queue<span>.</span>append<span>(</span>t<span>)</span>
        <span>return</span> <span>len</span><span>(</span>self<span>.</span>queue<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="C++">
```C++
#include <iostream>
#include <queue>
#include <vector>
<p>using namespace std;</p>
<p>class RecentCounter {
private:
queue<int> q;
public:
RecentCounter() {</p>
<div><pre><code>}

int ping(int t) {
    while (!q.empty() &amp;&amp; t - q.front() &gt; 3000) {
        q.pop();
    }
    q.push(t);

    return q.size();
}
</code></pre>
</div><p>};</p>
<div><pre><code>&lt;/CodeGroupItem&gt;
&lt;/CodeGroup&gt;



</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="队列" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:02:31.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 102 题：二叉树的层次遍历</title>
    <id>https://suanfa8.com/tree/solutions/0102-binary-tree-level-order-traversal/</id>
    <link href="https://suanfa8.com/tree/solutions/0102-binary-tree-level-order-traversal/"/>
    <updated>2022-01-13T16:20:05.000Z</updated>
    <content type="html"><![CDATA[<p>求解关键：非常标准的层序遍历的做法，使用队列作为辅助的数据结构。</p>
<ul>
<li>题目描述：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层次遍历<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong>
二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>返回其层序遍历结果：</p>
<div><pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>Example 2:</strong></p>
<div><pre><code>Input: root = [1]
Output: [[1]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: root = []
Output: []
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>非常标准的层序遍历的做法，使用队列作为辅助的数据结构。</p>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>class</span> <span>TreeNode</span> <span>{</span>
<span>int</span> val<span>;</span>
<span>TreeNode</span> left<span>;</span>
<span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>

<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>levelOrder</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> res<span>;</span>
        <span>}</span>

        <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        queue<span>.</span><span>offer</span><span>(</span>root<span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
            <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> currentLevel <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>size<span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>TreeNode</span> head <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                currentLevel<span>.</span><span>add</span><span>(</span>head<span>.</span>val<span>)</span><span>;</span>

                <span>if</span> <span>(</span>head<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>offer</span><span>(</span>head<span>.</span>left<span>)</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>head<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>offer</span><span>(</span>head<span>.</span>right<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            res<span>.</span><span>add</span><span>(</span>currentLevel<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>from</span> typing <span>import</span> List


<span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>

    <span>def</span> <span>levelOrder</span><span>(</span>self<span>,</span> root<span>:</span> TreeNode<span>)</span> <span>-</span><span>></span> List<span>[</span>List<span>[</span><span>int</span><span>]</span><span>]</span><span>:</span>

        res <span>=</span> <span>[</span><span>]</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> res
        queue <span>=</span> <span>[</span>root<span>]</span>
        <span>while</span> queue<span>:</span>
            size <span>=</span> <span>len</span><span>(</span>queue<span>)</span>
            cur <span>=</span> <span>[</span><span>]</span>
            <span>for</span> _ <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
                top <span>=</span> queue<span>.</span>pop<span>(</span><span>0</span><span>)</span>
                cur<span>.</span>append<span>(</span>top<span>.</span>val<span>)</span>

                <span>if</span> top<span>.</span>left<span>:</span>
                    queue<span>.</span>append<span>(</span>top<span>.</span>left<span>)</span>
                <span>if</span> top<span>.</span>right<span>:</span>
                    queue<span>.</span>append<span>(</span>top<span>.</span>right<span>)</span>

            res<span>.</span>append<span>(</span>cur<span>)</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:01:21.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 103 题：二叉树的锯齿形层次遍历（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0103-binary-tree-zigzag-level-order-traversal/</id>
    <link href="https://suanfa8.com/tree/solutions/0103-binary-tree-zigzag-level-order-traversal/"/>
    <updated>2022-01-13T16:20:05.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener noreferrer">103. 二叉树的锯齿形层次遍历<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：
给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>返回锯齿形层序遍历如下：</p>
<div><pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>Example 2:</strong></p>
<div><pre><code>Input: root = [1]
Output: [[1]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: root = []
Output: []
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>zigzagLevelOrder</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> res<span>;</span>
        <span>}</span>

        <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
        <span>boolean</span> direction <span>=</span> <span>true</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>// 当前这一层遍历的节点集合</span>
            <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> curList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

            <span>// 特别注意：每一次只能处理上一轮入队列的的元素，</span>
            <span>// 所以要将上一轮入队列的元素个数先存一下</span>
            <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>TreeNode</span> curNode <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>direction<span>)</span> <span>{</span>
                    curList<span>.</span><span>add</span><span>(</span>curNode<span>.</span>val<span>)</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    curList<span>.</span><span>add</span><span>(</span><span>0</span><span>,</span> curNode<span>.</span>val<span>)</span><span>;</span>
                <span>}</span>
                <span>// 处理每一个元素都一样，都要考虑一下左右子树</span>
                <span>if</span> <span>(</span>curNode<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>add</span><span>(</span>curNode<span>.</span>left<span>)</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>curNode<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>add</span><span>(</span>curNode<span>.</span>right<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// 改换方向</span>
            direction <span>=</span> <span>!</span>direction<span>;</span>
            res<span>.</span><span>add</span><span>(</span>curList<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TreeNode</span> node1 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>TreeNode</span> node2 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>2</span><span>)</span><span>;</span>
        <span>TreeNode</span> node3 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>3</span><span>)</span><span>;</span>
        <span>TreeNode</span> node4 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>4</span><span>)</span><span>;</span>
        <span>TreeNode</span> node5 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>5</span><span>)</span><span>;</span>
        <span>TreeNode</span> node6 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>6</span><span>)</span><span>;</span>
        <span>TreeNode</span> node7 <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>7</span><span>)</span><span>;</span>

        node1<span>.</span>left <span>=</span> node2<span>;</span>
        node1<span>.</span>right <span>=</span> node3<span>;</span>

        node2<span>.</span>left <span>=</span> node4<span>;</span>
        node2<span>.</span>right <span>=</span> node5<span>;</span>

        node3<span>.</span>left <span>=</span> node6<span>;</span>
        node3<span>.</span>right <span>=</span> node7<span>;</span>

        <span>Solution</span> solution <span>=</span> <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
        <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> zigzagLevelOrder <span>=</span> solution<span>.</span><span>zigzagLevelOrder</span><span>(</span>node1<span>)</span><span>;</span>
        zigzagLevelOrder<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:01:21.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 107 题：二叉树的层次遍历 II（中等）</title>
    <id>https://suanfa8.com/tree/solutions/0107-binary-tree-level-order-traversal-ii/</id>
    <link href="https://suanfa8.com/tree/solutions/0107-binary-tree-level-order-traversal-ii/"/>
    <updated>2022-01-13T16:20:05.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目描述：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener noreferrer">107. 二叉树的层次遍历 II<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order</em> <em>traversal of its nodes' values</em>. (i.e., from left to right, level by level from leaf to root).</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>Input: root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 2:</strong></p>
<div><pre><code>Input: root = [1]
Output: [[1]]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Example 3:</strong></p>
<div><pre><code>Input: root = []
Output: []
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>参考代码</strong>：</p>
<CodeGroup>
<CodeGroupItem title="Java">
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>LinkedList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Queue</span></span><span>;</span>

<span>class</span> <span>TreeNode</span> <span>{</span>
<span>int</span> val<span>;</span>
<span>TreeNode</span> left<span>;</span>
<span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>

<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>levelOrderBottom</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> res <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> res<span>;</span>
        <span>}</span>

        <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
            <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> curLevel <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>TreeNode</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
                curLevel<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
                <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            res<span>.</span><span>add</span><span>(</span><span>0</span><span>,</span> curLevel<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Python3">
<div><pre><code><span>from</span> typing <span>import</span> List
<span>from</span> collections <span>import</span> deque


<span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>

    <span>def</span> <span>levelOrderBottom</span><span>(</span>self<span>,</span> root<span>:</span> TreeNode<span>)</span> <span>-</span><span>></span> List<span>[</span>List<span>[</span><span>int</span><span>]</span><span>]</span><span>:</span>
        res <span>=</span> <span>[</span><span>]</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> res
        queue <span>=</span> deque<span>(</span><span>)</span>
        queue<span>.</span>append<span>(</span>root<span>)</span>
        <span>while</span> queue<span>:</span>
            size <span>=</span> <span>len</span><span>(</span>queue<span>)</span>
            cur <span>=</span> <span>[</span><span>]</span>
            <span>for</span> _ <span>in</span> <span>range</span><span>(</span>size<span>)</span><span>:</span>
                top <span>=</span> queue<span>.</span>popleft<span>(</span><span>)</span>
                cur<span>.</span>append<span>(</span>top<span>.</span>val<span>)</span>
                <span>if</span> top<span>.</span>left<span>:</span>
                    queue<span>.</span>append<span>(</span>top<span>.</span>left<span>)</span>
                <span>if</span> top<span>.</span>right<span>:</span>
                    queue<span>.</span>append<span>(</span>top<span>.</span>right<span>)</span>
            res<span>.</span>insert<span>(</span><span>0</span><span>,</span> cur<span>)</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:01:21.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 94 题：二叉树的中序遍历（简单）</title>
    <id>https://suanfa8.com/tree/solutions/0094-binary-tree-inorder-traversal/</id>
    <link href="https://suanfa8.com/tree/solutions/0094-binary-tree-inorder-traversal/"/>
    <updated>2022-01-13T16:20:05.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">94. 二叉树的中序遍历<i>Content not supported</i></a>；</li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/mo-ni-xi-tong-zhan-wan-cheng-fei-di-gui-zhong-xu-b/" target="_blank" rel="noopener noreferrer">模拟系统栈完成非递归中序遍历，同理可以完成非递归的前序遍历和后序遍历<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [1,null,2,3]
输出：[1,3,2]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<div><pre><code>输入：root = []
输出：[]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<div><pre><code>输入：root = [1]
输出：[1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 4：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [1,2]
输出：[2,1]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 5：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [1,null,2]
输出：[1,2]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="方法一-递归"> 方法一：递归</h2>
<p>Java 代码实现：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> result <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>inorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>inorder</span><span>(</span>root<span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>inorder</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>inorder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
            result<span>.</span><span>add</span><span>(</span>root<span>.</span>val<span>)</span><span>;</span>
            <span>inorder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="方法二-非递归写法-1"> 方法二：非递归写法 1</h2>
<p>Java 代码：</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayDeque</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Deque</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Stack</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>inorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Deque</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>ArrayDeque</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>TreeNode</span> currentNode <span>=</span> root<span>;</span>
        <span>while</span> <span>(</span>currentNode <span>!=</span> <span>null</span> <span>||</span> <span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>currentNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                stack<span>.</span><span>addLast</span><span>(</span>currentNode<span>)</span><span>;</span>
                currentNode <span>=</span> currentNode<span>.</span>left<span>;</span>
            <span>}</span>
            currentNode <span>=</span> stack<span>.</span><span>removeLast</span><span>(</span><span>)</span><span>;</span>
            res<span>.</span><span>add</span><span>(</span>currentNode<span>.</span>val<span>)</span><span>;</span>
            currentNode <span>=</span> currentNode<span>.</span>right<span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="方法三-非递归写法-2"> 方法三：非递归写法 2</h2>
<p>Java 代码实现：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>enum</span> <span>UseType</span> <span>{</span>
    RECURSION<span>,</span>
    ADD
<span>}</span>

<span>class</span> <span>Command</span> <span>{</span>
    <span>UseType</span> useType<span>;</span>
    <span>TreeNode</span> treeNode<span>;</span>

    <span>Command</span><span>(</span><span>UseType</span> useType<span>,</span> <span>TreeNode</span> treeNode<span>)</span> <span>{</span>
        <span>this</span><span>.</span>useType <span>=</span> useType<span>;</span>
        <span>this</span><span>.</span>treeNode <span>=</span> treeNode<span>;</span>
    <span>}</span>
<span>}</span>

<span>/**
 * 什么是中序遍历，先递归遍历左子节点
 * 在处理自己
 * 然后再递归遍历右子节点
 */</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>inorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> result <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> result<span>;</span>
        <span>}</span>
        <span>Stack</span><span><span>&lt;</span><span>Command</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        stack<span>.</span><span>push</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>UseType</span><span>.</span>RECURSION<span>,</span> root<span>)</span><span>)</span><span>;</span>

        <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Command</span> command <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span><span>UseType</span><span>.</span>ADD <span>==</span> command<span>.</span>useType<span>)</span> <span>{</span>
                result<span>.</span><span>add</span><span>(</span>command<span>.</span>treeNode<span>.</span>val<span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>assert</span> <span>UseType</span><span>.</span>RECURSION <span>==</span> command<span>.</span>useType<span>;</span>
                <span>if</span> <span>(</span>command<span>.</span>treeNode<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    stack<span>.</span><span>push</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>UseType</span><span>.</span>RECURSION<span>,</span> command<span>.</span>treeNode<span>.</span>right<span>)</span><span>)</span><span>;</span>
                <span>}</span>
                stack<span>.</span><span>push</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>UseType</span><span>.</span>ADD<span>,</span> command<span>.</span>treeNode<span>)</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>command<span>.</span>treeNode<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    stack<span>.</span><span>push</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>UseType</span><span>.</span>RECURSION<span>,</span> command<span>.</span>treeNode<span>.</span>left<span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>

        <span>}</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><hr>
<h2 id="方法-模拟系统栈"> 方法：模拟系统栈</h2>
<p>模拟系统栈的方法其实并不难理解，就是在栈中放入结点的同时，<strong>同时传入一个指令，这个指令可以有 2 个含义</strong>：</p>
<p>1、递归执行（就是继续放入栈里）；</p>
<p>2、马上执行。</p>
<p><strong>模拟系统栈的注意事项</strong>：因为栈是先进后出的，当递归执行的时候，代码编写的顺序应该是相应遍历种类的倒序（具体可以参考下面的代码）。</p>
<p><strong>模拟系统栈的好处</strong>：稍微改动一下代码，就可以完成非递归的前序遍历和后序遍历。</p>
<p><strong>参考代码</strong>：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>:</span>

    <span>def</span> <span>inorderTraversal</span><span>(</span>self<span>,</span> root<span>:</span> TreeNode<span>)</span> <span>-</span><span>></span> List<span>[</span><span>int</span><span>]</span><span>:</span>
        <span>if</span> <span>not</span> root<span>:</span>
            <span>return</span> <span>[</span><span>]</span>
        <span># 1 表示递归处理</span>
        stack <span>=</span> <span>[</span><span>(</span><span>1</span><span>,</span> root<span>)</span><span>]</span>
        res <span>=</span> <span>[</span><span>]</span>
        <span>while</span> stack<span>:</span>
            command<span>,</span> node <span>=</span> stack<span>.</span>pop<span>(</span><span>)</span>
            <span>if</span> command <span>==</span> <span>0</span><span>:</span>
                <span># 0 表示当前马上执行将结点的值添加到结果集中</span>
                res<span>.</span>append<span>(</span>node<span>.</span>val<span>)</span>
            <span>else</span><span>:</span>
                <span># 关键在这里：因为是模拟系统栈，应该把中序遍历的顺序倒过来写</span>
                <span># 调整一下顺序就可以完成前序遍历和后序遍历</span>
                <span>if</span> node<span>.</span>right<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>right<span>)</span><span>)</span>
                stack<span>.</span>append<span>(</span><span>(</span><span>0</span><span>,</span> node<span>)</span><span>)</span>
                <span>if</span> node<span>.</span>left<span>:</span>
                    stack<span>.</span>append<span>(</span><span>(</span><span>1</span><span>,</span> node<span>.</span>left<span>)</span><span>)</span>
        <span>return</span> res
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>ArrayList</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>List</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Stack</span></span><span>;</span>

<span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>enum</span> <span>Action</span> <span>{</span>
        <span>// GO 表示递归处理</span>
        <span>// ADDTORESULT 表示当前马上执行将结点的值添加到结果集中</span>
        GO<span>,</span> ADDTORESULT
    <span>}</span>

    <span>private</span> <span>class</span> <span>Command</span> <span>{</span>
        <span>private</span> <span>Action</span> action<span>;</span>
        <span>private</span> <span>TreeNode</span> node<span>;</span>

        <span>public</span> <span>Command</span><span>(</span><span>Action</span> action<span>,</span> <span>TreeNode</span> node<span>)</span> <span>{</span>
            <span>this</span><span>.</span>action <span>=</span> action<span>;</span>
            <span>this</span><span>.</span>node <span>=</span> node<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>inorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> res<span>;</span>
        <span>}</span>
        <span>Stack</span><span><span>&lt;</span><span>Command</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>GO<span>,</span> root<span>)</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Command</span> command <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>command<span>.</span>action <span>==</span> <span>Action</span><span>.</span>ADDTORESULT<span>)</span> <span>{</span>
                res<span>.</span><span>add</span><span>(</span>command<span>.</span>node<span>.</span>val<span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>assert</span> command<span>.</span>action <span>==</span> <span>Action</span><span>.</span>GO<span>;</span>
                <span>// 关键在这里：因为是模拟系统栈，应该把中序遍历的顺序倒过来写</span>
                <span>// 调整一下顺序就可以完成前序遍历和后序遍历</span>
                <span>if</span> <span>(</span>command<span>.</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>GO<span>,</span> command<span>.</span>node<span>.</span>right<span>)</span><span>)</span><span>;</span>
                <span>}</span>
                stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>ADDTORESULT<span>,</span> command<span>.</span>node<span>)</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>command<span>.</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    stack<span>.</span><span>add</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>Action</span><span>.</span>GO<span>,</span> command<span>.</span>node<span>.</span>left<span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:01:07.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 100 题：相同的树（简单）</title>
    <id>https://suanfa8.com/tree/solutions/0100-same-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0100-same-tree/"/>
    <updated>2022-01-13T16:20:05.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/same-tree/description/" target="_blank" rel="noopener noreferrer">100. 相同的树<i>Content not supported</i></a> 。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：p = [1,2,3], q = [1,2,3]
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：p = [1,2], q = [1,null,2]
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：p = [1,2,1], q = [1,1,2]
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<h2 id="思路分析"> 思路分析</h2>
<p>判断两棵二叉树是否一样。这是典型的使用递归解决的问题。</p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>isSameTree</span><span>(</span>self<span>,</span> p<span>,</span> q<span>)</span><span>:</span>
        <span>if</span> p <span>is</span> <span>None</span> <span>and</span> q <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>True</span>

        <span>if</span> p <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>False</span>

        <span>if</span> q <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>False</span>

        <span>return</span> p<span>.</span>val <span>==</span> q<span>.</span>val <span>and</span> self<span>.</span>isSameTree<span>(</span>
            p<span>.</span>left<span>,</span> q<span>.</span>left<span>)</span> <span>and</span> self<span>.</span>isSameTree<span>(</span>p<span>.</span>right<span>,</span> q<span>.</span>right<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><img src="http://upload-images.jianshu.io/upload_images/414598-cdec5589bde48aad.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="image-20181214103315065" loading="lazy"></p>
]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:01:07.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
  <entry>
    <title type="html">「力扣」第 101 题：判断两棵二叉树是否左右对称</title>
    <id>https://suanfa8.com/tree/solutions/0101-symmetric-tree/</id>
    <link href="https://suanfa8.com/tree/solutions/0101-symmetric-tree/"/>
    <updated>2022-01-13T16:20:05.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/symmetric-tree/description/" target="_blank" rel="noopener noreferrer">101. 对称二叉树<i>Content not supported</i></a>。</li>
</ul>
<h2 id="题目描述"> 题目描述</h2>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img" loading="lazy"></p>
<div><pre><code>输入：root = [1,2,2,null,3,null,3]
输出：false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong> 你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h2 id="方法一-递归"> 方法一：递归</h2>
<p>需要引入辅助函数。</p>
<p>Python 代码 1：</p>
<div><pre><code><span># Definition for a binary tree node.</span>
<span># 判断一棵二叉树是否镜面对称。</span>
<span># 设置辅助函数是关键。</span>


<span>class</span> <span>TreeNode</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span># 还可以使用队列去完成</span>
<span># https://leetcode.com/problems/symmetric-tree/solution/</span>

<span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>isSymmetric</span><span>(</span>self<span>,</span> root<span>)</span><span>:</span>
        <span>"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>True</span>
        <span>return</span> self<span>.</span>__helper<span>(</span>root<span>.</span>left<span>,</span> root<span>.</span>right<span>)</span>

    <span>def</span> <span>__helper</span><span>(</span>self<span>,</span> left_node<span>,</span> right_node<span>)</span><span>:</span>
        <span>if</span> left_node <span>is</span> <span>None</span> <span>and</span> right_node <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>True</span>
        <span>if</span> left_node <span>is</span> <span>None</span> <span>or</span> right_node <span>is</span> <span>None</span> <span>or</span> left_node<span>.</span>val <span>!=</span> right_node<span>.</span>val<span>:</span>
            <span>return</span> <span>False</span>
        <span>return</span> self<span>.</span>__helper<span>(</span>left_node<span>.</span>left<span>,</span> right_node<span>.</span>right<span>)</span> <span>and</span> self<span>.</span>__helper<span>(</span>
            left_node<span>.</span>right<span>,</span> right_node<span>.</span>left<span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id="方法二-非递归"> 方法二：非递归</h2>
<p>借助双端队列辅助判断。自己画一个图，就好理解了。</p>
<p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/101-1.jpg" alt="LeetCode 第 101 题：判断两棵二叉树是否左右对称" loading="lazy"></p>
<p>Python 代码：</p>
<div><pre><code><span># Definition for a binary tree node.</span>
<span>class</span> <span>TreeNode</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>


<span># 非递归写法：借助双端队列辅助判断</span>

<span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>isSymmetric</span><span>(</span>self<span>,</span> root<span>)</span><span>:</span>
        <span>"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        <span># 先写递归终止条件</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>True</span>

        <span># 其实应该用 from collections import deque</span>
        deque <span>=</span> <span>[</span><span>]</span>

        deque<span>.</span>insert<span>(</span><span>0</span><span>,</span> root<span>.</span>left<span>)</span>
        deque<span>.</span>append<span>(</span>root<span>.</span>right<span>)</span>

        <span>while</span> deque<span>:</span>
            l_node <span>=</span> deque<span>.</span>pop<span>(</span><span>0</span><span>)</span>
            r_node <span>=</span> deque<span>.</span>pop<span>(</span><span>)</span>

            <span>if</span> l_node <span>is</span> <span>None</span> <span>and</span> r_node <span>is</span> <span>None</span><span>:</span>
                <span>continue</span>
            <span>if</span> l_node <span>is</span> <span>None</span> <span>or</span> r_node <span>is</span> <span>None</span><span>:</span>
                <span>return</span> <span>False</span>
            <span># 代码走到这里一定有 l_node 和 r_node 非空</span>
            <span># 因此可以取出 val 进行判断了</span>
            <span>if</span> l_node<span>.</span>val <span>!=</span> r_node<span>.</span>val<span>:</span>
                <span>return</span> <span>False</span>
            deque<span>.</span>insert<span>(</span><span>0</span><span>,</span> l_node<span>.</span>right<span>)</span>
            deque<span>.</span>insert<span>(</span><span>0</span><span>,</span> l_node<span>.</span>left<span>)</span>
            deque<span>.</span>append<span>(</span>r_node<span>.</span>left<span>)</span>
            deque<span>.</span>append<span>(</span>r_node<span>.</span>right<span>)</span>
        <span>return</span> <span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>之前在刷这道题的时候，写过一个解法：先拷贝一棵二叉树，再反转，将反转以后的二叉树和自己比较，看看是否相等，这个思路就转化成了以前我们解决过的问题。另外复制的时候，我们可以反着复制，然后比较。</p>
<p>Java 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span> <span>{</span>
    <span>int</span> val<span>;</span>
    <span>TreeNode</span> left<span>;</span>
    <span>TreeNode</span> right<span>;</span>

    <span>TreeNode</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        val <span>=</span> x<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>boolean</span> <span>isSymmetric</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>TreeNode</span> copyBinaryTree <span>=</span> <span>copyBinaryTree</span><span>(</span>root<span>)</span><span>;</span>
        <span>TreeNode</span> invertBinaryTree <span>=</span> <span>invertBinaryTree</span><span>(</span>copyBinaryTree<span>)</span><span>;</span>
        <span>return</span> <span>isSameTree</span><span>(</span>root<span>,</span> invertBinaryTree<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>isSameTree</span><span>(</span><span>TreeNode</span> t1<span>,</span> <span>TreeNode</span> t2<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>&amp;&amp;</span> t2 <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>||</span> t2 <span>==</span> <span>null</span> <span>||</span> t1<span>.</span>val <span>!=</span> t2<span>.</span>val<span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>isSameTree</span><span>(</span>t1<span>.</span>left<span>,</span> t2<span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isSameTree</span><span>(</span>t1<span>.</span>right<span>,</span> t2<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>TreeNode</span> <span>invertBinaryTree</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> node<span>;</span>
        <span>}</span>
        <span>invertBinaryTree</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        <span>invertBinaryTree</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>TreeNode</span> temp <span>=</span> node<span>.</span>left<span>;</span>
        node<span>.</span>left <span>=</span> node<span>.</span>right<span>;</span>
        node<span>.</span>right <span>=</span> temp<span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span>

    <span>// 也使用递归的方式完成（熟悉一下如何完成二叉树的复制）</span>
    <span>private</span> <span>TreeNode</span> <span>copyBinaryTree</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>TreeNode</span> newTreeNode <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        newTreeNode<span>.</span>left <span>=</span> <span>copyBinaryTree</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        newTreeNode<span>.</span>right <span>=</span> <span>copyBinaryTree</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>return</span> newTreeNode<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>提示：首先理解什么是镜面对称。<strong>两个结点的根结点的值必须相等，并且 1、左边的左结点=右边的右结点；2、左边的右结点=右边的左结点</strong>。我觉得没有什么技巧，记住就可以了。使用下面这张图思考这个问题。</p>
<p>思路 1：递归。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/414598-e1711449c7543447.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="image-20181214103655847" loading="lazy"></p>
<p>思路 2：双端队列。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/414598-9fe70de9914851db.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="image-20181214104909130" loading="lazy"></p>
<p>Python 代码：</p>
<div><pre><code><span>class</span> <span>TreeNode</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>)</span><span>:</span>
        self<span>.</span>val <span>=</span> x
        self<span>.</span>left <span>=</span> <span>None</span>
        self<span>.</span>right <span>=</span> <span>None</span>

<span>class</span> <span>Solution</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>isSymmetric</span><span>(</span>self<span>,</span> root<span>)</span><span>:</span>
        <span># 先写递归终止条件</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>True</span>

        <span># 其实应该用 from collections import deque</span>
        deque <span>=</span> <span>[</span><span>]</span>

        deque<span>.</span>insert<span>(</span><span>0</span><span>,</span> root<span>.</span>left<span>)</span>
        deque<span>.</span>append<span>(</span>root<span>.</span>right<span>)</span>

        <span>while</span> deque<span>:</span>
            l_node <span>=</span> deque<span>.</span>pop<span>(</span><span>0</span><span>)</span>
            r_node <span>=</span> deque<span>.</span>pop<span>(</span><span>)</span>

            <span>if</span> l_node <span>is</span> <span>None</span> <span>and</span> r_node <span>is</span> <span>None</span><span>:</span>
                <span>continue</span>

            <span>if</span> l_node <span>is</span> <span>None</span> <span>or</span> r_node <span>is</span> <span>None</span><span>:</span>
                <span>return</span> <span>False</span>

            <span>if</span> l_node<span>.</span>val <span>!=</span> r_node<span>.</span>val<span>:</span>
                <span>return</span> <span>False</span>
            deque<span>.</span>insert<span>(</span><span>0</span><span>,</span> l_node<span>.</span>right<span>)</span>
            deque<span>.</span>insert<span>(</span><span>0</span><span>,</span> l_node<span>.</span>left<span>)</span>
            deque<span>.</span>append<span>(</span>r_node<span>.</span>left<span>)</span>
            deque<span>.</span>append<span>(</span>r_node<span>.</span>right<span>)</span>
        <span>return</span> <span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div>]]></content>
    <author>
      <name>liweiwei1419</name>
    </author>
    <category term="二叉树" scheme=""/>
    <contributor>
      <name>liweiwei1419</name>
    </contributor>
    <published>2022-01-06T08:01:07.000Z</published>
    <rights>Copyright by liweiwei1419</rights>
  </entry>
</feed>
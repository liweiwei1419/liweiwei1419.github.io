<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《算法与数据结构》学习笔记8：二分搜索树 | 算法吧</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <script data-ad-client="ca-pub-6066632930480255" async="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
    var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?15b6e6a744ff92195a76bda533c2c0bf";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
    </script>
    <link rel="icon" href="/suanfa8.png">
    <link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials">
    <link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png">
    <link rel="alternate" type="application/atom+xml" href="https://suanfa8.com/atom.xml" title="算法吧 Atom Feed">
    <link rel="alternate" type="application/json" href="https://suanfa8.com/rss.xml" title="算法吧 JSON Feed">
    <link rel="alternate" type="application/rss+xml" href="https://suanfa8.com/rss.xml" title="算法吧 RSS Feed">
    <meta name="description" content="欢迎来到算法吧">
    <meta property="og:url" content="https://suanfa8.com/data-structure/binary-search-tree/">
    <meta property="og:site_name" content="算法吧">
    <meta property="og:title" content="《算法与数据结构》学习笔记8：二分搜索树">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en-US">
    <meta property="article:author" content="liwei">
    <meta property="article:tag" content="二分搜索树">
    <meta property="article:published_time" content="2018-04-23T08:00:00.000Z">
    <meta name="theme-color" content="#46bd87">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <link rel="preload" href="/assets/css/0.styles.aeb49c51.css" as="style"><link rel="preload" href="/assets/js/app.501b6226.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Layout.b79b4248.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.142c3b04.js" as="script"><link rel="preload" href="/assets/js/page-《算法与数据结构》学习笔记8：二分搜索树.f6ee7432.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout.51e2ddcf.js" as="script"><link rel="prefetch" href="/assets/js/640.8e725f23.js"><link rel="prefetch" href="/assets/js/641.e4542c81.js"><link rel="prefetch" href="/assets/js/642.272d1601.js"><link rel="prefetch" href="/assets/js/643.d98d64a0.js"><link rel="prefetch" href="/assets/js/644.77cd202a.js"><link rel="prefetch" href="/assets/js/645.cbc8ff7f.js"><link rel="prefetch" href="/assets/js/646.8cefaf17.js"><link rel="prefetch" href="/assets/js/layout-Blog.e1272ca6.js"><link rel="prefetch" href="/assets/js/layout-Layout.28347db1.js"><link rel="prefetch" href="/assets/js/layout-NotFound.640d0bfa.js"><link rel="prefetch" href="/assets/js/layout-Slide.b40b02df.js"><link rel="prefetch" href="/assets/js/page--1a80215b.2fbc75c9.js"><link rel="prefetch" href="/assets/js/page--1fc74288.5a2b3e91.js"><link rel="prefetch" href="/assets/js/page--50505c44.5706361e.js"><link rel="prefetch" href="/assets/js/page--54b14006.7f715879.js"><link rel="prefetch" href="/assets/js/page--770626e8.85abb6f0.js"><link rel="prefetch" href="/assets/js/page--7e744542.6b084d25.js"><link rel="prefetch" href="/assets/js/page--b0421f28.b1a378bd.js"><link rel="prefetch" href="/assets/js/page--c954eb04.0af42c21.js"><link rel="prefetch" href="/assets/js/page--e477b492.2bcb0337.js"><link rel="prefetch" href="/assets/js/page-1079活字印刷.a1ee8206.js"><link rel="prefetch" href="/assets/js/page-1080根到叶路径上的不足节点.8566a671.js"><link rel="prefetch" href="/assets/js/page-11参考资料与网站.0e3a1f5b.js"><link rel="prefetch" href="/assets/js/page-12如何看待《算法导论》.dbf2241b.js"><link rel="prefetch" href="/assets/js/page-13书籍下载.afb6f1b8.js"><link rel="prefetch" href="/assets/js/page-14如何提问.7d211dda.js"><link rel="prefetch" href="/assets/js/page-15递归.6028d8c6.js"><link rel="prefetch" href="/assets/js/page-16时间复杂度.562793fe.js"><link rel="prefetch" href="/assets/js/page-17循环不变量.a847d4aa.js"><link rel="prefetch" href="/assets/js/page-1并查集视频讲解（请先看这里）.f9aaddb2.js"><link rel="prefetch" href="/assets/js/page-1归并排序简介.2a4b961d.js"><link rel="prefetch" href="/assets/js/page-1循环不变量简介.049d6ef9.js"><link rel="prefetch" href="/assets/js/page-210快速排序（重点）.c21d652a.js"><link rel="prefetch" href="/assets/js/page-21排序算法简介.13dbe3c8.js"><link rel="prefetch" href="/assets/js/page-225非比较排序算法简介.706d43f5.js"><link rel="prefetch" href="/assets/js/page-226计数排序（不重要，不用仔细看）.0c60f5c6.js"><link rel="prefetch" href="/assets/js/page-227基数排序（不重要，不用仔细看）.26080242.js"><link rel="prefetch" href="/assets/js/page-228桶排序（不重要，不用仔细看）.c974dde5.js"><link rel="prefetch" href="/assets/js/page-22选择排序.f1497bc9.js"><link rel="prefetch" href="/assets/js/page-23冒泡排序.11d0f80b.js"><link rel="prefetch" href="/assets/js/page-24冒泡排序的优化.14dbe5ec.js"><link rel="prefetch" href="/assets/js/page-25插入排序.89256a92.js"><link rel="prefetch" href="/assets/js/page-26插入排序的意义.65f44c2b.js"><link rel="prefetch" href="/assets/js/page-27插入排序的优化.6c848222.js"><link rel="prefetch" href="/assets/js/page-28希尔排序.71ed7385.js"><link rel="prefetch" href="/assets/js/page-29归并排序（重点）.1bb9f7ea.js"><link rel="prefetch" href="/assets/js/page-2并查集的设计思想.35a4dae9.js"><link rel="prefetch" href="/assets/js/page-2归并排序的基本实现.8fe68e66.js"><link rel="prefetch" href="/assets/js/page-2循环不变量有什么用.74bd6e9c.js"><link rel="prefetch" href="/assets/js/page-31二分查找习题分类.25bb0cf8.js"><link rel="prefetch" href="/assets/js/page-32滑动窗口是什么.61d2f7b2.js"><link rel="prefetch" href="/assets/js/page-33滑动窗口的练习.f934989d.js"><link rel="prefetch" href="/assets/js/page-34双指针简介与练习.36fa0e02.js"><link rel="prefetch" href="/assets/js/page-38排序算法练习.e84b288b.js"><link rel="prefetch" href="/assets/js/page-3归并排序的优化.4477c19a.js"><link rel="prefetch" href="/assets/js/page-3快速排序的优化（理解随机选择pivot）.df12653a.js"><link rel="prefetch" href="/assets/js/page-3明确循环不变量写出「快速排序」.135485c8.js"><link rel="prefetch" href="/assets/js/page-3第1版基于quick-find实现.3fd9a475.js"><link rel="prefetch" href="/assets/js/page-410树的练习.0a3a698a.js"><link rel="prefetch" href="/assets/js/page-411哈希表简介.d669571b.js"><link rel="prefetch" href="/assets/js/page-412哈希表练习.01f9f6bd.js"><link rel="prefetch" href="/assets/js/page-41链表简介.c1835ac8.js"><link rel="prefetch" href="/assets/js/page-42链表的练习.2a181162.js"><link rel="prefetch" href="/assets/js/page-43栈的简介.9d138743.js"><link rel="prefetch" href="/assets/js/page-44栈的练习.658f9cbd.js"><link rel="prefetch" href="/assets/js/page-45队列简介.efc3f187.js"><link rel="prefetch" href="/assets/js/page-46队列的问题.d2149377.js"><link rel="prefetch" href="/assets/js/page-47优先队列是什么.d4a0476f.js"><link rel="prefetch" href="/assets/js/page-48优先队列的练习.9500331c.js"><link rel="prefetch" href="/assets/js/page-49树的简介.3163bc9a.js"><link rel="prefetch" href="/assets/js/page-4总结.790e66b8.js"><link rel="prefetch" href="/assets/js/page-4第2版基于quick-union实现（非最终版本）.05b760c7.js"><link rel="prefetch" href="/assets/js/page-4自底向上的归并排序（选学）.1688580a.js"><link rel="prefetch" href="/assets/js/page-510动态规划是什么.c2e3786d.js"><link rel="prefetch" href="/assets/js/page-511动态规划练习.95dce2ae.js"><link rel="prefetch" href="/assets/js/page-512贪心算法简介.7b639a49.js"><link rel="prefetch" href="/assets/js/page-513贪心算法练习.e887524d.js"><link rel="prefetch" href="/assets/js/page-51回溯算法简介.453ead18.js"><link rel="prefetch" href="/assets/js/page-52树形问题.7ebf0d52.js"><link rel="prefetch" href="/assets/js/page-53理解回溯.5e661854.js"><link rel="prefetch" href="/assets/js/page-54回溯算法的几点说明.7e845058.js"><link rel="prefetch" href="/assets/js/page-55剪枝.4c611729.js"><link rel="prefetch" href="/assets/js/page-56回溯算法总结.c43c1ca6.js"><link rel="prefetch" href="/assets/js/page-57回溯算法视频讲解以及练习列表.5a7d0756.js"><link rel="prefetch" href="/assets/js/page-58广度优先遍历简介.3608b999.js"><link rel="prefetch" href="/assets/js/page-59广度优先遍历练习.182deb51.js"><link rel="prefetch" href="/assets/js/page-5归并排序练习.20aa7f4f.js"><link rel="prefetch" href="/assets/js/page-5第3版quick-union基于size的优化.6ea3078e.js"><link rel="prefetch" href="/assets/js/page-610创建线段树与区间查询.a76e878c.js"><link rel="prefetch" href="/assets/js/page-611区间更新（单点更新）.f4994e3b.js"><link rel="prefetch" href="/assets/js/page-612树状数组概述（视频讲解）.f3be725d.js"><link rel="prefetch" href="/assets/js/page-613预备知识：前缀和数组.74ce4922.js"><link rel="prefetch" href="/assets/js/page-614「树状数组」如何组织原始输入数据的结构.8977c3f1.js"><link rel="prefetch" href="/assets/js/page-615详解lowbit函数.2e3b2e1f.js"><link rel="prefetch" href="/assets/js/page-616「单点更新」与「前缀和查询」.9f6630ba.js"><link rel="prefetch" href="/assets/js/page-617例1：计算逆序数.e18cd343.js"><link rel="prefetch" href="/assets/js/page-618例2：「力扣」第315题：计算右侧小于当前元素的个数（困难）.437875f5.js"><link rel="prefetch" href="/assets/js/page-61Trie的思想与基本结构.64cbba9a.js"><link rel="prefetch" href="/assets/js/page-62Trie的添加与查询.bef95695.js"><link rel="prefetch" href="/assets/js/page-63Trie的前缀查询操作.7d67b54a.js"><link rel="prefetch" href="/assets/js/page-64简单的模式匹配.a251249e.js"><link rel="prefetch" href="/assets/js/page-65使用Trie实现字符串映射.f00cef74.js"><link rel="prefetch" href="/assets/js/page-65练习.aa699038.js"><link rel="prefetch" href="/assets/js/page-66并查集基础问题.7f80e994.js"><link rel="prefetch" href="/assets/js/page-67并查集进阶问题.7d145449.js"><link rel="prefetch" href="/assets/js/page-68线段树是原始数组的一个预处理数组.dfd50c07.js"><link rel="prefetch" href="/assets/js/page-69写出预处理数组的结构.05f98668.js"><link rel="prefetch" href="/assets/js/page-6第4版quick-union基于rank的优化.5749eff1.js"><link rel="prefetch" href="/assets/js/page-710Kruskal算法.fdac4860.js"><link rel="prefetch" href="/assets/js/page-711Prim算法.2794201d.js"><link rel="prefetch" href="/assets/js/page-712最小生成树算法总结与练习.41a17d68.js"><link rel="prefetch" href="/assets/js/page-71单源最短路径简介与参考资料.2abae30b.js"><link rel="prefetch" href="/assets/js/page-72Dijkstra算法要解决的问题与几何直观.1418f30d.js"><link rel="prefetch" href="/assets/js/page-73松弛操作.7f60e731.js"><link rel="prefetch" href="/assets/js/page-74通过一个例子理解Dijkstra算法的执行步骤.0f7db702.js"><link rel="prefetch" href="/assets/js/page-75代码实现.5214a761.js"><link rel="prefetch" href="/assets/js/page-76单源最短路径算法总结.26003085.js"><link rel="prefetch" href="/assets/js/page-77最小生成树简介与参考资料.d8bb8a0a.js"><link rel="prefetch" href="/assets/js/page-78最小生成树的应用.13c69e96.js"><link rel="prefetch" href="/assets/js/page-79切分定理.f6b3ec50.js"><link rel="prefetch" href="/assets/js/page-7第5版quick-union基于路径压缩的非递归实现.e9d8773f.js"><link rel="prefetch" href="/assets/js/page-8第6版quick-union基于路径压缩的递归实现.f1ff074a.js"><link rel="prefetch" href="/assets/js/page-9并查集总结.e9007e56.js"><link rel="prefetch" href="/assets/js/page-TopK问题：「力扣」第215题：数组第k大的元素（中等）.befb9766.js"><link rel="prefetch" href="/assets/js/page-partition几种写法比较.1bba822d.js"><link rel="prefetch" href="/assets/js/page-《剑指Offer》（第2版）第51题：计算数组的逆序对（困难）.37e487b2.js"><link rel="prefetch" href="/assets/js/page-《剑指Offer》（第2版）面试题56-I数组中数字出现的次数.143d3d0a.js"><link rel="prefetch" href="/assets/js/page-「剑指Offer」第40题：最小的k个数（中等）.35667746.js"><link rel="prefetch" href="/assets/js/page-「力扣」2020年春季团体赛第3题：LCP12小张刷题计划.f5fe1d79.js"><link rel="prefetch" href="/assets/js/page-「力扣」上一些有意义的讨论.cb38a49a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1004题：最大连续1的个数III（中等）.b4ca46b0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1008题：前序遍历构造二叉搜索树（中等）.addc595d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第100题：相同的树（简单）.333a7ebf.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1010题：总持续时间可被60整除的歌曲（中等）.2cabea54.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1011题：在D天内送达包裹的能力（中等）.89d796fd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第101题：判断两棵二叉树是否左右对称.0b778026.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1020题：飞地的数量（中等）.3e569780.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1025题：除数博弈（简单）.a515959a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第102题：二叉树的层次遍历.d00803d6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1034题：边界着色（中等）.25da0e3e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第103题：二叉树的锯齿形层次遍历（中等）.e8a60742.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1046题：最后一块石头的重量（中等）.6ad31aa8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第104题：求一棵二叉树的最大深度（简单）.be3e988c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1052题：爱生气的书店老板（中等）.2c655d36.js"><link rel="prefetch" href="/assets/js/page-「力扣」第105题：从前序与中序遍历序列构造二叉树（中等）.7631cb21.js"><link rel="prefetch" href="/assets/js/page-「力扣」第106题：从中序与后序遍历序列构造二叉树（中等）.11b0c316.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1079题：活字印刷（中等）.ca44d979.js"><link rel="prefetch" href="/assets/js/page-「力扣」第107题：二叉树的层次遍历II（中等）.fd1226f0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第108题：将有序数组转换为二叉搜索树（简单）.9c3cd3dd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1095题：山脉数组中查找目标值（中等）.ae07fbc1.js"><link rel="prefetch" href="/assets/js/page-「力扣」第109题：有序链表转换二叉搜索树（中等）.4a574837.js"><link rel="prefetch" href="/assets/js/page-「力扣」第10题：正则表达式（困难）.3cb4fc29.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1109题：航班预订统计（中等）.ae1ab06c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第110题：平衡二叉树（简单）.e17b390b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1111题：有效括号的嵌套深度（中等）.606edaac.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1128题：等价多米诺骨牌对的数量（简单）.f760be7c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第113题：路径总和II（中等）.9c8e4405.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1140题：石子游戏II（中等）.e13b90c9.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1143题：最长公共子序列（中等）.cb31aa69.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1162题：地图分析（中等）.4ea86b18.js"><link rel="prefetch" href="/assets/js/page-「力扣」第11题：盛最多水的容器（中等）.cf3435b3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1202题：交换字符串中的元素（中等）.65631fbc.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1203题：项目管理（困难）.9cd64aa1.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1206题：设计跳表（困难）.66352a13.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1208题：尽可能使字符串相等（中等）.cccf0274.js"><link rel="prefetch" href="/assets/js/page-「力扣」第120题：三角形最小路径和（中等）.79861019.js"><link rel="prefetch" href="/assets/js/page-「力扣」第121题：买卖股票的最佳时机（简单）.f49e39dd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第122题：买卖股票的最佳时机II（简单）.db92c4e5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第123题：买卖股票的最佳时机III（困难）.f45d3497.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1248题：统计「优美子数组」（中等）.24685209.js"><link rel="prefetch" href="/assets/js/page-「力扣」第124题：二叉树中的最大路径和（困难）.c3c806ca.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1254题：统计封闭岛屿的数目（中等）.a0ff68c7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第125题：验证回文串（简单）.6ed9e87f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1267题：统计参与通信的服务器（中等）.dfcfdd92.js"><link rel="prefetch" href="/assets/js/page-「力扣」第126题：单词接龙II（困难）.fae61125.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1276题：不浪费原料的汉堡制作方案（简单）.20b06751.js"><link rel="prefetch" href="/assets/js/page-「力扣」第127题：单词接龙（困难）.d4bd17d1.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1282题：用户分组（中等）.eefdb8d0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1283题：使结果不超过阈值的最小除数（中等）.cee94f0a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第128题：最长连续序列（困难）.74a3a4d6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1296题：划分数组为连续数字的集合（中等）.4ee00aae.js"><link rel="prefetch" href="/assets/js/page-「力扣」第129题：求根到叶子结点数字之和.d54f7b6c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第12题：整数转罗马数字（中等）.170c2645.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1300题：转变数组后最接近目标值的数组和（中等）.53a7082b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1306题：跳跃游戏III（中等）.4f39fb59.js"><link rel="prefetch" href="/assets/js/page-「力扣」第130题：被围绕的区域.768583a9.js"><link rel="prefetch" href="/assets/js/page-「力扣」第130题：被围绕的区域（中等）.d4f97688.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1314题：矩阵区域和（简单）.1266dabb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1315题：祖父节点值为偶数的节点和（中等）.71e46541.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1319题：连通网络的操作次数（中等）.5a9b986a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第131题：分割回文串（中等）.618fcc53.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1329题：将矩阵按对角线排序（中等）.cc1daf51.js"><link rel="prefetch" href="/assets/js/page-「力扣」第132题：分割回文串II（困难）.f771c5a3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第136题：只出现一次的数字.ebbb2a6b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第136题：只出现一次的数字（简单）.f9596355.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1371题：每个元音包含偶数次的最长子字符串（中等）.34668abb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1372题：二叉树中的最长交错路径（中等）.3df77c0c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第137题：只出现一次的数字II（中等）.bcd25bb8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1391题：检查网格中是否存在有效路径（中等）.22082425.js"><link rel="prefetch" href="/assets/js/page-「力扣」第139题：单词拆分（中等）.1a6e1207.js"><link rel="prefetch" href="/assets/js/page-「力扣」第13题：罗马数字转整数（简单）.7ab1ad99.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1400题：构造K个回文字符串（中等）.86bd25e6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第140题：单词拆分II（困难）.9261d2de.js"><link rel="prefetch" href="/assets/js/page-「力扣」第141题：环形链表（简单）.b8c482c8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1423题：可获得的最大点数（中等）.0f1474db.js"><link rel="prefetch" href="/assets/js/page-「力扣」第142题：环形链表II（中等）.bc2b6ae0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1438题：绝对差不超过限制的最长连续子数组（中等）.5a3f1781.js"><link rel="prefetch" href="/assets/js/page-「力扣」第143题：重排链表（中等）.fb78715f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1449题：数位成本和为目标值的最大数字.e2c7af51.js"><link rel="prefetch" href="/assets/js/page-「力扣」第144题：二叉树的前序遍历（中等）.4957c82e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1456题：定长子串中元音的最大数目（中等）.d98c5bff.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1457题：二叉树中的伪回文路径（中等）.9c66e664.js"><link rel="prefetch" href="/assets/js/page-「力扣」第145题：二叉树的后序遍历（困难）.c3a99155.js"><link rel="prefetch" href="/assets/js/page-「力扣」第146题：LRU缓存机制（中等）.ebb9597b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第147题：对链表进行插入排序（中等）.11fc118d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1482题：制作m束花所需的最少天数（中等）.f0bb087c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第148题：排序链表.ade81d7d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1493题：删掉一个元素以后全为1的最长子数组（中等）.0889ea07.js"><link rel="prefetch" href="/assets/js/page-「力扣」第150题：逆波兰表达式求值（中等）.0e1387d7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第152题：乘积最大子序列（中等）.98e20da9.js"><link rel="prefetch" href="/assets/js/page-「力扣」第153题：旋转排序数组的最小值（中等）.0afb834f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第154题：旋转排序数组的最小值II（困难）.16790b44.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1552题：两球之间的磁力（中等）.83f12972.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1559题：二维网格图中探测环（中等）.86afc992.js"><link rel="prefetch" href="/assets/js/page-「力扣」第155题：最小栈（简单）.eccd58aa.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1593题：拆分字符串使唯一子字符串的数目最大（中等）.09e820cf.js"><link rel="prefetch" href="/assets/js/page-「力扣」第15题：三数之和（中等）.2a0c3e08.js"><link rel="prefetch" href="/assets/js/page-「力扣」第160题：相交链表（简单）.5f47ebb0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第162题：寻找峰值（中等）.b9df8547.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1631题：最小体力消耗路径（中等）.a1782555.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1658题：将x减到0的最小操作数（中等）.f8841845.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1673题：找出最具竞争力的子序列（中等）.fa857679.js"><link rel="prefetch" href="/assets/js/page-「力扣」第167题：两数之和II-输入有序数组（简单）.7e09c17a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第16题：最接近的三数之和（中等）.ef469103.js"><link rel="prefetch" href="/assets/js/page-「力扣」第173题：二叉搜索树迭代器（中等）.a4aa63a7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第17题：电话号码的字母组合（中等）.afdcc0c8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第188题：买卖股票的最佳时机IV（困难）.3ffaf19a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第189题：生成旋转数组（中等）.7082a073.js"><link rel="prefetch" href="/assets/js/page-「力扣」第18题：四数之和（中等）.4fe386dd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第198题：打家劫舍（简单）.4d45a0ec.js"><link rel="prefetch" href="/assets/js/page-「力扣」第199题：二叉树的右视图（中等）.a127a277.js"><link rel="prefetch" href="/assets/js/page-「力扣」第19题：删除链表的倒数第N个节点（中等）.1f6ce9ca.js"><link rel="prefetch" href="/assets/js/page-「力扣」第1题：两数之和（简单）.2927404c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第200题：岛屿数量（中等）.811263f6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第200题：岛屿的个数（中等）.2be4e69f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第201题：数字范围按位与.76cc3f9c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第202题：同构字符串（简单）.9f028261.js"><link rel="prefetch" href="/assets/js/page-「力扣」第202题：快乐数（简单）.bc6406cd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第203题：移除链表元素（简单）.86a72c61.js"><link rel="prefetch" href="/assets/js/page-「力扣」第206题：反转链表（简单）.edf5169c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第207题：课程表（中等）.67157f7b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第208题：实现Trie(前缀树)（中等）.741654c2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第209题：长度最小的子数组（中等）.ef14fbd7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第20题：有效的括号（简单）.94b36340.js"><link rel="prefetch" href="/assets/js/page-「力扣」第210题：课程表II（中等）.6645dbe4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第211题：添加与搜索单词-数据结构设计（中等）.416571b1.js"><link rel="prefetch" href="/assets/js/page-「力扣」第212题：单词搜索II（困难）.7918500b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第215题：数组第k大的元素（中等）.6746788b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第216题：组合总和III（中等）.599c2082.js"><link rel="prefetch" href="/assets/js/page-「力扣」第217题：存在重复元素（简单）.b458cbc0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第218题：天际线问题（困难）.05a750a1.js"><link rel="prefetch" href="/assets/js/page-「力扣」第219题：存在重复元素II（中等）.482eb41c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第21题：合并两个有序链表（简单）.fc5e19ac.js"><link rel="prefetch" href="/assets/js/page-「力扣」第220题：存在重复元素III（中等）.57413fa7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第221题：最大正方形（中等）.10456eff.js"><link rel="prefetch" href="/assets/js/page-「力扣」第222题：求完全二叉树的节点数、满二叉树.aab9283a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第225题：用队列实现栈（简单）.b2e10e1b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第226题：反转一棵二叉树.528db39b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第22题：括号生成（中等）.780e0e63.js"><link rel="prefetch" href="/assets/js/page-「力扣」第230题：二叉搜索树中第K小的元素（中等）.e4f32b83.js"><link rel="prefetch" href="/assets/js/page-「力扣」第232题：用栈实现队列（简单）.6144fd1f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第233题：数字1的个数（困难）.69127563.js"><link rel="prefetch" href="/assets/js/page-「力扣」第234题：回文链表（简单）.cd543c5c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第235题：二叉搜索树的最近公共祖先（中等）.4e46c0b0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第236题：二叉树的最近公共祖先（中等）.aa4eca7e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第236题：二叉树的最近公共祖先（后序遍历、分治思想）.20986173.js"><link rel="prefetch" href="/assets/js/page-「力扣」第237题：删除链表中的节点（简单）.5867e5d6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第238题：除自身以外数组的乘积（中等）.0fa6d125.js"><link rel="prefetch" href="/assets/js/page-「力扣」第239题：滑动窗口的最大值（困难）.d1d61183.js"><link rel="prefetch" href="/assets/js/page-「力扣」第23题：合并K个排序链表.54ffff1c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第23题：合并K个排序链表（困难）.d1013ca6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第240题：搜索二维矩阵II（中等）.bb9f7f16.js"><link rel="prefetch" href="/assets/js/page-「力扣」第242题：有效的字母异位词（简单）.45aa04f7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第24题：两两交换链表中的结点（中等）.96a92d3e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第257题：二叉树的所有路径（简单）.0eeb2534.js"><link rel="prefetch" href="/assets/js/page-「力扣」第25题：K个一组翻转链表（困难）.1e663041.js"><link rel="prefetch" href="/assets/js/page-「力扣」第275题：H指数II（中等）.fbc14357.js"><link rel="prefetch" href="/assets/js/page-「力扣」第279题：完全平方式（中等）.448355b7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第279题：完全平方数（中等）.6848b3ce.js"><link rel="prefetch" href="/assets/js/page-「力扣」第287题：数组中的重复数字（中等）.6cc2d562.js"><link rel="prefetch" href="/assets/js/page-「力扣」第290题：单词规律（简单）.63b0f5b4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第292题：Nim游戏（简单）.40e2d575.js"><link rel="prefetch" href="/assets/js/page-「力扣」第295题：数据流的中位数（困难）.8c727d5e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第297题：二叉树的序列化与反序列化（困难）.7e82db92.js"><link rel="prefetch" href="/assets/js/page-「力扣」第2题：两个数相加（中等）.1f1f4ba0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第300题：最长上升子序列（中等）.47d49632.js"><link rel="prefetch" href="/assets/js/page-「力扣」第306题：累加数（中等）.6c27f043.js"><link rel="prefetch" href="/assets/js/page-「力扣」第309题：最佳买卖股票时机含冷冻期（中等）.e5bdc5a2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第310题：最小高度树（中等）.d3da8dac.js"><link rel="prefetch" href="/assets/js/page-「力扣」第313题：超级丑数（中等）.72a0db3f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第315题：计算右侧小于当前元素的个数（困难）.e8497456.js"><link rel="prefetch" href="/assets/js/page-「力扣」第316题：去除重复字母（中等）.9d7a9f89.js"><link rel="prefetch" href="/assets/js/page-「力扣」第322题：零钱兑换（中等）.7e342863.js"><link rel="prefetch" href="/assets/js/page-「力扣」第328题：奇偶链表（中等）.94adb134.js"><link rel="prefetch" href="/assets/js/page-「力扣」第331题：验证二叉树的前序序列化（中等）.0cb08179.js"><link rel="prefetch" href="/assets/js/page-「力扣」第336题：回文对（困难）.2808628b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第337题：打家劫舍III（中等）.4736a427.js"><link rel="prefetch" href="/assets/js/page-「力扣」第33题：搜索旋转排序数组（中等）.c86d57a2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第341题：扁平化嵌套列表迭代器（中等）.d92a33f5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第342题：4的幂.bad6b261.js"><link rel="prefetch" href="/assets/js/page-「力扣」第343题：整数拆分（中等）.20cc8ba8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第344题：反转字符串（简单）.b42ff17a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第345题：反转字符串中的元音字母（简单）.bc26bbf4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第347题：前K个高频元素（中等）.7d63cfc8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第349题：计算两个数组的交集（简单）.220dc50c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第34题：在排序数组中查找元素的第一个和最后一个位置（中等）.6939603f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第350题：两个数组的交集II（中等）.f9f2ebf8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第354题：俄罗斯套娃信封问题（困难）.0d3a8820.js"><link rel="prefetch" href="/assets/js/page-「力扣」第355题：设计推特（中等）.1031e5d7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第35题：搜索插入位置（简单）.b9742acf.js"><link rel="prefetch" href="/assets/js/page-「力扣」第365题：水壶问题（中等）.4c18cc1e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第367题：有效的完全平方数（中等）.18fb87b4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第368题：最大整除子集（中等）.8bdaab19.js"><link rel="prefetch" href="/assets/js/page-「力扣」第36题：有效的数独（中等）.b2d1ec35.js"><link rel="prefetch" href="/assets/js/page-「力扣」第374题：猜数字大小（简单）.7abe91fa.js"><link rel="prefetch" href="/assets/js/page-「力扣」第376题：摆动序列（中等）.6a85928e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第377题：组合总和Ⅳ（中等）.ebead2cb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第378题：有序矩阵中第K小的元素（中等）.f20fab96.js"><link rel="prefetch" href="/assets/js/page-「力扣」第37题：求解数独（困难）.f67d9a13.js"><link rel="prefetch" href="/assets/js/page-「力扣」第387题：字符串中的第一个唯一字符（简单）.1d54b047.js"><link rel="prefetch" href="/assets/js/page-「力扣」第399题：除法求值（中等）.bd10969f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第39题：组合总和（中等）.99a3ab87.js"><link rel="prefetch" href="/assets/js/page-「力扣」第3题：无重复字符的最长子串（中等）.9a09b16d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第401题：二进制手表问题.8e63a185.js"><link rel="prefetch" href="/assets/js/page-「力扣」第404题：左叶子之和（简单）.b05b2695.js"><link rel="prefetch" href="/assets/js/page-「力扣」第40题：组合总和II（中等）.60fbec31.js"><link rel="prefetch" href="/assets/js/page-「力扣」第410题：分割数组的最大值（困难）.27c879ba.js"><link rel="prefetch" href="/assets/js/page-「力扣」第413题：等差数列划分（中等）.c206301e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第416题：分割等和子集（中等）.9937c8c3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第417题：太平洋大西洋水流问题（中等）.0664540d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第41题：缺失的第一个正数（困难）.0e84095b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第421题：数组中两个数的最大异或值（中等）.105c0258.js"><link rel="prefetch" href="/assets/js/page-「力扣」第424题以及同类问题.4d3441ff.js"><link rel="prefetch" href="/assets/js/page-「力扣」第424题：替换后的最长重复字符（中等）.00913509.js"><link rel="prefetch" href="/assets/js/page-「力扣」第42题：接雨水（困难）.72611114.js"><link rel="prefetch" href="/assets/js/page-「力扣」第433题：最小基因变化（中等）.795dce4a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第436题：寻找右区间（中等）.79ed636b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第437题：路径总和III（中等）.07de3378.js"><link rel="prefetch" href="/assets/js/page-「力扣」第438题：找到字符串中所有字母异位词（中等）.79e86870.js"><link rel="prefetch" href="/assets/js/page-「力扣」第442题：数组中重复的数据.868bc48c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第445题：两数相加II（中等）.28c331b5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第447题：回旋镖的数量（中等）.a3f22ede.js"><link rel="prefetch" href="/assets/js/page-「力扣」第448题：找到所有数组中消失的数字（简单）.2cbef8bf.js"><link rel="prefetch" href="/assets/js/page-「力扣」第449题：序列化和反序列化二叉搜索树（中等）.3f86ae6b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第450题：删除二叉搜索树中的节点（中等）.a77d4017.js"><link rel="prefetch" href="/assets/js/page-「力扣」第451题：根据字符出现频率排序（中等）.4ce45420.js"><link rel="prefetch" href="/assets/js/page-「力扣」第452题：用最少数量的箭引爆气球（中等）.2988109e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第454题：四数相加II（中等）.bbdb42cb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第455题：分发饼干（中等）.6ced14f6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第456题：132模式（中等）.144fc5d6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第45题：整数转罗马数字（困难）.ede9e515.js"><link rel="prefetch" href="/assets/js/page-「力扣」第460题：LFU缓存（困难）.eaa1fd4d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第461题：汉明距离（简单）.fa75c0be.js"><link rel="prefetch" href="/assets/js/page-「力扣」第46题：全排列（中等）.a087be86.js"><link rel="prefetch" href="/assets/js/page-「力扣」第474题：一和零（中等）.022274c3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第477题：汉明距离总和（中等）.8652d35c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第47题：全排列II（中等）.01fc75e3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第486题：预测赢家（中等）.9d6b60a5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第491题：递增子序列（中等）.ddbde56e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第493题：计算翻转对（困难）.ae01f67c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第494题：目标和（中等）.243fa1d4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第496题：下一个更大元素I（简单）.9e9c198a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第49题：字母异位词分组（哈希表）.c00a9aee.js"><link rel="prefetch" href="/assets/js/page-「力扣」第4题：寻找两个有序数组的中位数（困难）.89762331.js"><link rel="prefetch" href="/assets/js/page-「力扣」第503题：下一个更大元素II（中等）.690d0832.js"><link rel="prefetch" href="/assets/js/page-「力扣」第507题：完美数（简单）.adff08a8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第508题：出现次数最多的子树元素和（中等）.985b7752.js"><link rel="prefetch" href="/assets/js/page-「力扣」第509题：斐波拉契数列（简单）.ad669140.js"><link rel="prefetch" href="/assets/js/page-「力扣」第50题：Pow(x,n).af5a7d9b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第50题：Pow(x,n)（中等）.470b62ff.js"><link rel="prefetch" href="/assets/js/page-「力扣」第516题：最长回文子序列（中等）.5bd6daf8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第518题：零钱兑换II（中等）.494fb44e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第51题：N皇后（困难）.47e072d0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第523题：连续的子数组（中等）.a1939c5c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第525题：连续数组（中等）.fa7eb1ea.js"><link rel="prefetch" href="/assets/js/page-「力扣」第529题：扫雷问题（中等）.3985d69f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第52题：N-QueensII（困难）.937faf57.js"><link rel="prefetch" href="/assets/js/page-「力扣」第53题：最大子序和（中等）.76face16.js"><link rel="prefetch" href="/assets/js/page-「力扣」第542题：01矩阵（中等）.5257b8b7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第543题：二叉树的直径（简单）.f2b1c426.js"><link rel="prefetch" href="/assets/js/page-「力扣」第547题：朋友圈（中等）.757657f7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第560题：和为K的子数组（中等）.2816ac36.js"><link rel="prefetch" href="/assets/js/page-「力扣」第567题：字符串的排列（中等、滑动窗口）.7a743a7c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第56题：合并区间（中等）.2a1ea5fc.js"><link rel="prefetch" href="/assets/js/page-「力扣」第572题：另一个树的子树（简单）.4b8e000e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第57题：插入区间（中等）.f164ac76.js"><link rel="prefetch" href="/assets/js/page-「力扣」第581题：最短无序连续子数组（中等）.77288fe2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第5题：最长回文子串（中等）.4cf8b3d0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第60题：第k个排列（困难）.267b9277.js"><link rel="prefetch" href="/assets/js/page-「力扣」第611题：有效三角形的个数（中等）.d3f1a483.js"><link rel="prefetch" href="/assets/js/page-「力扣」第61题：旋转链表（中等）.a72004a5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第621题：任务调度器（中等）.4ab870aa.js"><link rel="prefetch" href="/assets/js/page-「力扣」第622题：设计循环队列（中等）.b96d307e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第62题：不同路径（中等）.b22774fc.js"><link rel="prefetch" href="/assets/js/page-「力扣」第630题：课程表III（困难）.840832bb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第633题：平方数之和（简单）.6cae8026.js"><link rel="prefetch" href="/assets/js/page-「力扣」第63题：不同路径II（中等）.1bc21178.js"><link rel="prefetch" href="/assets/js/page-「力扣」第641题：设计循环双端队列（中等）.652ac4e8.js"><link rel="prefetch" href="/assets/js/page-「力扣」第643题：子数组最大平均数I（简单）.6a8b153b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第648题：单词替换（中等）.fe4c7a94.js"><link rel="prefetch" href="/assets/js/page-「力扣」第64题：最小路径和（中等）.50087227.js"><link rel="prefetch" href="/assets/js/page-「力扣」第658题：找到K个最接近的元素（中等）.f72f39b0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第664题：奇怪的打印机（困难）.582c7c1b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第66题：加1（简单）.9452476c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第674题：最长连续递增序列（简单）.9dd4d5d5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第677题：键值映射（中等）.0490b0cd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第67题：二进制求和（简单）.e9fe708b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第684题：冗余连接（中等）.17ef2e24.js"><link rel="prefetch" href="/assets/js/page-「力扣」第685题：冗余连接II（困难）.bc2acf7e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第687题：最长同值路径（中等）.b1744d8e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第690题：员工的重要性（中等）.0c486537.js"><link rel="prefetch" href="/assets/js/page-「力扣」第69题：x的平方根（简单）.fa69495e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第703题：数据流中的第K大元素（简单）.45e74ffa.js"><link rel="prefetch" href="/assets/js/page-「力扣」第70题：爬楼梯（简单）.ac7086e4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第713题：乘积小于K的子数组（中等）.80eb847a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第714题：买卖股票的最佳时机含手续费（中等）.c8fff92c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第719题：找出第k小的距离对（困难）.85d61c81.js"><link rel="prefetch" href="/assets/js/page-「力扣」第71题：简化路径（中等）.f0531c74.js"><link rel="prefetch" href="/assets/js/page-「力扣」第720题：词典中最长的单词（简单）.9b5d3a0d.js"><link rel="prefetch" href="/assets/js/page-「力扣」第721题：账户合并（中等）.ad1ac386.js"><link rel="prefetch" href="/assets/js/page-「力扣」第72题：编辑距离（困难）.97adc995.js"><link rel="prefetch" href="/assets/js/page-「力扣」第733题：图像渲染（简单）.27e1e3f7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第739题：每日温度（中等）.38b19ee5.js"><link rel="prefetch" href="/assets/js/page-「力扣」第744题：寻找比目标字母大的最小字母（简单）.aa7b6b9b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第745题：前缀和后缀搜索（困难）.9f421284.js"><link rel="prefetch" href="/assets/js/page-「力扣」第746题：使用最小花费爬楼梯（简单）.cea20eea.js"><link rel="prefetch" href="/assets/js/page-「力扣」第752题：打开转盘锁（中等）.914d15d0.js"><link rel="prefetch" href="/assets/js/page-「力扣」第75题：颜色分类（中等）.db53e3c2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第765题：情侣牵手（中等）.69fe1613.js"><link rel="prefetch" href="/assets/js/page-「力扣」第76题以及同类问题.fb14eb76.js"><link rel="prefetch" href="/assets/js/page-「力扣」第76题：最小覆盖子串（困难）.fdb7ae50.js"><link rel="prefetch" href="/assets/js/page-「力扣」第773题：滑动谜题（困难）.f08eef7a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第778题：水位上升的泳池中游泳（困难）.dd4c7586.js"><link rel="prefetch" href="/assets/js/page-「力扣」第77题：组合（中等）.9eb1c0ed.js"><link rel="prefetch" href="/assets/js/page-「力扣」第784题：字母大小写全排列（中等）.89c01b0f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第78题：子集（中等）.71065293.js"><link rel="prefetch" href="/assets/js/page-「力扣」第79题：单词搜索（中等）.88c932ec.js"><link rel="prefetch" href="/assets/js/page-「力扣」第802题：找到最终的安全状态（中等）.09dcdb9c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第803题：打砖块（困难）.6d9c906b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第81题：搜索旋转排序数组II（中等）.7ef8022a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第82题：删除排序链表中的重复元素II（中等）.ddccaaf9.js"><link rel="prefetch" href="/assets/js/page-「力扣」第836题：矩形重叠（简单）.abdf21e1.js"><link rel="prefetch" href="/assets/js/page-「力扣」第83题：删除排序链表中的重复元素（简单）.866f029a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第842题：将数组拆分成斐波那契序列（中等）.cddac8f9.js"><link rel="prefetch" href="/assets/js/page-「力扣」第84题：柱状图中最大的矩形（困难）.30026b8e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第852题：山脉数组的峰顶索引（简单）.64f81f7b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第860题：柠檬水找零（简单）.6cb961e3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第861题：翻转矩阵后的得分（中等）.bfb762e9.js"><link rel="prefetch" href="/assets/js/page-「力扣」第863题：二叉树中所有距离为K的结点（中等）.b8f49261.js"><link rel="prefetch" href="/assets/js/page-「力扣」第865题：具有所有最深节点的最小子树（中等）.7f724ba3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第868题：二进制间距（简单）.83a8ddb7.js"><link rel="prefetch" href="/assets/js/page-「力扣」第86题：分隔链表（中等）.2b62c8aa.js"><link rel="prefetch" href="/assets/js/page-「力扣」第875题：爱吃香蕉的珂珂（中等）.d586355e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第876题：链表的中间结点（简单）.f1397072.js"><link rel="prefetch" href="/assets/js/page-「力扣」第877题：石子游戏（中等）.3c9ed662.js"><link rel="prefetch" href="/assets/js/page-「力扣」第881题：救生艇（中等）.9f82399c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第88题：合并两个有序数组（简单）.5e980067.js"><link rel="prefetch" href="/assets/js/page-「力扣」第897题：递增顺序查找树（中等）.07b26601.js"><link rel="prefetch" href="/assets/js/page-「力扣」第8题：字符串转换整数(atoi)（中等）.a1598ce4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第904题：水果成篮（中等）.35d92f3c.js"><link rel="prefetch" href="/assets/js/page-「力扣」第907题：子数组的最小值之和（中等）.104e9a92.js"><link rel="prefetch" href="/assets/js/page-「力扣」第90题：子集II（中等）.e0ab5bb4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第918题：环形子数组的最大和（中等）.8a0bdbcd.js"><link rel="prefetch" href="/assets/js/page-「力扣」第91题：解码方法（中等）.43e2d23a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第921题：使括号有效的最少添加（中等）.057dd60a.js"><link rel="prefetch" href="/assets/js/page-「力扣」第92题：反转链表II（中等）.071ef37f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第933题：最近的请求次数（简单）.3830a25f.js"><link rel="prefetch" href="/assets/js/page-「力扣」第93题：复原IP地址（中等）.2f15c821.js"><link rel="prefetch" href="/assets/js/page-「力扣」第945题：使数组唯一的最小增量（中等）.140de9fb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第946题：验证栈序列（中等）.8bb08704.js"><link rel="prefetch" href="/assets/js/page-「力扣」第947题：移除最多的同行或同列石头（中等）.f53e29e2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第94题：二叉树的中序遍历（中等）.82bf5b7b.js"><link rel="prefetch" href="/assets/js/page-「力扣」第94题：二叉树的中序遍历（简单）.ea5816c2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第951题：翻转等价二叉树（中等）.e300adcc.js"><link rel="prefetch" href="/assets/js/page-「力扣」第952题：按公因数计算最大组件大小（困难）.c7d4b795.js"><link rel="prefetch" href="/assets/js/page-「力扣」第959题：由斜杠划分区域（中等）.08f27d00.js"><link rel="prefetch" href="/assets/js/page-「力扣」第95题：不同的二叉搜索树II（中等）.80bcf189.js"><link rel="prefetch" href="/assets/js/page-「力扣」第962题：最大宽度坡（中等）.1ae6ad46.js"><link rel="prefetch" href="/assets/js/page-「力扣」第968题：监控二叉树（困难）.c1cc04b2.js"><link rel="prefetch" href="/assets/js/page-「力扣」第96题：不同的二叉搜索树（中等）.ef0bc70e.js"><link rel="prefetch" href="/assets/js/page-「力扣」第973题：最接近原点的K个点（中等）.b04f2ccb.js"><link rel="prefetch" href="/assets/js/page-「力扣」第974题：和可被K整除的子数组（中等）.16450ca6.js"><link rel="prefetch" href="/assets/js/page-「力扣」第977题：有序数组的平方（简单）.be3d3ee3.js"><link rel="prefetch" href="/assets/js/page-「力扣」第978题：最长湍流子数组（中等）.5f2fa5da.js"><link rel="prefetch" href="/assets/js/page-「力扣」第983题：最低票价（中等）.c38a5087.js"><link rel="prefetch" href="/assets/js/page-「力扣」第98题：验证二叉搜索树（中等）.a5b89726.js"><link rel="prefetch" href="/assets/js/page-「力扣」第990题：等式方程的可满足性（中等）.aec12a90.js"><link rel="prefetch" href="/assets/js/page-「力扣」第993题：二叉树的堂兄弟节点.dab71397.js"><link rel="prefetch" href="/assets/js/page-「力扣」第993题：二叉树的堂兄弟节点（简单）.59c8faf4.js"><link rel="prefetch" href="/assets/js/page-「力扣」第994题：腐烂的橘子（中等）.ab0ad053.js"><link rel="prefetch" href="/assets/js/page-「力扣」问题回答.99ea6a42.js"><link rel="prefetch" href="/assets/js/page-「双指针」简介.897e0b48.js"><link rel="prefetch" href="/assets/js/page-「程序员面试金典」1714最小K个数（中等）.92b01b63.js"><link rel="prefetch" href="/assets/js/page-「闲谈」板块简介.bd113e01.js"><link rel="prefetch" href="/assets/js/page-「闲谈」简介.67675769.js"><link rel="prefetch" href="/assets/js/page-一些无处安放的链接.9280e34a.js"><link rel="prefetch" href="/assets/js/page-专题：前缀和与哈希表.7f9bab26.js"><link rel="prefetch" href="/assets/js/page-二分查找.e3d0d144.js"><link rel="prefetch" href="/assets/js/page-二分查找习题列表.3c60fdc2.js"><link rel="prefetch" href="/assets/js/page-二叉树.37cf5902.js"><link rel="prefetch" href="/assets/js/page-优先队列的应用.ee320b44.js"><link rel="prefetch" href="/assets/js/page-优先队列精讲.4973ce43.js"><link rel="prefetch" href="/assets/js/page-位运算.f6aaa08c.js"><link rel="prefetch" href="/assets/js/page-使用数据结构的滑动窗口问题.1ab8fda3.js"><link rel="prefetch" href="/assets/js/page-例1：「力扣」第26题：删除排序数组中的重复项（简单）.70232089.js"><link rel="prefetch" href="/assets/js/page-例2：「力扣」第283题：移动零（简单）.fb2e7ae9.js"><link rel="prefetch" href="/assets/js/page-例3：「力扣」第27题：移除元素（简单）.88601e81.js"><link rel="prefetch" href="/assets/js/page-例4：「力扣」第80题：删除排序数组中的重复项II（中等）.c15d1b45.js"><link rel="prefetch" href="/assets/js/page-关于我在「力扣」上回答问题的点点滴滴.f39722cd.js"><link rel="prefetch" href="/assets/js/page-关于这部分视频的说明.cc683a9b.js"><link rel="prefetch" href="/assets/js/page-前缀和.06a22bbd.js"><link rel="prefetch" href="/assets/js/page-前缀树.d5afec85.js"><link rel="prefetch" href="/assets/js/page-剑指Offer38字符串的排列.e2aa6a4f.js"><link rel="prefetch" href="/assets/js/page-剑指Offer（第2版）与「力扣」问题的对应关系.5cb8eb4a.js"><link rel="prefetch" href="/assets/js/page-动态规划（语雀的笔记）.191f97f9.js"><link rel="prefetch" href="/assets/js/page-单调栈.8b400350.js"><link rel="prefetch" href="/assets/js/page-历史的天空（电视剧《三国演义》片尾曲，演唱：毛阿敏）.a16d7c3a.js"><link rel="prefetch" href="/assets/js/page-双指针习题分类.8b2f0a64.js"><link rel="prefetch" href="/assets/js/page-变更日志.faea4a18.js"><link rel="prefetch" href="/assets/js/page-哈希表.2c07e844.js"><link rel="prefetch" href="/assets/js/page-回溯算法重点概括.567845df.js"><link rel="prefetch" href="/assets/js/page-固定长度的滑动窗口问题.770c1655.js"><link rel="prefetch" href="/assets/js/page-图论算法概述.b5b3c9f4.js"><link rel="prefetch" href="/assets/js/page-学习算法没有捷径.74e8d5cc.js"><link rel="prefetch" href="/assets/js/page-完全背包公式推导.14851b95.js"><link rel="prefetch" href="/assets/js/page-差分.c51639d5.js"><link rel="prefetch" href="/assets/js/page-广度优先遍历直观.86fb1a7c.js"><link rel="prefetch" href="/assets/js/page-归并排序简介.e922057b.js"><link rel="prefetch" href="/assets/js/page-循环不变量重点概括.cc7cafdf.js"><link rel="prefetch" href="/assets/js/page-快来算法吧.aeee6df7.js"><link rel="prefetch" href="/assets/js/page-快速排序.bef1de11.js"><link rel="prefetch" href="/assets/js/page-总结.70a17986.js"><link rel="prefetch" href="/assets/js/page-懂你（演唱：满文军）.10433d78.js"><link rel="prefetch" href="/assets/js/page-我对算法「题」的偏见.03158b6d.js"><link rel="prefetch" href="/assets/js/page-拓扑排序简介.a6632ef8.js"><link rel="prefetch" href="/assets/js/page-数学.567a9c53.js"><link rel="prefetch" href="/assets/js/page-数组.d5c100c4.js"><link rel="prefetch" href="/assets/js/page-最大值最小化简介.f21928c3.js"><link rel="prefetch" href="/assets/js/page-本章内容介绍（请先看这里）.3a339a85.js"><link rel="prefetch" href="/assets/js/page-栈.e6ea9ad0.js"><link rel="prefetch" href="/assets/js/page-树形DP简介.f65ec774.js"><link rel="prefetch" href="/assets/js/page-梦想破碎的2021年.ab3a3bb3.js"><link rel="prefetch" href="/assets/js/page-模板不重要（转载）.b84312d8.js"><link rel="prefetch" href="/assets/js/page-滑动窗口.24502918.js"><link rel="prefetch" href="/assets/js/page-滚滚长江东逝水（电视剧《三国演义》片尾曲，演唱：杨洪基）.23bf470d.js"><link rel="prefetch" href="/assets/js/page-第0章参考资料.4151ac7e.js"><link rel="prefetch" href="/assets/js/page-第10章链表.5fcd23b2.js"><link rel="prefetch" href="/assets/js/page-第10节「快速排序」总结.eac56f12.js"><link rel="prefetch" href="/assets/js/page-第10节从学习「二分查找」窥见算法学习的一般方法.1f26e471.js"><link rel="prefetch" href="/assets/js/page-第11章栈.9f32883e.js"><link rel="prefetch" href="/assets/js/page-第12章队列.90892024.js"><link rel="prefetch" href="/assets/js/page-第13章二叉树.c05693a9.js"><link rel="prefetch" href="/assets/js/page-第13章优先队列（堆）.6adbb06f.js"><link rel="prefetch" href="/assets/js/page-第15章二分搜索树.e8ab4559.js"><link rel="prefetch" href="/assets/js/page-第15章二叉搜索树.e9b0cc23.js"><link rel="prefetch" href="/assets/js/page-第16章哈希表.86e0ee63.js"><link rel="prefetch" href="/assets/js/page-第17章回溯算法.4330b8d4.js"><link rel="prefetch" href="/assets/js/page-第18章前缀和与哈希表.f67c1e28.js"><link rel="prefetch" href="/assets/js/page-第18章广度优先遍历.2501fd15.js"><link rel="prefetch" href="/assets/js/page-第19章动态规划.38b5d5db.js"><link rel="prefetch" href="/assets/js/page-第1节二分查找的基本思想.260b2171.js"><link rel="prefetch" href="/assets/js/page-第1节什么是动态规划.a37c7262.js"><link rel="prefetch" href="/assets/js/page-第1节优先队列简介.be135a84.js"><link rel="prefetch" href="/assets/js/page-第1节快速排序的基本思想.03047f80.js"><link rel="prefetch" href="/assets/js/page-第2章二分查找、滑动窗口、双指针.7dbd2e09.js"><link rel="prefetch" href="/assets/js/page-第2章练习题精讲简介（先看这里）.8413594e.js"><link rel="prefetch" href="/assets/js/page-第2节partition.1e108aae.js"><link rel="prefetch" href="/assets/js/page-第2节「力扣」上一类问题的特点（极其重要）.6967290f.js"><link rel="prefetch" href="/assets/js/page-第2节为什么取中间.8351df29.js"><link rel="prefetch" href="/assets/js/page-第2节优先队列的实现.141c98eb.js"><link rel="prefetch" href="/assets/js/page-第2节动态规划用于解决怎样的问题.cc73adf4.js"><link rel="prefetch" href="/assets/js/page-第3章基础排序算法.017edceb.js"><link rel="prefetch" href="/assets/js/page-第3节「动态规划」的算法设计思想.74cca739.js"><link rel="prefetch" href="/assets/js/page-第3节快速排序（第1版代码）.b3a43d0f.js"><link rel="prefetch" href="/assets/js/page-第3节把区间分成两个部分.3430723b.js"><link rel="prefetch" href="/assets/js/page-第3节把区间分成两个部分（重要）.5e5bc969.js"><link rel="prefetch" href="/assets/js/page-第3节最大堆的第1个重要操作：SiftUp.dd769360.js"><link rel="prefetch" href="/assets/js/page-第4节SiftDown.65db633b.js"><link rel="prefetch" href="/assets/js/page-第4节为什么需要上取整.a3bd0352.js"><link rel="prefetch" href="/assets/js/page-第4节二分查找万能模板.6ed17428.js"><link rel="prefetch" href="/assets/js/page-第4节自顶向下与自底向上.e153e0d6.js"><link rel="prefetch" href="/assets/js/page-第4节随机选择切分元素.c27311fb.js"><link rel="prefetch" href="/assets/js/page-第5节写分支逻辑的经验.b2f08643.js"><link rel="prefetch" href="/assets/js/page-第5节双路快排.1b0cf6a1.js"><link rel="prefetch" href="/assets/js/page-第5节堆排序、heapify、原地堆排序.9ceccab4.js"><link rel="prefetch" href="/assets/js/page-第5节死循环（什么时候取mid+1）.270cf444.js"><link rel="prefetch" href="/assets/js/page-第5节状态与状态转移方程.03dc1f5e.js"><link rel="prefetch" href="/assets/js/page-第6章非比较排序.f9410f49.js"><link rel="prefetch" href="/assets/js/page-第6节三路快排.c38ce967.js"><link rel="prefetch" href="/assets/js/page-第6节二分查找的应用.84173280.js"><link rel="prefetch" href="/assets/js/page-第6节关于mid=(left+right)2的说明.db127628.js"><link rel="prefetch" href="/assets/js/page-第6节最优子结构、重复子问题、无后效性.1d1a81e4.js"><link rel="prefetch" href="/assets/js/page-第6节索引堆.63f7e822.js"><link rel="prefetch" href="/assets/js/page-第7节while(leftright)一定表示左闭右开吗？.43a18217.js"><link rel="prefetch" href="/assets/js/page-第7节三种划分方式总结.781c1f07.js"><link rel="prefetch" href="/assets/js/page-第7节几种二分查找的写法比较.f4dddb2c.js"><link rel="prefetch" href="/assets/js/page-第7节阶段、状态、选择.1814832b.js"><link rel="prefetch" href="/assets/js/page-第8节三种二分查找模板对比.33915dec.js"><link rel="prefetch" href="/assets/js/page-第8节再次理解「循环不变量」.0bbe6656.js"><link rel="prefetch" href="/assets/js/page-第8节超级重要的动态规划问题.712842db.js"><link rel="prefetch" href="/assets/js/page-第9节再次理解「递归」.af614a04.js"><link rel="prefetch" href="/assets/js/page-第9节写对「二分查找」的经验.49afb024.js"><link rel="prefetch" href="/assets/js/page-第9节总结.53e8a4d9.js"><link rel="prefetch" href="/assets/js/page-简介.e5cfcfdf.js"><link rel="prefetch" href="/assets/js/page-精选题解.32197443.js"><link rel="prefetch" href="/assets/js/page-线段树北美讲题大纲.c0f408e3.js"><link rel="prefetch" href="/assets/js/page-练习.8e2e0ca0.js"><link rel="prefetch" href="/assets/js/page-给本站留言.30291bb7.js"><link rel="prefetch" href="/assets/js/page-视频题解合集.c34109e1.js"><link rel="prefetch" href="/assets/js/page-请见专栏「二分查找精讲」.162c0876.js"><link rel="prefetch" href="/assets/js/page-谋生的路上不抛弃良知.e105413f.js"><link rel="prefetch" href="/assets/js/page-贪心算法.5fe7cdc9.js"><link rel="prefetch" href="/assets/js/page-软件工程师和算法竞赛（转载）.e9f12927.js"><link rel="prefetch" href="/assets/js/page-这一拜（电视剧《三国演义》插曲，演唱：刘欢）.b31656bb.js"><link rel="prefetch" href="/assets/js/page-链表问题.fba3945e.js"><link rel="prefetch" href="/assets/js/page-链表问题简介.84be809e.js"><link rel="prefetch" href="/assets/js/page-队列.114c7587.js"><link rel="prefetch" href="/assets/js/page-音乐欣赏.040f8f84.js"><link rel="prefetch" href="/assets/js/page-高级程序员不是追求的目标（雷军）.ce624fe2.js"><link rel="prefetch" href="/assets/js/page-（会员题）「力扣」第159题：至多包含两个不同字符的最长子串（中等）.b31ffab1.js"><link rel="prefetch" href="/assets/js/page-（会员题）「力扣」第340题：至多包含K个不同字符的最长子串（中等）.256d304c.js"><link rel="prefetch" href="/assets/js/page-（公众号文章）「动态规划」为什么叫「动态规划」.54a821b1.js"><link rel="prefetch" href="/assets/js/page-（公众号文章）从「最大子段和」问题谈如何设计状态（定义子问题）.341643ff.js"><link rel="prefetch" href="/assets/js/page-（公众号文章）再讲「树形DP」是个什么玩意儿.55ab3383.js"><link rel="prefetch" href="/assets/js/page-（公众号文章）树形DP是个什么玩意儿.6c87f808.js"><link rel="prefetch" href="/assets/js/vendors~chart.a73fd952.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.b9789e78.js"><link rel="prefetch" href="/assets/js/vendors~mermaid.2b66d3a7.js"><link rel="prefetch" href="/assets/js/vendors~photo-swipe.49a8ad49.js"><link rel="prefetch" href="/assets/js/vendors~reveal.91831e04.js"><link rel="prefetch" href="/assets/js/vendors~valine.cfdab08c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.aeb49c51.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container has-navbar has-sidebar has-anchor"><header class="navbar"><!----> <div class="content__navbar-start"></div> <button title="Sidebar Button" class="sidebar-button"><span class="icon"></span></button> <a href="/" class="home-link router-link-active"><img src="/suanfa8.png" alt="算法吧" class="logo"> <!----> <span class="site-name can-hide">算法吧</span></a> <!----> <div class="content__navbar-center"></div> <div class="links"><button tabindex="-1" aria-hidden="true" class="color-button"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="skin-icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4
        38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32
        51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0
        102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2
        6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4
        0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2
        9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224
        419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4
        470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0
        22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6
        12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128
        505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2
        16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8
        86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4
        80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6
        6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><!----> <div class="darkmode-toggle"><label for="darkmode-toggle" class="desc">Theme Mode:</label> <div class="darkmode-switch"><div class="item day"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon light-icon"><path d="M512 256a42.667 42.667 0 0 0 42.667-42.667V128a42.667 42.667 0 0 0-85.334 0v85.333A42.667 42.667 0 0 0 512 256zm384 213.333h-85.333a42.667 42.667 0 0 0 0 85.334H896a42.667 42.667 0 0 0 0-85.334zM256 512a42.667 42.667 0 0 0-42.667-42.667H128a42.667 42.667 0 0 0 0 85.334h85.333A42.667 42.667 0 0 0 256 512zm9.387-298.667a42.667 42.667 0 0 0-59.307 62.72l61.44 59.307a42.667 42.667 0 0 0 31.147 11.947 42.667 42.667 0 0 0 30.72-13.227 42.667 42.667 0 0 0 0-60.16zm459.946 133.974a42.667 42.667 0 0 0 29.44-11.947l61.44-59.307a42.667 42.667 0 0 0-57.6-62.72l-61.44 60.587a42.667 42.667 0 0 0 0 60.16 42.667 42.667 0 0 0 28.16 13.227zM512 768a42.667 42.667 0 0 0-42.667 42.667V896a42.667 42.667 0 0 0 85.334 0v-85.333A42.667 42.667 0 0 0 512 768zm244.48-79.36a42.667 42.667 0 0 0-59.307 61.44l61.44 60.587a42.667 42.667 0 0 0 29.44 11.946 42.667 42.667 0 0 0 30.72-12.8 42.667 42.667 0 0 0 0-60.586zm-488.96 0-61.44 59.307a42.667 42.667 0 0 0 0 60.586 42.667 42.667 0 0 0 30.72 12.8 42.667 42.667 0 0 0 28.587-10.666l61.44-59.307a42.667 42.667 0 0 0-59.307-61.44zM512 341.333A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333z" fill="currentColor"></path></svg></div> <div class="item auto active"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon auto-icon"><path d="M460.864 539.072H564.8L510.592 376l-49.728 163.072zM872 362.368V149.504H659.648L510.528 0l-149.12 149.504H149.12v212.928L0 511.872l149.12 149.504v212.928h212.352l149.12 149.504 149.12-149.504h212.352V661.376l149.12-149.504L872 362.368zM614.464 693.12l-31.616-90.624H438.272l-31.616 90.624h-85.888l144.576-407.68h90.368l144.576 407.68h-85.824zm0 0" fill="currentColor"></path></svg></div> <div class="item night"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon dark-icon"><path d="M935.539 630.402c-11.43-11.432-28.674-14.739-43.531-8.354-46.734 20.103-96.363 30.297-147.508 30.297-99.59 0-193.221-38.784-263.64-109.203-108.637-108.637-139.61-270.022-78.908-411.148a39.497 39.497 0 0 0-51.886-51.887c-52.637 22.64-100.017 54.81-140.826 95.616-85.346 85.346-132.346 198.821-132.346 319.52 0 120.7 47.001 234.172 132.347 319.519S408.063 947.11 528.76 947.11c120.7 0 234.172-47.003 319.52-132.351 40.809-40.81 72.978-88.19 95.616-140.826a39.497 39.497 0 0 0-8.356-43.532z" fill="currentColor"></path></svg></div></div> <!----></div></div></div></button> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link router-link-active"><i class="iconfont icon-home"></i>
  主页
</a></div><div class="nav-item"><a href="/video/" class="nav-link"><i class="iconfont icon-shipin"></i>
  视频讲解
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题精讲" class="dropdown-title"><span class="title"><i class="iconfont icon-jingjiang"></i>
        专题精讲
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>算法精讲</span></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/loop-invariant/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  循环不变量
</a></li><li class="dropdown-subitem"><a href="/binary-search/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  二分查找
</a></li><li class="dropdown-subitem"><a href="/sliding-window/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  滑动窗口
</a></li><li class="dropdown-subitem"><a href="/two-pointers/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  双指针
</a></li><li class="dropdown-subitem"><a href="/merge-sort/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  归并排序
</a></li><li class="dropdown-subitem"><a href="/quick-sort/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  快速排序
</a></li><li class="dropdown-subitem"><a href="/backtracking/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  回溯算法（深度优先遍历）
</a></li><li class="dropdown-subitem"><a href="/breadth-first-search/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  广度优先遍历与拓扑排序
</a></li><li class="dropdown-subitem"><a href="/dynamic-programming/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  动态规划
</a></li><li class="dropdown-subitem"><a href="/greedy/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  贪心算法
</a></li><li class="dropdown-subitem"><a href="/graph/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  图论精讲
</a></li><li class="dropdown-subitem"><a href="/math/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  数学
</a></li><li class="dropdown-subitem"><a href="/bit-manipulation/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  位运算
</a></li><li class="dropdown-subitem"><a href="/difference/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  差分
</a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据结构精讲</span></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/array/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  数组
</a></li><li class="dropdown-subitem"><a href="/linked-list/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  链表
</a></li><li class="dropdown-subitem"><a href="/stack/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  栈
</a></li><li class="dropdown-subitem"><a href="/monotonous-stack/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  单调栈
</a></li><li class="dropdown-subitem"><a href="/queue/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  队列
</a></li><li class="dropdown-subitem"><a href="/heap/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  优先队列（堆）
</a></li><li class="dropdown-subitem"><a href="/tree/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  二叉树与二叉搜索树
</a></li><li class="dropdown-subitem"><a href="/hash-table/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  哈希表
</a></li><li class="dropdown-subitem"><a href="/presum-hashtable/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  前缀和与哈希表
</a></li><li class="dropdown-subitem"><a href="/union-find/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  并查集
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="系统功能" class="dropdown-title"><span class="title"><i class="iconfont icon-xitong"></i>
        系统功能
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="/article/" class="nav-link"><i class="iconfont icon-wenzhangliebiaoxiangqing"></i>
  文章列表
</a></li><li class="dropdown-item"><a href="/category/" class="nav-link"><i class="iconfont icon-fenlei"></i>
  按分类
</a></li><li class="dropdown-item"><a href="/tag/" class="nav-link"><i class="iconfont icon-biaoqian"></i>
  按标签
</a></li><li class="dropdown-item"><a href="/timeline/" class="nav-link"><i class="iconfont icon-shijianxian"></i>
  文章时间线
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="友情链接" class="dropdown-title"><span class="title"><i class="iconfont icon-youqinglianjie"></i>
        友情链接
      </span> <span class="arrow"></span></button> <ul class="nav-dropdown"><li class="dropdown-item"><a href="https://fuxuemingzhu.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-youqinglianjie"></i>
  负雪明烛
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><a href="https://leetcode.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-youqinglianjie"></i>
  LeetCode（中国）
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/chat/" class="nav-link"><i class="iconfont icon-xianliaoshequ"></i>
  闲聊
</a></div><div class="nav-item"><a href="/music/" class="nav-link"><i class="iconfont icon-gequxinshang"></i>
  音乐
</a></div><div class="nav-item"><a href="/suanfa8/bulletin-board.html" class="nav-link"><i class="iconfont icon-liuyanban-05"></i>
  留言反馈
</a></div></nav> <!----> <a rel="noopener noreferrer" href="https://github.com/liweiwei1419/liweiwei1419.github.io" target="_blank" class="repo-link can-hide">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <!----> <div class="content__navbar-end"></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <!----> <div class="content__sidebar-top"></div> <nav class="sidebar-nav-links"><div class="nav-item"><a href="/" class="nav-link router-link-active"><i class="iconfont icon-home"></i>
  主页
</a></div><div class="nav-item"><a href="/video/" class="nav-link"><i class="iconfont icon-shipin"></i>
  视频讲解
</a></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="专题精讲" class="dropdown-title"><span class="title"><i class="iconfont icon-jingjiang"></i>
      专题精讲
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>算法精讲</span></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/loop-invariant/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  循环不变量
</a></li><li class="dropdown-subitem"><a href="/binary-search/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  二分查找
</a></li><li class="dropdown-subitem"><a href="/sliding-window/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  滑动窗口
</a></li><li class="dropdown-subitem"><a href="/two-pointers/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  双指针
</a></li><li class="dropdown-subitem"><a href="/merge-sort/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  归并排序
</a></li><li class="dropdown-subitem"><a href="/quick-sort/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  快速排序
</a></li><li class="dropdown-subitem"><a href="/backtracking/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  回溯算法（深度优先遍历）
</a></li><li class="dropdown-subitem"><a href="/breadth-first-search/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  广度优先遍历与拓扑排序
</a></li><li class="dropdown-subitem"><a href="/dynamic-programming/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  动态规划
</a></li><li class="dropdown-subitem"><a href="/greedy/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  贪心算法
</a></li><li class="dropdown-subitem"><a href="/graph/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  图论精讲
</a></li><li class="dropdown-subitem"><a href="/math/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  数学
</a></li><li class="dropdown-subitem"><a href="/bit-manipulation/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  位运算
</a></li><li class="dropdown-subitem"><a href="/difference/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  差分
</a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据结构精讲</span></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/array/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  数组
</a></li><li class="dropdown-subitem"><a href="/linked-list/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  链表
</a></li><li class="dropdown-subitem"><a href="/stack/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  栈
</a></li><li class="dropdown-subitem"><a href="/monotonous-stack/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  单调栈
</a></li><li class="dropdown-subitem"><a href="/queue/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  队列
</a></li><li class="dropdown-subitem"><a href="/heap/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  优先队列（堆）
</a></li><li class="dropdown-subitem"><a href="/tree/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  二叉树与二叉搜索树
</a></li><li class="dropdown-subitem"><a href="/hash-table/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  哈希表
</a></li><li class="dropdown-subitem"><a href="/presum-hashtable/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  前缀和与哈希表
</a></li><li class="dropdown-subitem"><a href="/union-find/" class="nav-link"><i class="iconfont icon-jingjiang"></i>
  并查集
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="系统功能" class="dropdown-title"><span class="title"><i class="iconfont icon-xitong"></i>
      系统功能
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/" class="nav-link"><i class="iconfont icon-wenzhangliebiaoxiangqing"></i>
  文章列表
</a></li><li class="dropdown-item"><!----> <a href="/category/" class="nav-link"><i class="iconfont icon-fenlei"></i>
  按分类
</a></li><li class="dropdown-item"><!----> <a href="/tag/" class="nav-link"><i class="iconfont icon-biaoqian"></i>
  按标签
</a></li><li class="dropdown-item"><!----> <a href="/timeline/" class="nav-link"><i class="iconfont icon-shijianxian"></i>
  文章时间线
</a></li></ul></div></div><div class="nav-item"><div class="mobile-dropdown-wrapper"><button type="button" aria-label="友情链接" class="dropdown-title"><span class="title"><i class="iconfont icon-youqinglianjie"></i>
      友情链接
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://fuxuemingzhu.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-youqinglianjie"></i>
  负雪明烛
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://leetcode.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont icon-youqinglianjie"></i>
  LeetCode（中国）
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/chat/" class="nav-link"><i class="iconfont icon-xianliaoshequ"></i>
  闲聊
</a></div><div class="nav-item"><a href="/music/" class="nav-link"><i class="iconfont icon-gequxinshang"></i>
  音乐
</a></div><div class="nav-item"><a href="/suanfa8/bulletin-board.html" class="nav-link"><i class="iconfont icon-liuyanban-05"></i>
  留言反馈
</a></div> <a rel="noopener noreferrer" href="https://github.com/liweiwei1419/liweiwei1419.github.io" target="_blank" class="repo-link">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <!----> <div class="content__sidebar-center"></div> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><i class="iconfont icon-book"></i> <span class="title">第 1 部分 树的基本问题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable open"><i class="iconfont icon-book"></i> <span class="title">第 2 部分 二分搜索树</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/data-structure/binary-search-tree/" aria-current="page" class="active sidebar-link">《算法与数据结构》学习笔记8：二分搜索树</a></li><li><a href="/tree/solutions/1008-construct-binary-search-tree-from-preorder-traversal/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 1008 题：前序遍历构造二叉搜索树（中等）</a></li><li><a href="/tree/solutions/0095-unique-binary-search-trees-ii/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 95 题：不同的二叉搜索树 II（中等）</a></li><li><a href="/tree/solutions/0098-validate-binary-search-tree/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 98 题：验证二叉搜索树（中等）</a></li><li><a href="/tree/solutions/0108-convert-sorted-array-to-binary-search-tree/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 108 题：将有序数组转换为二叉搜索树（简单）</a></li><li><a href="/tree/solutions/0109-convert-sorted-list-to-binary-search-tree/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 109 题：有序链表转换二叉搜索树（中等）</a></li><li><a href="/tree/solutions/0220-contains-duplicate-iii/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 220 题： 存在重复元素 III（中等）</a></li><li><a href="/tree/solutions/0230-kth-smallest-element-in-a-bst/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 230 题：二叉搜索树中第 K 小的元素（中等）</a></li><li><a href="/tree/solutions/0235-lowest-common-ancestor-of-a-binary-search-tree/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 235 题：二叉搜索树的最近公共祖先（中等）</a></li><li><a href="/tree/solutions/0449-serialize-and-deserialize-bst/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 449 题：序列化和反序列化二叉搜索树（中等）</a></li><li><a href="/tree/solutions/0450-delete-node-in-a-bst/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 450 题：删除二叉搜索树中的节点（中等）</a></li><li><a href="/tree/solutions/0897-increasing-order-search-tree/" class="sidebar-link"><i class="iconfont icon-yongyan"></i>「力扣」第 897 题：递增顺序查找树（中等）</a></li></ul></section></li></ul> <!----> <div class="content__sidebar-bottom"></div> <!----></aside> <main class="page"><nav class="breadcrumb disable"><!----></nav> <!----> <div class="content__page-top"></div> <div vocab="https://schema.org/" typeof="Article" class="page-title"><h1><!----> <span property="headline">《算法与数据结构》学习笔记8：二分搜索树</span></h1> <div class="page-info"><!----> <span aria-label="Author🖊" data-balloon-pos="down" categoryPath="/category/$category/" tagPath="/tag/$tag/"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon author-icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z" fill="currentColor"></path></svg> <span property="author">liwei</span></span><span aria-label="Page views🔢" data-balloon-pos="down" defaultAuthor="liweiwei1419" categoryPath="/category/$category/" tagPath="/tag/$tag/" class="visitor-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon eye-icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 0 0-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z" fill="currentColor"></path></svg> <span id="/data-structure/binary-search-tree/" data-flag-title="《算法与数据结构》学习笔记8：二分搜索树" class="leancloud_visitors waline-visitor-count"><span class="leancloud-visitors-count">...</span></span></span><span aria-label="Writing Date📅" data-balloon-pos="down" defaultAuthor="liweiwei1419" categoryPath="/category/$category/" tagPath="/tag/$tag/" class="time-info"><svg viewBox="0 0 1030 1024" xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H180.6A134.314 134.314 0 0 0 46.66 277.595v535.756A134.314 134.314 0 0 0 180.6 947.289h669.74a134.36 134.36 0 0 0 133.94-133.938V277.595a134.314 134.314 0 0 0-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 0 1-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 0 1-33.472 33.473z" fill="currentColor"></path></svg> <span property="datePublished">2018-04-23 08:00:00</span></span><span role="navigation" aria-label="Category🌈" data-balloon-pos="down" defaultAuthor="liweiwei1419" tagPath="/tag/$tag/" class="category-info enable"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon category-icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zm-.854 446.486H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zm446.371-446.486h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zm136.293 813.51H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z" fill="currentColor"></path></svg> <span property="articleSection">算法与数据结构</span></span><span aria-label="Tags🏷" data-balloon-pos="down" defaultAuthor="liweiwei1419" categoryPath="/category/$category/"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon tag-icon"><path d="M939.902 458.563 910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 0 0 0 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z" fill="currentColor"></path></svg> <ul class="tags-wrapper"><li class="tag clickable tag0"><span role="navigation">二分搜索树</span></li></ul> <meta property="keywords" content="二分搜索树"></span><span aria-label="Reading Time⌛" data-balloon-pos="down" defaultAuthor="liweiwei1419" categoryPath="/category/$category/" tagPath="/tag/$tag/" class="reading-time-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon timer-icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z" fill="currentColor"></path></svg> <span>About 42 min</span> <meta property="timeRequired" content="PT42M"></span></div> <!----> <hr></div> <div class="anchor-place-holder"><aside id="anchor"><div class="anchor-wrapper"><ul class="anchor-list"><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-1-基于有序数组的二分查找法" class="anchor-link heading2"><div>8.1 基于有序数组的二分查找法</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-2-二分搜索树-binary-search-tree" class="anchor-link heading2"><div>8.2 二分搜索树（Binary Search Tree）</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-3-二分搜索树的第-1-个操作-向二分搜索树中插入新的结点" class="anchor-link heading2"><div>8.3 二分搜索树的第 1 个操作：向二分搜索树中插入新的结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-4-二分搜索树的第-2-个操作-元素查找和判断是否包含" class="anchor-link heading2"><div>8.4 二分搜索树的第 2 个操作：元素查找和判断是否包含</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-5-二分搜索树的第-3-个操作-深度优先遍历" class="anchor-link heading2"><div>8.5 二分搜索树的第 3 个操作：深度优先遍历</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-6-二分搜索树的第-4-个操作-广度优先遍历" class="anchor-link heading2"><div>8.6 二分搜索树的第 4 个操作：广度优先遍历</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-7-二分搜索树的结点的删除-这部分有一定难度-不过可以分情况讨论" class="anchor-link heading2"><div>8.7 二分搜索树的结点的删除（这部分有一定难度，不过可以分情况讨论）</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-7-1-第-1-种情况-讨论删除二分搜索树中的最小结点和最大结点" class="anchor-link heading3"><div>8.7.1 第 1 种情况：讨论删除二分搜索树中的最小结点和最大结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-7-2-第-2-种情况-讨论删除只有左孩子-子树-或者只有右孩子-子树-的结点" class="anchor-link heading3"><div>8.7.2 第 2 种情况：讨论删除只有左孩子（子树）或者只有右孩子（子树）的结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-7-3-第-3-种情况-删除左右都有孩子-子树-的结点" class="anchor-link heading3"><div>8.7.3 第 3 种情况：删除左右都有孩子（子树）的结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-8-二分搜索树的顺序性" class="anchor-link heading2"><div>8.8 二分搜索树的顺序性</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-9-二分搜索树的局限性" class="anchor-link heading2"><div>8.9 二分搜索树的局限性</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-10-树形问题和更多树" class="anchor-link heading2"><div>8.10 树形问题和更多树</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#_8-11-二分搜索树的代码实现" class="anchor-link heading2"><div>8.11 二分搜索树的代码实现</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#代码实现-java" class="anchor-link heading3"><div>代码实现（Java）</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#bst-的-floor-与-ceiling" class="anchor-link heading2"><div>BST 的 floor 与 ceiling</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#floor-函数的实现" class="anchor-link heading3"><div>floor 函数的实现</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#ceiling-函数的实现" class="anchor-link heading3"><div>ceiling 函数的实现</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#如何查找" class="anchor-link heading2"><div>如何查找</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#初始化-bst" class="anchor-link heading2"><div>初始化 BST</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的操作-增" class="anchor-link heading2"><div>二分搜索树的操作：增</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的操作-查、改" class="anchor-link heading2"><div>二分搜索树的操作：查、改</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的操作-删" class="anchor-link heading2"><div>二分搜索树的操作：删</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#第-1-种情况-删除二分搜索树中的最小结点和最大结点" class="anchor-link heading3"><div>第 1 种情况：删除二分搜索树中的最小结点和最大结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#第-2-种情况-删除只有左孩子-子树-或者只有右孩子-子树-的结点" class="anchor-link heading3"><div>第 2 种情况：删除只有左孩子（子树）或者只有右孩子（子树）的结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#第-3-种情况-删除左右都有孩子-子树-的结点" class="anchor-link heading3"><div>第 3 种情况：删除左右都有孩子（子树）的结点</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的-floor-与-ceiling" class="anchor-link heading2"><div>二分搜索树的 floor 与 ceiling</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#floor-函数的实现-2" class="anchor-link heading3"><div>floor 函数的实现</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#ceiling-函数的实现-2" class="anchor-link heading3"><div>ceiling 函数的实现</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的深度优先遍历" class="anchor-link heading2"><div>二分搜索树的深度优先遍历</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的广度优先遍历" class="anchor-link heading2"><div>二分搜索树的广度优先遍历</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的代码实现" class="anchor-link heading2"><div>二分搜索树的代码实现</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#小结" class="anchor-link heading3"><div>小结</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的顺序性" class="anchor-link heading2"><div>二分搜索树的顺序性</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的局限性" class="anchor-link heading2"><div>二分搜索树的局限性</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#树形问题和更多树" class="anchor-link heading2"><div>树形问题和更多树</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#本文源代码" class="anchor-link heading3"><div>本文源代码</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树" class="anchor-link heading2"><div>二分搜索树</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#「树」专题-6-二分搜索树中的问题" class="anchor-link heading2"><div>「树」专题 6：二分搜索树中的问题</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#回顾二分搜索树的定义" class="anchor-link heading3"><div>回顾二分搜索树的定义</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#二分搜索树的重要性质" class="anchor-link heading3"><div>二分搜索树的重要性质</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#回顾二分搜索树中的基本操作" class="anchor-link heading3"><div>回顾二分搜索树中的基本操作</div></a></li><li class="anchor"><a href="/data-structure/binary-search-tree/#例题" class="anchor-link heading2"><div>例题</div></a></li></ul></div></aside></div> <!----> <div class="content__content-top"></div> <div class="theme-default-content content__default"><h1 id="_8-《算法与数据结构》学习笔记-二分搜索树"><a href="#_8-《算法与数据结构》学习笔记-二分搜索树" class="header-anchor">#</a> 8. 《算法与数据结构》学习笔记：二分搜索树</h1> <h2 id="_8-1-基于有序数组的二分查找法"><a href="#_8-1-基于有序数组的二分查找法" class="header-anchor">#</a> 8.1 基于有序数组的二分查找法</h2> <ul><li><p>查找问题是计算机中非常重要的一类基础问题；</p></li> <li><p>这个问题可以这样理解，在我们的生活中，要想方便地“找东西”，就要在“存东西”的时候多花点心思。例如：我们在“存东西”的时候，会有意识地“分门别类”放好。在我们的计算机中，文件夹呈现的树形结构，就是一种分类存放的策略，我们想要找张三的资料，肯定不会去李四的文件夹下查找。我们去图书馆要找一本《算法》的书，我们肯定不会去标明“文学”的那个书架上找；</p></li> <li><p>学习过 Java 语言的朋友们一定知道 hash 表，我们可以给放进集合中的对象计算一个 hash 值，以后取出来的时候通过计算 hash 值得到之前放进去的对象，这也是一种存放数据和读取数组的策略的策略；</p></li> <li><p>那么“二分查找法”要求数据是怎么存的呢？很简单，只要数据是顺序摆放的，我们就可以用“二分查找算法”。即二分查找法的使用前提：<strong>对于有序的数列才能使用二分查找法</strong>，如果数组无序，就不能使用二分查找法。</p></li></ul> <blockquote><p>“二分查找法”能够根据数组的索引大大减少每次查找所需的比较次数。</p></blockquote> <p>因为每次查找都能缩短一半的查找区间。</p> <ul><li>二分查找法的思想在 1946 年就被提出来了。但是第 1 个没有 bug 的二分查找法在 1962 年才出现。这个 bug  就在于查找两个数的中间数，如何避免为了求中间数而导致的整形溢出，避免这个 bug 的方法我们在介绍归并排序时介绍过。</li></ul> <p>二分查找算法要求数组是顺序数组，但是在我们的生活中，还有这样的场景：我们购买的物品是一件一件买回来的，有时，我们还会丢弃一些物品，那么是不是我们每增加或者丢弃一些物品的时候，都要将他们重新整理一下呢？</p> <p>可以查阅资料，看看如何使用二分查找实现 <code>floor</code> 和 <code>ceiling</code> 操作。</p> <h2 id="_8-2-二分搜索树-binary-search-tree"><a href="#_8-2-二分搜索树-binary-search-tree" class="header-anchor">#</a> 8.2 二分搜索树（Binary Search Tree）</h2> <ul><li>实现查找表，可以通过“普通数组”、“顺序数组”、“二分搜索树”来实现。其中，最有效的方式就是实现二分搜索树。这是因为：</li></ul> <blockquote><p>BST 是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的数据结构。</p></blockquote> <p>BST 的定义如下：</p> <blockquote><p>一棵二叉搜索树（BST）首先是一棵二叉树，其中每个结点都含有一个可以比较的键（对于 Java 语言来说，就是实现了 <code>Comparable</code> 接口的对象）以及相关联的值，且每个结点的键都大于其左子树中的任意结点的键而小于右子树中任意结点的键。</p></blockquote> <p>理解 BST 的定义是理解关于 BST 操作的基础。</p> <ul><li>二分搜索树很适合用于实现“查找表”或者“字典”这种数据结构。</li> <li>二分搜索树不一定是一棵完全二叉树。</li> <li>以左右孩子为根的子树仍为二分搜索树；任一结点的键大于左子树中的<strong>所有</strong>结点的键，小于右子树中的<strong>所有</strong>结点的键；</li> <li>我个人认为：理解二分搜索树的性质，应该通过二分搜索树的定义，以及接下来我们对二分搜索树的一些操作，看看我们对二分搜索树中的数据进行&quot;增删改查&quot;的时候，是如何去维护&quot;二分搜索树&quot;的性质的。</li> <li>我一开始在学习&quot;二分搜索树&quot;的时候，有一些混淆的概念如下：</li></ul> <p>1、&quot;二分搜索树&quot;首先是&quot;二叉树&quot;，有了&quot;搜索&quot;两个字，对结点的键值就有要求了，这个结点的键值要可比较，并且还要按照符合二分搜索树的性质来组织结构，在做 LeetCode 上的问题的时候，一定要看清楚题目中给出的条件包不包含&quot;搜索&quot;两个字；
2、&quot;二分搜索树&quot;和&quot;堆&quot;：&quot;最大堆&quot;只要求父结点不小于子结点就可以了，但是&quot;二分搜索树&quot;就完全不一样了；另外，&quot;堆&quot;可以用数组来表示，因为&quot;堆&quot;是&quot;完全二叉树&quot;，而&quot;二分搜索树&quot;是动态的树形结构，这是由它们的性质决定的，&quot;堆&quot;的操作其实比 BST 少（&quot;堆&quot;有自己适用的场合），BST 能够帮助我们完成很多事情。</p> <p>初始化 BST：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BST</span> <span class="token punctuation">{</span>

    <span class="token comment">// 使用内部类来表示结点</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

        <span class="token comment">// 为了说明算法，我们将 key 设置成易于比较的 int 类型，设计成实现了 Comparable 接口的对象是更标准的做法</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> key<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token comment">// 节根点</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> root<span class="token punctuation">;</span>

    <span class="token comment">// 二分搜索树中的结点个数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token comment">// 默认构造一棵空的二分搜索树</span>
    <span class="token keyword">public</span> <span class="token function">BST</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回二分搜索树的结点个数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回二分搜索树是否为空</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>查阅资料，如何借助二分搜索树实现以下函数：min、max、floor、ceil、rank、select。二分搜索树还可以回答很多数据之间的关系的问题。</p> <h2 id="_8-3-二分搜索树的第-1-个操作-向二分搜索树中插入新的结点"><a href="#_8-3-二分搜索树的第-1-个操作-向二分搜索树中插入新的结点" class="header-anchor">#</a> 8.3 二分搜索树的第 1 个操作：向二分搜索树中插入新的结点</h2> <ul><li>我们利用了二分搜索树的递归的性质来完成 <code>insert</code> 函数的编写。</li> <li>应该特别注意的是：<strong>该递归的方法返回了插入了新的结点的二分搜索树的根</strong>，这一点保证了插入新结点以后，它能够被它的父结点的 <code>left</code> 或 <code>right</code> 指向，这一点要认真体会：</li></ul> <p>1、<code>node.left = insert(node.left, key, value);</code></p> <p>2、<code>node.right = insert(node.right, key, value);</code></p> <p>注意：在递归的实现中，应该把 <code>insert</code> 的结果返回给 <code>node.left</code> 和 <code>node.right</code> ，刚开始接触这个算法的时候，觉得很难理解，写多了就觉得比较自然了。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 向一棵二分搜索树的根结点插入 key 和 value，看看放在左边还是放在右边，然后把插入以后形成的树的根结点返回。</span>
<span class="token comment">// 注意这里的递归调用实现，初学的时候，不是很好理解。可以尝试从最最简单的情况开始分析。</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 key 值存在，直接覆盖就好了，即更新</span>
        node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 递归调用结束以后，要把根结点返回回去</span>
        <span class="token comment">// 因为很可能，node.left 是空，要让新创建的结点接到原来的根，就得执行这步操作</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 递归调用结束以后，要把根结点返回回去</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="_8-4-二分搜索树的第-2-个操作-元素查找和判断是否包含"><a href="#_8-4-二分搜索树的第-2-个操作-元素查找和判断是否包含" class="header-anchor">#</a> 8.4 二分搜索树的第 2 个操作：元素查找和判断是否包含</h2> <ul><li>这一节，我们要实现查找的两个方法：二分查找树的包含 <code>contain</code>（返回 <code>true</code> 或者 <code>false</code>） 和查找 <code>search</code>（返回相应的 <code>vlaue</code> 值），这两个方法同质。还要考虑查找成功和失败这两种情况。</li> <li>1、首先实现 <code>contain</code> 方法。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contain</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">contain</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先处理递归到底的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>2、再实现 <code>search</code> 方法。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在以 node 为根的二分搜索树中查找 key 所对应的 value</span>
<span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先处理递归到底的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_8-5-二分搜索树的第-3-个操作-深度优先遍历"><a href="#_8-5-二分搜索树的第-3-个操作-深度优先遍历" class="header-anchor">#</a> 8.5 二分搜索树的第 3 个操作：深度优先遍历</h2> <ul><li>二分搜索树的遍历，其实就是挨个把二分搜索树中的元素拿出来，只不过二分搜索树不像数组或者链表那样，有明显的“从头到尾”的性质。但其实<strong>走完一个二分搜索树也是有规律可循的</strong>，其中一种方式就是深度优先遍历。</li> <li>深度优先遍历的顺序是下面这张图展示的样子。首先尝试走到最深，再回退，再走到另一个分支的最深。</li></ul> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/二分搜索树的深度优先遍历.jpg" alt="" loading="lazy"></p> <p>那么什么是二分搜索树的前序、中序、后序遍历呢？</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/遍历方式的解释.jpg" alt="" loading="lazy"></p> <ul><li>把握要点：<strong>通过对深度优先遍历</strong>的遍历路径，我么可以看出，深度优先遍历走完一棵二叉树，每个结点会被访问 3 次，分别对应左边、中间和右边，那么在什么位置进行输出，就对应了深度优先遍历的这三种遍历方式：前序遍历，在访问左边位置的时候，进行操作；中序遍历，在访问中间位置的时候，进行操作；后序遍历，在访问右边位置的时候，进行操作；。</li> <li>使用递归的方式实现的代码编写是异常简单的！下面的图表多看几遍就明白了，千万不要忘记了对 node 是否为 null 的判断。下面用递归的方式编写前、中、后序遍历是十分简单的。它们的结构是完全相同的。</li></ul> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/前序中序后序遍历.jpg" alt="" loading="lazy"></p> <ul><li>后序遍历与空间释放</li></ul> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/后序遍历与空间释放.jpg" alt="" loading="lazy"></p> <p>可以看到，红色标注的部分是结构一致的。</p> <ul><li>记忆要点：左右子树都是递归处理，树根是真正要执行的操作。后序遍历的一个重要特点：前序和后序都访问完以后，才做操作。</li> <li>中序遍历的重要结论：中序遍历可以将数据按照从小到大升序排列。</li> <li>后序遍历的重要结论：后续遍历在空间释放的时候可以先释放左右结点，再释放自身。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 二分搜索树的前序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 二分搜索树的中序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 二分搜索树的后序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><ul><li>补充知识：使用非递归的方法完成二分搜索树的三种深度优先遍历。</li></ul> <h2 id="_8-6-二分搜索树的第-4-个操作-广度优先遍历"><a href="#_8-6-二分搜索树的第-4-个操作-广度优先遍历" class="header-anchor">#</a> 8.6 二分搜索树的第 4 个操作：广度优先遍历</h2> <ul><li>重点：广度优先遍历区别于深度优先遍历的方式是<strong>我们首先将每一层的结点优先遍历完毕</strong>。</li> <li>要想完成广度优先遍历，我们要借助队列（先进先出，后进后出）这个数据结构。</li> <li>具体实现方式 ：当队列中的队首出队的时候，要从二叉搜索树中找到它的两个孩子入队（如果有左边孩子的话，左边先入队）。队列出队为空的时候，就将二叉树遍历完成了。</li> <li>我们再归纳一下广度优先遍历的步骤：</li></ul> <ol><li>将根结点入队（入队的时候不做别的操作）；</li> <li>队列非空，所以接下来就要出队，规则是：依次出队，只要出队的元素有孩子，左右孩子依次入队，如果没有孩子不做任何操作。</li></ol> <p>代码实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 二分搜索树的广度优先遍历(层序遍历)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>以下的总结是针对深度优先遍历的 3 种方式和广度优先的 1 种方式，总共 4 种遍历方式而言的：整个遍历的复杂度是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p> <ul><li>不论是深度优先遍历还是广度优先遍历，对于二分搜索树来说，每一个结点只访问了常数次；</li> <li><strong>归并排序和快速排序的本质其实是二叉树的深度优先遍历的过程</strong>；</li> <li>重点把握思想：1、递归调用；2、使用队列实现一个更加复杂的算法的过程（这种按顺序访问的情况，可以使用队列）。</li></ul> <h2 id="_8-7-二分搜索树的结点的删除-这部分有一定难度-不过可以分情况讨论"><a href="#_8-7-二分搜索树的结点的删除-这部分有一定难度-不过可以分情况讨论" class="header-anchor">#</a> 8.7 二分搜索树的结点的删除（这部分有一定难度，不过可以分情况讨论）</h2> <h3 id="_8-7-1-第-1-种情况-讨论删除二分搜索树中的最小结点和最大结点"><a href="#_8-7-1-第-1-种情况-讨论删除二分搜索树中的最小结点和最大结点" class="header-anchor">#</a> 8.7.1 第 1 种情况：讨论删除二分搜索树中的最小结点和最大结点</h3> <ul><li>我们要删除结点，首先要找到这些结点。因此首先要理解下面的这两个基本且简单的性质：</li></ul> <p>最小值结点如何查找：从根结点开始，不停地沿着左边结点的方向找，直到再也没有左结点为止；</p> <p>最大值结点如何查找：从根结点开始，不停地沿着右边结点的方向找，直到再也没有右结点为止。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 查找二分搜索树 key 的最小值</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 查找二分搜索树 key 的最大值</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">maximum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><ul><li>删除最小值结点分两种情况：</li></ul> <ol><li>最小值结点没有右孩子（子树），此时直接删除就好；</li> <li>最小值结点有右孩子（子树），此时让右孩子（子树）代替自己就可以了。</li></ol> <ul><li>同理分析可以得到：删除最大值结点也分两种情况：</li></ul> <ol><li>最大值结点没有左孩子（子树），此时直接删除就好；</li> <li>最大值结点有左孩子（子树），此时让左孩子（子树）代替自己就可以了。</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 从二分搜索树中删除最小 key 所在的结点</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">removeMin</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仔细体会这个过程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 就是删除这个结点</span>
        <span class="token class-name">Node</span> rightNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 因为左边已经是空了，再把右边释放掉</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> rightNode<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 从二分搜索树中删除最大 key 所在的结点</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除了最大元素以后的根结点很有可能不是原来的根结点</span>
        <span class="token comment">// 所以一定要赋值回去</span>
        root <span class="token operator">=</span> <span class="token function">removeMax</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> nodeLeft <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> nodeLeft<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">removeMax</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h3 id="_8-7-2-第-2-种情况-讨论删除只有左孩子-子树-或者只有右孩子-子树-的结点"><a href="#_8-7-2-第-2-种情况-讨论删除只有左孩子-子树-或者只有右孩子-子树-的结点" class="header-anchor">#</a> 8.7.2 第 2 种情况：讨论删除只有左孩子（子树）或者只有右孩子（子树）的结点</h3> <p>处理的方式也很简单，只要让那个非空的左右孩子代替自己就可以了，代码我们合并在下一种情况中展示。</p> <h3 id="_8-7-3-第-3-种情况-删除左右都有孩子-子树-的结点"><a href="#_8-7-3-第-3-种情况-删除左右都有孩子-子树-的结点" class="header-anchor">#</a> 8.7.3 第 3 种情况：删除左右都有孩子（子树）的结点</h3> <ul><li>代替的那个结点是右边子树的最小值（即找到要删除的这个结点的后继结点），或者是左边子树的最大值（或者找到要删除的这个结点的前驱）。</li> <li>重要结论：删除二分搜索树的任意一个结点的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。主要消耗的时间都在找到这个结点，删除这个结点的过程虽然很复杂，但是操作都是指针间的交换，是常数级别的，和整棵树有多少个结点是无关的。所以二分搜索树的删除是非常高效的。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 算法并不难理解，但是在编写的过程中有一些情况需要讨论清楚，并且要注意一写细节，多写几遍就清楚了</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    root <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里要想清楚一个问题，删除以后的二分搜索树的根结点很可能不是原来的根结点</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// key == node.key</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> rightNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> rightNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> leftNode <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> leftNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 当前 node 的后继</span>
        <span class="token class-name">Node</span> successor <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下面删除了一个结点，所以要先加一下</span>
        successor<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        successor<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h2 id="_8-8-二分搜索树的顺序性"><a href="#_8-8-二分搜索树的顺序性" class="header-anchor">#</a> 8.8 二分搜索树的顺序性</h2> <ul><li>之前我们将二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。</li> <li>二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。</li> <li>1、minimum，maximum；</li> <li>2、successor，predecessor（这两个元素在二分搜索树的 key 中必须存在）；</li> <li>3、floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在）；</li> <li>4、rank（58 是排名第几的元素）、select（排名第10的元素是谁，这个问题与 rank 正好相反）。</li></ul> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/rank.jpg" alt="" loading="lazy"></p> <ul><li>之前，我们的二分搜索树并不支持有重复元素的二分搜索树。在有些情况下，我们须要支持重复元素的二分搜索树。</li></ul> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/支持重复元素的二分搜索树.jpg" alt="" loading="lazy"></p> <h2 id="_8-9-二分搜索树的局限性"><a href="#_8-9-二分搜索树的局限性" class="header-anchor">#</a> 8.9 二分搜索树的局限性</h2> <ul><li>二分查找树的性能。二分查找树在一些极端情况下性能并不好。</li> <li>我们首先要认识下面一个事实：同样的数据，可以对应不同的二分搜索树。看下面的例子。</li></ul> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/可以对应不同的二分搜索树.jpg" alt="" loading="lazy"></p> <p>此时二分搜索树可以<strong>退化为链表</strong>。此时时间复杂度变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。我们可以做一个极端测试：如果把 key 排序好以后，依次插入到二分搜索树中，此时二分搜索树的高度就会变得非常高。</p> <ul><li>解决方案：改造二叉树的实现，使得二叉树无法成为链表。使用平衡二叉树。</li> <li>使用红黑树（<strong>红黑树是一种平衡二叉树的实现</strong>，其它平衡二叉树的实现还有 2-3 tree，AVL tree，Splay tree 伸展树，平衡二叉树和堆的结合：Treap）。左右两棵子树的高度差不会超过1。</li> <li>一个很有意思的数据结构：trie（设计巧妙，实现不难）。使用 trie 统计词频。</li></ul> <p>![](https://liweiwei1419.github.io/images/algorithms/bst/前缀树 trie.jpg)</p> <h2 id="_8-10-树形问题和更多树"><a href="#_8-10-树形问题和更多树" class="header-anchor">#</a> 8.10 树形问题和更多树</h2> <ul><li>虽然没有创建树。递归方法天然地具有递归的性质。归并排序法和快速排序法的思想它们像极了对一棵树进行后序遍历和前序遍历。</li> <li><strong>递归的思想</strong>大量应用于搜索问题：一条龙游戏、8 数码、8皇后、数独、搬运工、人工智能：搬运工，<strong>树形搜索</strong>、机器学习。</li> <li>更多的树还有：KD 树，区间树，哈夫曼树。</li> <li>这一节的最后，老师介绍了很多开放的问题，帮助我们培养对算法的兴趣。</li></ul> <h2 id="_8-11-二分搜索树的代码实现"><a href="#_8-11-二分搜索树的代码实现" class="header-anchor">#</a> 8.11 二分搜索树的代码实现</h2> <h3 id="代码实现-java"><a href="#代码实现-java" class="header-anchor">#</a> 代码实现（Java）</h3> <p>https://gist.github.com/liweiwei1419/490d6fa4a92b88b166e5680978858034</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/二分搜索树实现.jpg" alt="" loading="lazy"></p> <ul><li>注意：这里查找 key 的最小值，查找 key 的最大值，删除 key 的最小值，删除 key 的最大值，删除任意结点的操作还比较生疏，希望多加练习（BST6.java、BST7.java）！</li> <li>另外，使用非递归的方式实现递归的效果，用在遍历和查找最小最大、删除最小最大上，也要自己实现一遍。</li></ul> <hr> <p>补充内容：</p> <ul><li>堆是二叉树结构，但不是二分搜索树结构。</li> <li>二分查找的思想在 LeetCode 中有很多应用，希望引起重视。</li> <li>分别使用递归和非递归实现二分查找算法，以及相应的练习。</li> <li>查找相关的问题：min、max、rank、select、floor、ceiling</li> <li>什么是完全二叉树、什么是满二叉树</li> <li>注意为 BST 增加（insert） 结点，使用递归方法将结点挂接到原来的结点上，那么如何写非递归的实现呢？</li> <li>使用 BST 还可以解决一些例如逆序对这类的问题</li> <li>删除二分搜索树的结点（<strong>其实就是分类讨论</strong>），应该要做一下总结，否则每次都忘记</li> <li>BST 更一般地，二叉树的 4 种遍历方式、广度优先遍历，要设置一个队列，深度优先遍历不论是递归还是非递归都和栈有关系</li></ul> <h2 id="bst-的-floor-与-ceiling"><a href="#bst-的-floor-与-ceiling" class="header-anchor">#</a> BST 的 floor 与 ceiling</h2> <ul><li>floor(key) 函数返回比 key 小的数的最大值，如果 BST 中没有比 key 小的数，则返回 null</li> <li>ceiling(key) 函数返回比 key 大的数的最小值，如果 BST 中没有比 key 大的数，则返回 null</li></ul> <h3 id="floor-函数的实现"><a href="#floor-函数的实现" class="header-anchor">#</a> floor 函数的实现</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">floor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Integer</span> tempValue <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tempValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tempValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>说明：</p> <ul><li>如果给定的键 key 小于二分搜索树的根结点的键，那么小于等于 key 的最大键 floor(key) 一定位于根结点的左子树中；</li> <li>如果给定的键 key 大于二分搜索树的根结点的键，分两种情况：</li></ul> <ol><li>当根结点的右子树中存在小于等于 key 的结点的时候，小于等于 key 的最大键才会出现在右子树中；</li> <li>否则根结点就是小于等于 key 的最大键。</li></ol> <p>我们可以举出一个具体的例子来说明：</p> <img src="https://liweiwei1419.github.io/images/algorithms/bst/floor.png"> <p>实现 <code>floor(int key)</code> 函数的关键：</p> <ol><li>利用 BST 的 key 具有顺序性和 BST 的递归性质；</li> <li>写好递归函数，就要处理好递归到底的条件，这里 <code>node == null</code> 和 <code>node.key = key</code> 就是递归终止条件，<strong><code>node == null</code> 直接影响了后续的逻辑</strong>。</li></ol> <h3 id="ceiling-函数的实现"><a href="#ceiling-函数的实现" class="header-anchor">#</a> ceiling 函数的实现</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Integer</span> tempValue <span class="token operator">=</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tempValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tempValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>（本节完）</p> <hr> <p>title: 【算法日积月累】13-二分搜索树
date: 2019-01-14 08:00:00
author: liwei
top: false
mathjax: true
summary: 本文介绍了二分搜索树。
category: 算法与数据结构
tags:</p> <ul><li>binary-search-tree
permalink: algorithms-and-data-structures/binary-search-tree</li></ul> <hr> <h1 id="【算法日积月累】13-二分搜索树"><a href="#【算法日积月累】13-二分搜索树" class="header-anchor">#</a> 【算法日积月累】13-二分搜索树</h1> <h2 id="如何查找"><a href="#如何查找" class="header-anchor">#</a> 如何查找</h2> <p>我们先从二分查找法开始说起，生活中，如果我们摆放物品是按照一定规律的话，那么查找起来就会非常快，如果我们杂乱无章的摆放我们的物品，那么找起来就非常费劲，我们几乎要看看我们所有可能放置物品的地方，这样的操作无异于计算机中的遍历操作，于是乎，如何摆放以使得我们高效地查找，就是一个值得研究的话题。</p> <p>1、二分查找法的时间复杂度是 $O(\log n) $，与“递归”相关的算法（呈现树形结构的算法）一般复杂度都是对数阶的复杂度。</p> <p>2、通过递归来思考一个问题通常更加容易，但递归在性能上会略差（稍差但不意味着我们不会去使用它），因为我们要通过栈来保存层层递归的中间变量。</p> <h1 id="二分搜索树-binary-search-tree"><a href="#二分搜索树-binary-search-tree" class="header-anchor">#</a> 二分搜索树（Binary Search Tree）</h1> <p>二分搜索树（Binary Search Tree），简称为 BST。二分搜索树这个数据结构的提出，是自来于“查找表”和“字典”这种数据结构。</p> <p>在“哈希表”没有出现之前，可以通过“普通数组”、“顺序数组”、“二分搜索树”实现查找表。三者之中，最有效的方式是“二分搜索树”。这是因为，BST 是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的数据结构。下面我们比较一下这三个数据结构。</p> <table><thead><tr><th></th> <th><strong>查找元素</strong></th> <th><strong>插入元素</strong></th> <th><strong>删除元素</strong></th></tr></thead> <tbody><tr><td><strong>普通数组</strong></td> <td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td> <td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td> <td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr> <tr><td><strong>顺序数组</strong></td> <td>$O(\log n) $</td> <td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td> <td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr> <tr><td><strong>二分搜索树</strong></td> <td>$O(\log n) $</td> <td>$O(\log n) $</td> <td>$O(\log n) $</td></tr></tbody></table> <p>对于上表的说明：</p> <p>普通数组的插入操作：要先查找有没有这个元素，然后插入或者覆盖。</p> <p>普通数组的删除操作：要先查找有没有这个元素，然后删除或者什么都不做。</p> <p>顺序数组的查找操作：可以使用二分查找法，二分查找法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p> <p>二分搜索树的定义如下：</p> <blockquote><p>一棵二叉搜索树（BST）首先是一棵二叉树，其中每个结点都含有一个可以比较的键（对于 Java 语言来说，就是实现了 <code>Comparable</code> 接口的对象）以及相关联的值，且每个结点的键都大于其左子树中的任意结点的键而小于右子树中任意结点的键。</p></blockquote> <p>理解 BST 的定义是理解关于 BST 操作的基础。</p> <p>1、二分搜索树很适合用于实现“查找表”或者“字典”这种数据结构；</p> <p>2、二分搜索树不一定是一棵完全二叉树。</p> <p>3、以左右孩子为根的子树仍为二分搜索树；任一结点的键大于左子树中的<strong>所有</strong>结点的键，小于右子树中的<strong>所有</strong>结点的键。</p> <p>理解二分搜索树的性质，应该通过定义，以及二分搜索树的操作，看看我们对二分搜索树中的数据进行“增删改查”的时候，是如何去维护“二分搜索树”的性质。</p> <p>我一开始在学习“二分搜索树”的时候，有一些混淆的概念如下：</p> <p>1、“二分搜索树”首先是“二叉树”，有了“搜索”两个字，对结点的 <code>key</code> 就有要求了，这个结点的键值要可比较，并且还要按照符合二分搜索树的性质来组织结构，在做 LeetCode 上的问题的时候，一定要看清楚题目中给出的条件包不包含“搜索”两个字；
2、“二分搜索树”和“堆”的比较：“最大堆”只要求父结点不小于子结点就可以了，但是“二分搜索树”就完全不一样了；另外，“堆”可以用数组来表示，因为“堆”是“完全二叉树”，而“二分搜索树”是动态的树形结构，这是由它们的性质决定的，“堆”的操作其实比 “二分搜索树” 少（“堆”有自己适用的场合），“二分搜索树” 能够帮助我们完成很多事情。</p> <h2 id="初始化-bst"><a href="#初始化-bst" class="header-anchor">#</a> 初始化 BST</h2> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BST</span> <span class="token punctuation">{</span>

    <span class="token comment">// 使用内部类来表示结点</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

        <span class="token comment">// 为了说明算法，我们将 key 设置成易于比较的 int 类型，设计成实现了 Comparable 接口的对象是更标准的做法</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> key<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token comment">// 根结点</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> root<span class="token punctuation">;</span>

    <span class="token comment">// 二分搜索树中的结点个数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token comment">// 默认构造一棵空的二分搜索树</span>
    <span class="token keyword">public</span> <span class="token function">BST</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回二分搜索树的结点个数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回二分搜索树是否为空</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h2 id="二分搜索树的操作-增"><a href="#二分搜索树的操作-增" class="header-anchor">#</a> 二分搜索树的操作：增</h2> <p>我们利用二分搜索树的递归的性质来完成 <code>insert</code> 函数的编写。</p> <p>应该特别注意的是：<strong>该递归的方法返回了插入了新的结点的二分搜索树的根</strong>，这一点保证了插入新结点以后，它能够被它的父结点的 <code>left</code> 或 <code>right</code> 指向，这一点要认真体会：</p> <p>1、<code>node.left = insert(node.left, key, value);</code></p> <p>2、<code>node.right = insert(node.right, key, value);</code></p> <p>注意：在递归的实现中，应该把 <code>insert</code> 的结果返回给 <code>node.left</code> 和 <code>node.right</code> ，刚开始接触这个算法的时候，觉得很难理解，写多了就觉得比较自然了。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 向一棵二分搜索树的根结点插入 key 和 value，看看放在左边还是放在右边，然后把插入以后形成的树的根结点返回。</span>
<span class="token comment">// 注意这里的递归调用实现，初学的时候，不是很好理解。可以尝试从最最简单的情况开始分析。</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 key 值存在，直接覆盖就好了，即更新</span>
        node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 递归调用结束以后，要把根结点返回回去</span>
        <span class="token comment">// 因为很可能，node.left 是空，要让新创建的结点接到原来的根，就得执行这步操作</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 递归调用结束以后，要把根结点返回回去</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="二分搜索树的操作-查、改"><a href="#二分搜索树的操作-查、改" class="header-anchor">#</a> 二分搜索树的操作：查、改</h2> <p>这一部分，我们要实现查找的两个方法：二分查找树的包含 <code>contain</code>（返回 <code>true</code> 或者 <code>false</code>） 和查找 <code>search</code>（返回相应的 <code>vlaue</code> 值），这两个方法同质。还要考虑查找成功和失败这两种情况。</p> <p>1、首先实现 <code>contain</code> 方法。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contain</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">contain</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先处理递归到底的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>2、再实现 <code>search</code> 方法。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在以 node 为根的二分搜索树中查找 key 所对应的 value</span>
<span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先处理递归到底的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="二分搜索树的操作-删"><a href="#二分搜索树的操作-删" class="header-anchor">#</a> 二分搜索树的操作：删</h2> <p>下面考虑最难的情况：删除左右都有孩子的结点。</p> <p>思路：拿一个已经有的结点代替这个被删除的结点，同时保持二分搜索树的性质不变。</p> <p>1962年，由 Hibbard 提出，即 Hibbard Deletion（Hibbard 删除法），即：代替的那个结点是右边子树的最小值（即找到要删除的这个结点的后继结点），或者是左边子树的最大值（或者找到要删除的这个结点的前驱）。</p> <p>1、删除二分搜索树的任意一个结点的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>；</p> <p>2、主要消耗的时间都在找到这个结点，删除这个结点的过程虽然很复杂，但是操作都是指针间的交换，是常数级别的。</p> <h3 id="第-1-种情况-删除二分搜索树中的最小结点和最大结点"><a href="#第-1-种情况-删除二分搜索树中的最小结点和最大结点" class="header-anchor">#</a> 第 1 种情况：删除二分搜索树中的最小结点和最大结点</h3> <p>我们要删除结点，首先要找到这些结点。因此首先要理解下面的这两个基本且简单的性质：</p> <p>最小值结点如何查找：从根结点开始，不停地沿着左边结点的方向找，直到再也没有左结点为止；</p> <p>最大值结点如何查找：从根结点开始，不停地沿着右边结点的方向找，直到再也没有右结点为止。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 查找二分搜索树 key 的最小值</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 查找二分搜索树 key 的最大值</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">maximum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>删除最小值结点分两种情况：</p> <p>1、最小值结点没有右孩子（子树），此时直接删除就好；</p> <p>2、最小值结点有右孩子（子树），此时让右孩子（子树）代替自己就可以了。</p> <p>同理分析可以得到：删除最大值结点也分两种情况：</p> <p>1、最大值结点没有左孩子（子树），此时直接删除就好；</p> <p>2、最大值结点有左孩子（子树），此时让左孩子（子树）代替自己就可以了。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 从二分搜索树中删除最小 key 所在的结点</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">removeMin</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仔细体会这个过程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 就是删除这个结点</span>
        <span class="token class-name">Node</span> rightNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 因为左边已经是空了，再把右边释放掉</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> rightNode<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 从二分搜索树中删除最大 key 所在的结点</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除了最大元素以后的根结点很有可能不是原来的根结点</span>
        <span class="token comment">// 所以一定要赋值回去</span>
        root <span class="token operator">=</span> <span class="token function">removeMax</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 特别注意：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> nodeLeft <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> nodeLeft<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">removeMax</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h3 id="第-2-种情况-删除只有左孩子-子树-或者只有右孩子-子树-的结点"><a href="#第-2-种情况-删除只有左孩子-子树-或者只有右孩子-子树-的结点" class="header-anchor">#</a> 第 2 种情况：删除只有左孩子（子树）或者只有右孩子（子树）的结点</h3> <p>处理的方式也很简单，只要让那个非空的左右孩子代替自己就可以了，代码我们合并在下一种情况中展示。</p> <p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-1.png" alt="二分搜索树的删除-1" loading="lazy"></p> <p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-2.png" alt="二分搜索树的删除-2" loading="lazy"></p> <h3 id="第-3-种情况-删除左右都有孩子-子树-的结点"><a href="#第-3-种情况-删除左右都有孩子-子树-的结点" class="header-anchor">#</a> 第 3 种情况：删除左右都有孩子（子树）的结点</h3> <p>代替的那个结点是右边子树的最小值（即找到要删除的这个结点的后继结点），或者是左边子树的最大值（或者找到要删除的这个结点的前驱）。</p> <p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-3.png" alt="二分搜索树的删除-3" loading="lazy"></p> <p><img src="https://liweiwei1419.github.io/images/leetcode-solution/450-4.png" alt="二分搜索树的删除-4" loading="lazy"></p> <p>重要结论：删除二分搜索树的任意一个结点的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。主要消耗的时间都在找到这个结点，删除这个结点的过程虽然很复杂，但是操作都是指针间的交换，是常数级别的，和整棵树有多少个结点是无关的。所以二分搜索树的删除是非常高效的。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 算法并不难理解，但是在编写的过程中有一些情况需要讨论清楚，并且要注意一写细节，多写几遍就清楚了</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    root <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里要想清楚一个问题，删除以后的二分搜索树的根结点很可能不是原来的根结点</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// key == node.key</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> rightNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> rightNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> leftNode <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> leftNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 当前 node 的后继</span>
        <span class="token class-name">Node</span> successor <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下面删除了一个结点，所以要先加一下</span>
        successor<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        successor<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h2 id="二分搜索树的-floor-与-ceiling"><a href="#二分搜索树的-floor-与-ceiling" class="header-anchor">#</a> 二分搜索树的 floor 与 ceiling</h2> <p>对于二分查找法来说：<code>floor</code> 地板函数和 <code>ceiling</code>天花板函数是这样定义的：</p> <p>1、在有很多 <code>target</code> 相同元素的数组中，<code>floor</code> 返回第 1 个出现 <code>target</code> 的元素的索引，<code>ceiling</code> 返回最后一个出现这个元素的索引；</p> <p>2、在没有 <code>target</code> 元素的数组中，<code>floor</code> 返回的是最后一个比 <code>target</code> 小的元素的索引，<code>ceil</code> 返回的是第 1 个比 <code>target</code> 大的元素的索引。</p> <p>对于二分搜索树来说：</p> <p><code>floor(key)</code> 函数返回比 <code>key</code> 小的数的最大值，如果 BST 中没有比 <code>key</code> 小的数，则返回 <code>null</code>。</p> <p><code>ceiling(key)</code> 函数返回比 <code>key</code> 大的数的最小值，如果 BST 中没有比 <code>key</code> 大的数，则返回 <code>null</code>。</p> <h3 id="floor-函数的实现-2"><a href="#floor-函数的实现-2" class="header-anchor">#</a> floor 函数的实现</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">floor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Integer</span> tempValue <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tempValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tempValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>说明：如果给定的键 key 小于二分搜索树的根结点的键，那么小于等于 key 的最大键 floor(key) 一定位于根结点的左子树中；</p> <p>如果给定的键 key 大于二分搜索树的根结点的键，分两种情况：</p> <p>1、当根结点的右子树中存在小于等于 key 的结点的时候，小于等于 key 的最大键才会出现在右子树中；</p> <p>2、否则根结点就是小于等于 key 的最大键。</p> <p>我们可以举出一个具体的例子来说明：</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/floor.png" alt="二分搜索树的 floor 操作" loading="lazy"></p> <p>实现 <code>floor(int key)</code> 函数的关键：</p> <p>1、利用 BST 的 key 具有顺序性和 BST 的递归性质；</p> <p>2、写好递归函数，就要处理好递归到底的条件，这里 <code>node == null</code> 和 <code>node.key = key</code> 就是递归终止条件，<strong><code>node == null</code> 直接影响了后续的逻辑</strong>。</p> <h3 id="ceiling-函数的实现-2"><a href="#ceiling-函数的实现-2" class="header-anchor">#</a> ceiling 函数的实现</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 返回以 node 为根的二分搜索树中，小于等于 key 的最大值</span>
<span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Integer</span> tempValue <span class="token operator">=</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tempValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tempValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="二分搜索树的深度优先遍历"><a href="#二分搜索树的深度优先遍历" class="header-anchor">#</a> 二分搜索树的深度优先遍历</h2> <p>首先强调一点：深度优先遍历是一个重要的遍历方法，不是只在二分搜索树中才有。更一般地，我们要掌握二叉树的深度优先遍历和图中的深度优先遍历。</p> <p>二分搜索树的遍历，其实就是挨个把二分搜索树中的元素拿出来，只不过二分搜索树不像数组或者链表那样，有明显的“从头到尾”的性质。但其实<strong>走完一个二分搜索树也是有规律可循的</strong>，其中一种方式就是深度优先遍历。</p> <p>深度优先遍历的顺序是下面这张图展示的样子。首先尝试走到最深，再回退，再走到另一个分支的最深。</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/二分搜索树的深度优先遍历.jpg" alt="二分搜索树的深度优先遍历" loading="lazy"></p> <p>那么什么是二分搜索树的前序、中序、后序遍历呢？</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/遍历方式的解释.jpg" alt="二分搜索树的遍历方式的解释" loading="lazy"></p> <p>把握要点：<strong>通过对深度优先遍历</strong>的遍历路径，我么可以看出，深度优先遍历走完一棵二叉树，每个结点会被访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 次，分别对应左边、中间和右边，那么在什么位置进行输出，就对应了深度优先遍历的这三种遍历方式：前序遍历，在访问左边位置的时候，进行操作；中序遍历，在访问中间位置的时候，进行操作；后序遍历，在访问右边位置的时候，进行操作；。</p> <p>使用递归的方式实现的代码编写是异常简单的！下面的图表多看几遍就明白了，千万不要忘记了对 <code>node</code> 是否为 <code>null</code> 的判断。下面用递归的方式编写前、中、后序遍历是十分简单的。它们的结构是完全相同的。</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/前序中序后序遍历.jpg" alt="二分搜索树的前序、中序、后序遍历" loading="lazy"></p> <p>后序遍历与空间释放</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/后序遍历与空间释放.jpg" alt="二分搜索树的后序遍历与空间释放" loading="lazy"></p> <p>可以看到，红色标注的部分是结构一致的。</p> <p>记忆要点：左右子树都是递归处理，树根是真正要执行的操作。后序遍历的一个重要特点：前序和后序都访问完以后，才做操作。</p> <p>中序遍历的重要结论：中序遍历可以将数据按照从小到大升序排列。</p> <p>后序遍历的重要结论：后续遍历在空间释放的时候可以先释放左右结点，再释放自身。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 二分搜索树的前序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 二分搜索树的中序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 二分搜索树的后序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>补充知识：使用非递归的方法完成二叉树树的三种深度优先遍历。</p> <h2 id="二分搜索树的广度优先遍历"><a href="#二分搜索树的广度优先遍历" class="header-anchor">#</a> 二分搜索树的广度优先遍历</h2> <p>重点：广度优先遍历区别于深度优先遍历的方式是<strong>我们首先将每一层的结点优先遍历完毕</strong>。</p> <p>要想完成广度优先遍历，我们要借助队列（先进先出，后进后出）这个数据结构。</p> <p>具体实现方式 ：当队列中的队首出队的时候，要从二叉搜索树中找到它的两个孩子入队（如果有左边孩子的话，左边先入队）。队列出队为空的时候，就将二叉树遍历完成了。</p> <p>我们再归纳一下广度优先遍历的步骤：</p> <p>1、将根结点入队（入队的时候不做别的操作）；</p> <p>2、队列非空，所以接下来就要出队，规则是：依次出队，只要出队的元素有孩子，左右孩子依次入队，如果没有孩子不做任何操作。</p> <p>Java 代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 二分搜索树的广度优先遍历(层序遍历)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>以下的总结是针对深度优先遍历的 3 种方式和广度优先的 1 种方式，总共 4 种遍历方式而言的：整个遍历的复杂度是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p> <p>不论是深度优先遍历还是广度优先遍历，对于二分搜索树来说，每一个结点只访问了常数次；</p> <blockquote><p><strong>归并排序和快速排序的本质其实是二叉树的深度优先遍历的过程</strong>。</p></blockquote> <p>重点把握思想：1、递归调用；2、使用队列实现一个更加复杂的算法的过程（这种按顺序访问的情况，可以使用队列）。</p> <h2 id="二分搜索树的代码实现"><a href="#二分搜索树的代码实现" class="header-anchor">#</a> 二分搜索树的代码实现</h2> <p>Python 代码：</p> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">BST</span><span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
            self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
            <span class="token comment"># 以该结点为根的子树中的结点总数</span>
            self<span class="token punctuation">.</span>N <span class="token operator">=</span> N
            <span class="token comment"># 指向子树的链接</span>
            self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>
            self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>get_size<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_size</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> node<span class="token punctuation">.</span>N

    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__get_from_node<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__get_from_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>__get_from_node<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>__get_from_node<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val

    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 注意：这里是赋值的关系</span>
        self<span class="token punctuation">.</span>root <span class="token operator">=</span> self<span class="token punctuation">.</span>__put_to_bst<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__put_to_bst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 注意：这里叶子结点要把 1 传进去</span>
            <span class="token keyword">return</span> BST<span class="token punctuation">.</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment"># 此时 node 不为空</span>
        <span class="token keyword">if</span> key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>__put_to_bst<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>__put_to_bst<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 更新</span>
            node<span class="token punctuation">.</span>val <span class="token operator">=</span> val

        <span class="token comment"># 注意这一行代码</span>
        node<span class="token punctuation">.</span>N <span class="token operator">=</span> self<span class="token punctuation">.</span>get_size<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>get_size<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token comment"># 注意：最后都要将 node 返回回去</span>
        <span class="token keyword">return</span> node


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    bst <span class="token operator">=</span> BST<span class="token punctuation">(</span><span class="token punctuation">)</span>
    bst<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
    bst<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
    bst<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>
    bst<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><p>Java 代码：<a href="https://gist.github.com/liweiwei1419/490d6fa4a92b88b166e5680978858034" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <table><thead><tr><th>代码</th> <th>说明</th></tr></thead> <tbody><tr><td>BST1.java</td> <td>二分搜索树树的框架。</td></tr> <tr><td>BST2.java</td> <td>在上一版基础上添加了 insert 操作。</td></tr> <tr><td>BST3.java</td> <td>在上一版基础上添加了 contain 和 search 操作。</td></tr> <tr><td>BST4.java</td> <td>在上一版基础上添加了三种深度优先遍历操作（递归实现）。</td></tr> <tr><td>BST5.java</td> <td>在上一版基础上添加了广度优先遍历（层序遍历）的操作。</td></tr> <tr><td>BST6.java</td> <td>在上一版基础上添加了删除以某个结点为根的二分搜索树的操作（<strong>特别注意的一点是：删除了一个结点以后，根元素很可能会发生变化，因此，算法设计的时候，一定要把根结点返回回去</strong>）。</td></tr> <tr><td>BST7.java</td> <td>在上一版基础上添加了删除一个结点的操作。直接让我们操作可能会有很多种情况以及一些细节没有考虑到。不过好在计算机科学家为我们解决了这个问题。这里用到的是  Hibbard Deletion 删除法。<strong>算法设计思路</strong>如下：（1）如果要删除的结点是最小值、最大值结点，很容易就删除了（即使最小值结点有右孩子，最大值结点有左孩子），此时删除了以后一定记得把新的二分搜索树的根结点返回回去；（2）如果要删除的结点是非叶子结点，我们可以使用这个结点的直接前驱或者直接后继来代替这个结点，这样就完成了结点的删除操作。</td></tr></tbody></table> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>1、堆是二叉树结构，但不是二分搜索树结构；</p> <p>2、查找相关的问题：min、max、rank、select、floor、ceiling；</p> <p>3、什么是完全二叉树、什么是满二叉树；</p> <p>4、注意为 BST 增加（insert） 结点，使用递归方法将结点挂接到原来的结点上，那么如何写非递归的实现呢？</p> <p>5、使用 BST 还可以解决一些例如逆序对这类的问题；</p> <p>6、删除二分搜索树的结点（<strong>其实就是分类讨论</strong>），应该要做一下总结，否则每次都忘记；</p> <p>7、BST 更一般地，二叉树的 4 种遍历方式、广度优先遍历，要设置一个队列，深度优先遍历不论是递归还是非递归都和栈有关系。</p> <p>LeetCode 第 220 题。</p> <h2 id="二分搜索树的顺序性"><a href="#二分搜索树的顺序性" class="header-anchor">#</a> 二分搜索树的顺序性</h2> <p>之前我们将二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。</p> <p>二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。</p> <p>1、minimum，maximum；</p> <p>2、successor，predecessor（这两个元素在二分搜索树的 key 中必须存在）；</p> <p>3、floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在）；</p> <p>4、rank（58 是排名第几的元素）、select（排名第10的元素是谁，这个问题与 rank 正好相反）。</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/rank.jpg" alt="二分搜索树的 rank 操作" loading="lazy"></p> <p>之前，我们的二分搜索树并不支持有重复元素的二分搜索树。在有些情况下，我们须要支持重复元素的二分搜索树。</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/支持重复元素的二分搜索树.jpg" alt="支持重复元素的二分搜索树" loading="lazy"></p> <h2 id="二分搜索树的局限性"><a href="#二分搜索树的局限性" class="header-anchor">#</a> 二分搜索树的局限性</h2> <p>二分查找树的性能。二分查找树在一些极端情况下性能并不好。我们首先要认识下面一个事实：同样的数据，可以对应不同的二分搜索树。看下面的例子。</p> <p><img src="https://liweiwei1419.github.io/images/algorithms/bst/可以对应不同的二分搜索树.jpg" alt="可以对应不同的二分搜索树" loading="lazy"></p> <p>此时二分搜索树可以<strong>退化为链表</strong>。此时时间复杂度变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。我们可以做一个极端测试：如果把 key 排序好以后，依次插入到二分搜索树中，此时二分搜索树的高度就会变得非常高。</p> <p>解决方案：改造二叉树的实现，使得二叉树无法成为链表。1、使用平衡二叉树；2、使用红黑树（<strong>红黑树是一种平衡二叉树的实现</strong>，其它平衡二叉树的实现还有 2-3 tree，AVL tree，Splay tree 伸展树，平衡二叉树和堆的结合：Treap）。左右两棵子树的高度差不会超过1。</p> <p>一个很有意思的数据结构：Trie，其设计巧妙，实现并不难。</p> <p>![前缀树](https://liweiwei1419.github.io/images/algorithms/bst/前缀树 trie.jpg)</p> <h2 id="树形问题和更多树"><a href="#树形问题和更多树" class="header-anchor">#</a> 树形问题和更多树</h2> <p>虽然没有创建树。递归方法天然地具有递归的性质。归并排序法和快速排序法的思想它们像极了对一棵树进行后序遍历和前序遍历。<strong>递归的思想</strong>大量应用于搜索问题：一条龙游戏、8 数码、8皇后、数独、搬运工、人工智能：搬运工，<strong>树形搜索</strong>、机器学习。更多的树还有：KD 树，区间树，哈夫曼树。这一节的最后，老师介绍了很多开放的问题，帮助我们培养对算法的兴趣。</p> <h3 id="本文源代码"><a href="#本文源代码" class="header-anchor">#</a> 本文源代码</h3> <p>Python：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Python/tree/master/bst" target="_blank" rel="noopener noreferrer">代码文件夹<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，Java：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Java/tree/master/08-Binary-Search-Tree/src" target="_blank" rel="noopener noreferrer">代码文件夹<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>（本节完）</p> <h2 id="二分搜索树"><a href="#二分搜索树" class="header-anchor">#</a> 二分搜索树</h2> <hr> <p>title: 「树」专题 6：二分搜索树中的问题
icon: yongyan
category: 二叉树
tags:</p> <ul><li>二叉树</li> <li>递归</li></ul> <hr> <h2 id="「树」专题-6-二分搜索树中的问题"><a href="#「树」专题-6-二分搜索树中的问题" class="header-anchor">#</a> 「树」专题 6：二分搜索树中的问题</h2> <h3 id="回顾二分搜索树的定义"><a href="#回顾二分搜索树的定义" class="header-anchor">#</a> 回顾二分搜索树的定义</h3> <h3 id="二分搜索树的重要性质"><a href="#二分搜索树的重要性质" class="header-anchor">#</a> 二分搜索树的重要性质</h3> <p>二分搜索树的重要性质如下，初学的时候经常会被忽略或者错误地理解：</p> <ul><li>左子树中所有的结点<strong>都小于</strong>当前结点；</li> <li>右子树中所有的结点<strong>都大于</strong>当前结点。</li> <li>以左右孩子为根的子树仍为二分搜索树。</li></ul> <h3 id="回顾二分搜索树中的基本操作"><a href="#回顾二分搜索树中的基本操作" class="header-anchor">#</a> 回顾二分搜索树中的基本操作</h3> <p>既然学习到这个专题，我们就有必要来复习巩固之前在学习《二分搜索树》的时候所进行的一些基本操作，这些操作都是十分重要而且基础的。由于二分搜索树的性质，我们总能以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度来完成上面的操作。</p> <p>1、插入 insert</p> <p>2、查找 find</p> <p>3、删除 delete</p> <p>4、最大值，最小值 minimum, maximum</p> <p>5、前驱，后继 successor, predecessor</p> <p>6、上界，下界 floor, ceil</p> <p>7、某个元素的排名 rank</p> <p>8、寻找第 k大（小）元素 select</p> <p>9、如何将二分搜索树改造成平衡搜索树，平衡搜索树的一个重要应用就是红黑树。</p> <h2 id="例题"><a href="#例题" class="header-anchor">#</a> 例题</h2></div> <!----> <div class="content__content-bottom"></div> <footer class="page-meta"><div class="edit-link"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon edit-icon"><path d="M117.953 696.992 64.306 959.696l265.931-49.336 450.204-452.505-212.284-213.376-450.204 452.513zm496.384-296.326L219.039 797.993l-46.108-46.34L568.233 354.33l46.104 46.335zm345.357-122.99-114.45 115.04-212.288-213.377 114.45-115.035 212.288 213.371zm0 0" fill="currentColor"></path></svg> <a href="https://github.com/liweiwei1419/liweiwei1419.github.io/edit/main/tree/intro.md" target="_blank" rel="noopener noreferrer">Edit this page</a></div> <div class="meta-item update-time"><span class="label">Last update:</span> <span class="info">January 15, 2022 07:10</span></div> <div class="meta-item contributors"><span class="label">Contributors: </span> <span class="info"><span title="email: 45396320+suanfa8@users.noreply.github.com" class="contributor">
          suanfa8
        </span> , <span title="email: 121088825@qq.com" class="contributor">
          liweiwei1419
        </span> <!----></span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/tree/solutions/1080-insufficient-nodes-in-root-to-leaf-paths/" class="prev"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon prev-icon"><path d="M906.783 588.79c-.02 8.499-6.882 15.36-15.38 15.37l-443.7-.01 75.704 191.682c2.52 6.42.482 13.763-5.038 17.91-5.52 4.168-13.138 4.147-18.616-.092L123.228 524.175a15.362 15.362 0 0 1-6-12.165c0-4.782 2.222-9.277 6-12.185L499.753 210.35a15.388 15.388 0 0 1 9.38-3.195c3.236 0 6.502 1.034 9.236 3.103 5.52 4.147 7.578 11.49 5.038 17.91L447.683 419.84l443.72-.01c8.498.01 15.36 6.881 15.36 15.36l.02 153.6z" fill="currentColor"></path></svg>
        1080. 根到叶路径上的不足节点
      </a></span> <span class="next"><a href="/tree/solutions/1008-construct-binary-search-tree-from-preorder-traversal/">
        「力扣」第 1008 题：前序遍历构造二叉搜索树（中等）
        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon next-icon"><path d="M906.772 512c0 4.772-2.211 9.267-5.99 12.175L524.257 813.66a15.37 15.37 0 0 1-18.616.092 15.368 15.368 0 0 1-5.038-17.91l75.714-191.672h-443.73c-8.488 0-15.36-6.881-15.36-15.36v-153.6c0-8.489 6.872-15.36 15.36-15.36h443.73l-75.714-191.682a15.358 15.358 0 0 1 5.048-17.91c5.51-4.158 13.128-4.137 18.606.092l376.525 289.485a15.323 15.323 0 0 1 5.99 12.165z" fill="currentColor"></path></svg></a></span></p></div> <div class="comments-wrapper"><div class="valine-wrapper"><div id="valine"></div></div></div> <!----> <div class="content__page-bottom"></div></main> <footer class="footer-wrapper"><!----> <div class="footer"><a href='https://beian.miit.gov.cn' target='_blank' >闽ICP备2022001209号</a></div> <div class="copyright">Copyright © 2022 liweiwei1419</div></footer></div><div class="global-ui"><!----><div id="pwa-install"><!----> <div id="install-modal-wrapper" style="display:none;"><div class="background"></div> <div class="install-modal"><div class="header"><button aria-label="Close" class="close-button"><svg width="23" height="22" xmlns="http://www.w3.org/2000/svg" class="icon close-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.12.358a1.224 1.224 0 011.729 0l8.92 8.914L20.686.358a1.224 1.224 0 011.73 1.728L13.497 11l8.92 8.913a1.222 1.222 0 11-1.73 1.729l-8.919-8.913-8.92 8.913a1.224 1.224 0 01-1.729-1.729L10.04 11l-8.92-8.914a1.222 1.222 0 010-1.728z" fill="currentColor"></path></svg></button> <div class="logo"><!----> <div class="title"><h1></h1> <p class="desc">This app can be installed on your PC or mobile device.  This will allow this web app to look and behave like any other installed app.  You will find it in your app lists and be able to pin it to your home screen, start menus or task bars.  This installed web app will also be able to safely interact with other apps and your operating system. </p></div></div></div> <div class="content"><div class="highlight"><!----> <!----></div> <div class="description"><h3>Description</h3> <p></p></div></div> <div class="button-wrapper"><button class="install-button">
        Install <span></span></button> <button class="cancel-button">
        Cancel
      </button></div></div></div></div><!----><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button title="Close" aria-label="Close" class="pswp__button pswp__button--close"></button> <button title="Share" aria-label="Share" class="pswp__button pswp__button--share"></button> <button title="Switch to full screen" aria-label="Switch to full screen" class="pswp__button pswp__button--fs"></button> <button title="Zoom in/out" aria-label="Zoom in/out" class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button title="Prev (Arrow Left)" aria-label="Prev (Arrow Left)" class="pswp__button pswp__button--arrow--left"></button> <button title="Next (Arrow Right)" aria-label="Next (Arrow Right)" class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div></div>
    <script src="/assets/js/app.501b6226.js" defer></script><script src="/assets/js/vendors~layout-Layout.b79b4248.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.142c3b04.js" defer></script><script src="/assets/js/page-《算法与数据结构》学习笔记8：二分搜索树.f6ee7432.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout.51e2ddcf.js" defer></script>
  </body>
</html>

---
title: 「力扣」第 124 题：二叉树中的最大路径和（困难）
icon: yongyan
categories: 动态规划
tags:
  - 动态规划
  - 树形 DP
---

+ 题目链接：[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)。

## 题目描述

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)





```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 10^4]`
- `-1000 <= Node.val <= 1000`






本题解介绍了这一类问题需要如何思考。最重要的思想是「**后序遍历**」和动态规划的「**无后效性**」。

如果觉得内容比较多的话，可以先看看题解最后的视频，了解程序是如何通过「后序遍历」，记录了子问题的解，从而得到原问题的解。


---

首先我们需要理解题意。

### 明确什么是「路径」（非常重要）

任意给出一棵二叉树的两个结点，路径指的是：分别从这两个结点向上走，找到 **最近的公共祖先** 结点而形成的路径。**只有这样的定义下，路径才是唯一确定的**。

下图展示的是同一棵树，不同的结点 A 和结点 B 定义的直径（图中绿色标注的部分）。其中左图展示的路径经过了根结点，右图展示的路径不经过根结点。

![image.png](https://pic.leetcode-cn.com/1621619421-SJXSGP-image.png)

下面的树种绿色结点构成的部分不符合题目中路径的定义。

![image.png](https://pic.leetcode-cn.com/1621619636-IBVQPM-image.png)


也就是说：**路径上的每一个结点最多只与 2 条边连接**。

> 友情提示：确定定义非常关键，直接决定了这道问题是否有解。


### 无后效性

根据「直径」的定义，这条路径一定会经过某一个结点。而最长的直径会经过哪一个结点这件事情不确定。

动态规划求解的思路需要考虑所有子问题，也就是 **每一个结点产生的子问题都会考虑到**。因此我们在设计子问题的时候，就要求我们求解的 **子问题** 的直径 **必须经过子问题表述的子树的根结点**。

> 在设计状态的时候，把不确定的事情确定下来，计算得到结果，是「动态规划」的设计思想「无后效性」的应用。我们想一想打家劫舍问题（「力扣」第 198 题）、最长上升子序列问题（「力扣」第 300 题）的状态定义。打家劫舍问题，某一个房间可以偷也可以不偷，我们分别求出，某一个房间被偷的时候的子问题的结果，某一个房间不被偷的时候的子问题的结果，通过比较得出最优值。

另一件事情，**路径可能是「直」的，也可能是「弯」的**。「直」和「弯」的定义如下（虽然左边「直」的看起来也很「弯」，大家看图中红字的定义哦）：

![image.png](https://pic.leetcode-cn.com/1621619774-vsreMV-image.png)

**我们只规定子问题求解得到的路径是「直」的**。为什么这么规定呢？因为 **「直的」情况简单，它可以组成复杂的「弯」的情况**。


## 状态定义

我们规定必须经过子树的根结点，并且最大路径的和表示的路径只来自左子树和右子树 **其中之一** 的 **最大值**。也就是说，这条「路径」其实只走一边。

我们把不确定的、需要分类讨论的事情确定下来，以便求解。


## 为什么是「后序遍历」

深度优先遍历就是从根结点开始在树中转一圈，最后回到根结点。我们采用后序遍历计算结果的方式，表现为：

> 从叶子结点开始，一层一层向上传递信息，最后在根结点汇总结果。

为什么是「后序遍历」呢？

+ 因为二叉树从子结点到父结点只会有一条路径；
+ 而从根结点到子节点至多会有两条路径。

「后序遍历」相当于 **先求得两个子问题的结果，再根据两个子问题的结果得到当前规模更大的子问题的结果**，这是「分而治之」的思想。

## 题目问的结果在求解子问题的过程中得到

我们对状态的定义规定了只来自左右子树的一边，在后序遍历的时候，左右子树的结果都求得的情况下，当前结点就可以把左右两棵子树的求解结果进行综合，就是题目要求的 **经过某个结点** 的最大路径和。

下面给出「参考代码」，我们把需要注意的地方作为注释写在代码中，「树形 DP」与的状态设计与状态转移是隐含在递归方法里的，这一点请大家留意。

大家可以先理解代码，代码之后有一个具体的例子，展示了代码是如何执行，并计算题目要求的结果的。

**参考代码**：

```java
public class Solution {

    private int res;

    public int maxPathSum(TreeNode root) {
        res = Integer.MIN_VALUE;
        dfs(root);
        return res;
    }


    /**
     * 规定 node 必须被选取
     *
     * @param node
     * @return 返回必须经过 node 的直的路径的最大和，这条路径到 node 为止，即：这条路径在左子树和右子树的路径中只能选择一条
     */
    private int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 这里体现了「后序遍历」，先递归求解左、右子树
        // 由于结点的值有可能为负数，因此如果子树得到的路径是负数，可以舍弃，表现为和 0 取最大值
        int leftSubTreeSum = Math.max(0, dfs(node.left));
        int rightSubTreeSum = Math.max(0, dfs(node.right));
        
        // node.val 必须被选择体现在这里
        // 在深度优先遍历的过程中选出最大值
        res = Math.max(res, node.val + leftSubTreeSum + rightSubTreeSum);
        
        // node.val 必须被选择体现在这里
        return node.val + Math.max(leftSubTreeSum, rightSubTreeSum);
    }
}
```


**时间复杂度**：遍历了树一次，因此时间复杂度为 $O(N)$，这里 $N$ 为二叉树的结点总数。


下面的视频可以帮助大家理解程序是如何运行的。

@slidestart [theme]

![0124.001](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd763s0j31hc0u0di1.jpg)

---

![0124.002](https://tva1.sinaimg.cn/large/008i3skNgy1gxixu45eaoj31hc0u0di1.jpg)

---


![0124.003](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd4zhspj31hc0u0mzi.jpg)

---

![0124.004](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd6tdikj31hc0u0di2.jpg)

---

![0124.005](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd898cvj31hc0u0q56.jpg)

---

![0124.006](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd7qqboj31hc0u0acc.jpg)

---

![0124.007](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd5ypbaj31hc0u0whs.jpg)

---

![0124.008](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd25x0qj31hc0u0di3.jpg)

---

![0124.009](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd952vwj31hc0u0q5z.jpg)

---

![0124.010](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd35g55j31hc0u00w0.jpg)

---

![0124.011](https://tva1.sinaimg.cn/large/008i3skNgy1gxixd42ivuj31hc0u0wh9.jpg)


@slideend



## 总结

首先是理解题意，**对「路径」的定义的理解非常关键**，直接决定了递归函数（也就是状态设计）为什么规定了「路径」只能来自其中一个子树。
​
然后是求解这一类问题的思想：
​
+ **后序遍历**：一层一层向上传递；
+ **无后效性**：把不确定的因素固定下来，以便分类讨论。

如果大家做过「力扣」第 53 题：[最大子序和](/problems/maximum-subarray/) 就会发现，当前问题（「力扣」第 124 题） 其实是这道问题的在树上的版本。重点再说一遍：

+ 路径的定义；
+ 后序遍历；
+ 动态规划的无后效性。

## 同类问题

这些问题依然是先理解题目中「直径」「路径」的定义，**有些问题「路径」指的是结点的个数，有些问题「路径」指的是边的条数**。

+ 「力扣」第 124 题：二叉树中的最大路径和（困难，本节讲解问题）；
+ 「力扣」第 337 题：打家劫舍 III（中等）；
+ 「力扣」第 543 题：二叉树的直径（简单）；
+ 「力扣」第 687 题：最长同值路径（中等）；
+ 「力扣」第 968 题：监控二叉树（困难）；
+ 「力扣」第 1372 题：二叉树中的最长交错路径（中等）；






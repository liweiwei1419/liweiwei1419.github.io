---
title: 「力扣」第 509 题：斐波拉契数列
icon: yongyan
categories: 动态规划
tags:
  - 动态规划
---

 提示：「斐波拉契数列」是入门「动态规划」的典型的问题。

## 题目描述

**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给你 `n` ，请计算 `F(n)` 。

**示例 1：**

```
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

**提示：**

- `0 <= n <= 30`

## 思路分析

斐波那契数列是通过「递归」定义的，通过这个递归关系式，我们可以知道斐波那契数列中任意一个位置的数值。

$$
\begin{equation}\begin{split} 
F(0) & = 0,\\
F(1) & = 1,\\
F(n) & = F(n-1) + F(n-2),\\
\end{split}\end{equation}
$$

很容易地，我们能写出下面的代码：

```java
public class Solution {

    public int fib(int n) {
        if (n < 2) {
            return n;
        }
        return fib(n - 1) + fib(n - 2);
    }
}
```

说明：代码用于计算是没有问题的，但是仔细研究，我们就会发现，我们虽然使用递归实现了斐波那契数列在任意位置的值的计算，但是，如果要我们自己计算的话，肯定不会这样计算，因为太耗时了。

耗时的原因在于，在上述的递归实现中，存在大量的重复计算，例如：
要计算 `fib(4)`，就得计算 `fib(3)` 和 `fib(2)`，要计算 `fib(3)`，就得计算 `fib(2)` 和 `fib(1)`，此时 `fib(2)` 就被重复计算了，下面是一张图，展示了部分重复计算的过程。

![image-20211218170017276](https://tva1.sinaimg.cn/large/008i3skNgy1gxi3d9bbtrj319w0sawgy.jpg)

要解决上一步的问题，就要避免重复计算，我们可以引入一个 `memo` 数组，用于存入已经计算过一次的 fib 的值，下一次需要这个值的时候，再从中取，下面是代码实现。

## 什么是「记忆化搜索」

针对一个递归问题，如果它呈树形结构，并且出现了很多「重叠子问题」，会导致计算效率低下，「记忆化搜索」就是针对「重叠子问题」的一个解决方案，实际上就是「加缓存避免重复计算」。

加入了记忆化搜索，即：使用了缓存数组，以避免重复计算。

```java
import java.util.Arrays;

public class Solution3 {

    public int fib(int N) {
        if (N < 2) {
            return N;
        }

        // 0 要占一个位置，所以设置 N + 1 个位置
        int[] memo = new int[N + 1];
        // 还未计算过的值用 -1 表示
        Arrays.fill(memo, -1);
        return fib(N, memo);
    }

    public int fib(int n, int[] memo) {
        if (n == 0) {
            return 0;
        }

        if (n == 1) {
            return 1;
        }

        if (memo[n] == -1) {
            memo[n] = fib(n - 1) + fib(n - 2);
        }
        return memo[n];
    }
}
```

这个版本是最接近我们自己去计算斐波那契数列的第 $n$ 项。想一想的确是这样，聪明的你一定不会递归去计算波那契数列的，因为我们的脑容量是有限，不太适合做太深的递归思考，虽然计算机在行递归，但是我们也没有必要让计算机做重复的递归工作。

```java
public class Solution {

    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        int[] dp = new int[N + 1];

        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < N + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$
+ 空间复杂度：$O(N)$

## 「自顶向下」与「自底向上」

+ 「记忆化搜索」或者我们称「重叠子问题」的加缓存优化的实现，我们的思考路径是「自顶向下」。即为了解决数据规模大的问题，我们假设已经解决了数据规模较小的子问题；
+ 「动态规划」就是上述「循环版本」的实现，我们思考问题路径是「自下而上」。实际上，我们是先真正地解决了数据规模较小的问题，然后一步一步地解决了数据规模较大的问题。

## 「动态规划」的官方定义

> Dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions – ideally, using a memory-based data structure.

翻译：将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。

### 「动态规划』问题的一般思考路径

我们通常的做法是：使用记忆化搜索的思路思考原问题，但是使用动态规划的方法来实现。即“从上到下”思考，但是“从下到上”实现。

## 总结

对于一个递归结构的问题，如果我们在分析它的过程中，发现了它有很多“重叠子问题”，虽然并不影响结果的正确性，但是我们认为大量的重复计算是不环保，不简洁，不优雅，不高效的，因此，我们必须将“重叠子问题”进行优化，优化的方法就是“加入缓存”，“加入缓存”的一个学术上的叫法就是“记忆化搜索”。

另外，我们还发现，直接分析递归结构，是假设更小的子问题已经解决给出的实现，思考的路径是“自顶向下”。但有的时候，“自底向上”的思考路径往往更直接，这就是“动态规划”，我们是真正地解决了更小规模的问题，在处理更大规模的问题的时候，直接使用了更小规模问题的结果。
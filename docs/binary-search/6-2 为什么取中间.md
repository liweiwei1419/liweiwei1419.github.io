## 为什么取中间

大家好  这里是算法不好玩

上一节的最后我们给大家留了一个问题

为什么二分查找每一次要看中间位置的元素的值

其实只要这个位置是在搜索区间的范围里都是可以的

看到值以后无非就是找到了

或者继续向左边找

或者继续向右边找

取中间位置的原因是

在平均情况下结果最好

这是因为在我们对输入数据一无所知的情况下

我们不应该对数据大小的猜测有偏向

## 整数除法默认下取整

这里有一个细节需要大家注意

在区间里只有偶数个元素的时候

实际上有两个位于中间位置的元素

这一行代码只能取中间位置靠左的那个元素的下标

要想取到中间位置靠右的元素的下标

我们需要在括号里加 1


我们把「力扣」第 704 题 mid 的取值改成上取整

也可以得到通过

```java
public class Solution {

    public int search(int[] nums, int target) {
        int len = nums.length;

        int left = 0;
        int right = len - 1;
        // 在 nums[left..right] 左闭右闭区间里查找目标元素
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target){
                return mid;
            } else if (nums[mid] < target){
                left = mid + 1;
            } else {
                // nums[mid] > target
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

还有一个细节我们以前和大家提到过

在 left 和 right 很大的时候

left + right 在 int 这个范围里

有可能会出现整型溢出得到负数

```java
public static void main(String[] args) {
    int left = Integer.MAX_VALUE - 8;
    int right = Integer.MAX_VALUE - 2;
    // 输出 -6
    System.out.println((left + right) / 2);
    // 输出 2147483642
    System.out.println(left + (right - left) / 2);
    // 输出 2147483642
    System.out.println((left + right) >>> 1);
}
```

我们可以把取中间数写成这个样子

但其实很多时候是没有必要的

以后和大家介绍的问题

如果题目当中给出的数据的范围没有溢出的可能

我们还是保持最原始的相加以后除以 2 的写法

# 把区间分成三个部分

我们上一节介绍的二分查找算法

把区间分成了三个部分

第一个部分是我们当前看到的那个元素

第二个部分是当前看到的元素的左边的所有元素

第三个部分是当前看到的元素的右边的所有元素

我们根据当前看到的元素的数值推断目标元素

在中间位置的左边

还是在中间位置的右边

这样的解法在最后一轮循环的时候

或者 left 右移一位来到 right 的右边

或者 right 左移一位来到 left 的左边

退出循环以后到底返回 left 还是 right

有些时候没有那么容易看出来

事实上我经常用的是另外一种二分查找的写法

这种写法在形式上把 while 循环可以继续的条件

改成了 left 严格小于 right

在循环体内只写两个分支

在退出循环以后 left 与 right 重合

这种把区间分成两个部分的方式

只要大家熟练以后

可以简化思考问题的难度

减少很多边界条件的讨论

我们在下一节和大家详细介绍这种二分查找的写法

这就是这一节的内容

感谢大家的收看


```java
public class Solution {

    public int search(int[] nums, int target) {
        int len = nums.length;

        int left = 0;
        int right = len - 1;
        // 在 nums[left..right] 左闭右闭区间里查找目标元素
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target){
                left = mid + 1;
            } else {
                // nums[mid] >= target
                right = mid;
            }
        }

        if (nums[left] == target) {
            return left;
        }
        return -1;
    }
}
```
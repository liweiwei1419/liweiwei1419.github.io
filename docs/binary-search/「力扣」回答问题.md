---
title: 「力扣」问题回答
icon: yongyan
category: 二分查找
tags:
  - 二分查找
---


本文是在这篇 [帖子](https://leetcode-cn.com/circle/discuss/rFK9HC/view/tDWDHh/) 下我的回答。

# 回答 1：取 mid 为什么要加 1

`int mid = left + (right - left) / 2 + 1;` （+1 也可以写在括号里面，目的是为了改变整数除法默认下取整的行为）只出现在 `while (left < right)` 这种写法里，因为这种写法要求我们一定要弄清楚 `mid` 位置的值是保留还是剔除：

+ 如果保留，就不加 1 或者减 1；
+ 如果剔除，就要加 1 或者减 1。

需要重点理解： `if` 和 `else` 里面出现了 `left = mid` ，**加 `1` 是避免出现死循环**。你可以试试看取 `mid` 的时候不加 1 ，一定会有某一些测试用例 **超时**。

**原因**：整数除法是下取整。取 `mid` 的时候 **不能做到真正取到中间位置**，例如 `left = 3, right = 4`， `mid = (left + right) / 2 = 3`；

你给的「第一种」代码里 `if` 和 `else` 里面的代码表示：根据 `mid` 位置的值把区间 `[left..right]` 分成两个部分：`[left..mid - 1]` 与 `[mid..right]`。`left = mid` 一定需要与 `right = mid - 1` 配对使用。因为：

+ `left = mid` 表示下一轮搜索区间是 `[mid..right]` ，所以设置 `left = mid`；
+ `right = mid - 1` 表示下一轮搜索区间是区间 `[left..mid - 1]`，所以设置 `right = mid - 1`。

当区间里只剩下两个元素的时候 `left` 的值等于 `mid` 的值，还看上面的例子 `left = 3, right = 4`， `mid = (left + right) / 2 = 3 = mid`，此时一旦进入这个区间 `[mid..right]` ，代码执行 `left = mid` ，搜索区间不能缩小，所以进入死循环。

如果实在对着屏幕很难理解为什么会出现死循环，**在循环体里把 `left` 和 `right` 的值打印出来看一下就清楚了**。「力扣」第 69 题是这种情况下最容易看到死循环的问题，我写过题解展示过这种死循环，可以看 [这里](https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/)，可以直接翻到最后「问答」那里，看第 3 点。


---


# 回答 2：你给出的 「第二种」 代码为什么也能通过

你给出的 「第二种」 代码：`while (left <= right)` 这种写法，这种写法要求：**`if` 和 `else` 里面的 `right` 和 `left` 都要 `-1` 或者 `+ 1`，它没有死循环的问题**，但是有一点要注意的是：**一定要判断 `mid` 位置的值可能是解的时候，把结果先保存下来**。

本题 `ans[i] = items[mid][1];` 就设置在 `else` 里，表示当 `items[mid][0] <= queries[i]` 的时候，`mid` 位置的值有可能是我们要找的（至于为什么是这样，看题目）。当 `left == right` 的时候，循环体还会继续执行，由于 `left` 和 `right` 一定会 +1 或者 -1，还会继续查找，所以没有死循环的问题，由于之前保留过 `ans` 的值，所以不会丢失解。

我帮你简单总结一下网络上常见的三种模板的区别：

---

# 总结：三种模板写法比较

+ 模板一：`while (left <= right)` ，这种写法里面的 `left` 和 `right` 都要加 1 或者减 1，还要判断 mid 位置的值有可能是解的时候，把 `mid` 的值保存下来，所以这种写法别人也叫带 `ans` 的写法，我以前看到力扣的大佬零神就比较喜欢这样写；
+ 模板二：`while (left < right)` 这种写法需要清楚 `mid` 位置的值是否保留，所以一定是 `left = mid` 与 `right = mid - 1` 配对，`left = mid + 1` 与 `right = mid` 配对。这种模板最难理解的地方就是出现 `left = mid` 的时候，一定要把取 `mid` 的表达式 +1。好处是退出循环以后，很多时候 `left` 与 `right` 就是要找的解，而且这种写法也要求我们必须弄清楚 `mid` 到底有没有可能是解；

> 这里有个小技巧，一般我会在注释里写上「下一轮搜索区间是什么」。如果下一轮搜索区间是 `[mid..right]` ，这个时候就设置 `left = mid`，这种情况的反面区间就是 `[left..mid - 1]` ，那么 `else` 就设置 `right = mid - 1`，所以就不用记忆配对关系了。


+ 模板三：`while (left + 1 < right)` 这种写法里面的 `left` 和 `right` 都不加 1 或者减 1，意思就是都认为 `mid` 可能是要找的值，所以退出循环以后一定要再判断一下 `left` 和 `right` 哪个有可能是解。退出 `while (left + 1 < right)` 循环以后，区间里剩下两个元素，所以还要单独判断一下这两个位置哪个是要找的元素的值，很多时候会增加不必要的判断逻辑。


**三种模板实际上都是一个意思**：

+ 模板二说一定要搞清楚 `mid` 位置是不是要保留，退出循环以后 `left` 与 `right` 重合，区间 `[left..right]` 只有 1 个元素；
+ 模板三说 `mid` 全部保留，退出循环以后 `left` 在左，`right` 在右，区间 `[left..right]` 有 2 个元素；
+ 模板一说 `mid` 全部不保留，退出循环以后 `left` 在右，`right` 在左，区间 `[left..right]` 为空区间。

模板一和模板三屏蔽了 + 1 还是 -1 的细节，但是都有相应的「补救措施」。

不管哪种模板一定要判断的是 **下一轮「向左找」还是「向右找」**，这一点应该从题目中分析得到，所以一定要认真审题哦。

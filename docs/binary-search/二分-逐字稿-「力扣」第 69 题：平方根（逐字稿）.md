大家好
今天要和大家分享的是 leetcode 第 69 题 平方根
这道题要求我们实现平方根函数
输入是一个非负整数
输出也是一个整数

但是题目当中说了结果只保留整数的部分
小数部分将被舍去

这是什么意思呢
我们来看一下示例 1

输入是 4
输出是 2

这是显然的 
4 就是一个完全平方数
2 乘以 2 等于 4
我们看到 虽然在数学上一个数的平方根有正有负
但是这个题目只要求我们返回算术平方根

（停顿）再来看一下示例 2 
输入是 8 
输出也是 2
这是为什么呢
因为 8 的平方根是 2.82842 这是在浮点数的情况下
又因为题目当中要求我们将小数部分舍去
因此输出的是 2

从这个例子，我们看出由于输出是将小数部分舍去
因此作为输出的平方根的这个整数
它平方以后一定不会严格大于作为输入的这个数
我们看在这里返回 3 就不对了
这是因为 3 * 3 等于 9 大于 8

从题目的要求和示例我们可以看出
这其实是一个查找整数的问题
并且这个整数是有范围的
如果这个整数的平方恰恰好等于输入整数
那么我们就找到了这个整数

如果这个整数的平方大于输入整数
那么这个整数肯定不是我们要找的那个数
对吗
刚刚示例 2 我们就向大家解释过了
这是由于题目要求我们将 输出 舍去小数的部分


如果这个整数的平方小于输入整数
那么这个整数可能是我们要找的那个数

依然看示例 2 
2 的平方是 4
4 小于 8
但是我们不能返回 3


相信说到这里
聪明的你也一定明白了
我们可以使用二分查找法来查找这个整数

如果是让人（ren）来做
其实也是这样 
不断地 缩小范围 地去猜

猜的数平方以后大了就往小了猜
猜的数平方以后恰恰好等于输入的数就找到了
猜的数平方以后小了 可能猜的数就是 也可能不是


事实上 这个数其实是有范围的

直觉上一个整数的平方根肯定不会超过它自己的一半
但是 0 和 1 除外
因此我们可以在 1 到 输入整数除以 2 这个范围里查找我们要找的平方根整数
0 呢就单独判断一下就好了

![image-20210316235242377](https://tva1.sinaimg.cn/large/e6c9d24egy1gom6n02vxmj21ea0omdit.jpg)



下面我们来看一下代码

```java
public class Solution {
    public int mySqrt(int x) {
        // 首先先做一个特殊的判断
        if (x == 0) {
            return 0;
        }

        if (x == 1) {
            return 1;
        }

        // 接着我们就是要在 1 到 x / 2 这个范围里查找这个整数
        // 因此，我们设置左边界为 1 右边界为 x / 2
        int left = 1;
        int right = x / 2;

        // 接下来我们在一个循环体里查找目标整数
        // 我们写成 while left 严格小于 right 的样子
        // 这是因为在退出循环的时候一定有 left == right
        // 这个时候 left 或者 right 就是我们要找的整数
        while (left < right) {
            // 在循环体里我们先随意才一个整数
            // 猜中间数是平均期望最高的
            // 我们这个样子来写是为了防止整数溢出
            // int mid = left + (right - left) / 2;

            // 这是因为右移等价于除以 2，并且它是无符号右移，右移以后高位一律补 0
            // 也就是在 left + right 发生整型溢出的时候
            // 这个表达式的结果肯定正确，它不会变成负数
            // 这一点我是从 Java 的 JDK 当中学来的
            int mid = (left + right + 1) >>> 1;

            // 接下来我们就要考虑我们猜的数对不对了
            // 根据我们刚才的分析，这个数的平方如果严格大于输入整数，那么它肯定不是我们要找的平方根
            if (mid * mid > x) {
                // 下一轮搜索的区间就是 [left, mid - 1]
                // 这个时候我们设置右边界为 mid - 1
                right = mid - 1;
            } else {
                // 否则就是 mid * mid <= x
                // 这个时候我们当然可以分开讨论，当 mid * mid == x 的时候和当  mid * mid < x
                // 但是我们觉得没有必要了
                // 因为在上一个分支正确的情况下，这个分支要搜索的区间一定是上一个区间的反面
                // 因此在这个分支里下一轮搜索的区间就是 [mid, right]
                // 这个时候我们设置左边界为 mid
                left = mid;
                // 写完了这个分支的情况我们要特别注意一点
                // 那就是一看到 left = mid 这种设置边界的情况
                // 我们在取中间数的时候就要把它改成上取整
                // 这是为什么呢，因为 left + right / 2 这个数由于 / 2 整数除法是下取整
                // 当搜索区间只有 2 个数的时候 left + right / 2 只能取到 left 永远取不到 right
                // 而一旦进入这个分支 left = mid 整个区间就分不开了
                // 进而陷入死循环，这一点需要特别注意，要想避免这个问题我们全程让取中间数的时候上取整就可以
            }
        }
        // 最后在退出循环的时候，区间里只有一个数 left 我们没有看到，但是它肯定是我们要找的那个数
        // 不用再做一次特殊的判断，我们直接将他返回
        return left;
    }
}
```


但是如果我们把这一版代码提交上去以后
你会看到出错了
这个时候别慌
我们看一下出错的这个用例 2147395599 
这么大的一个数
我们就知道了
其实我们的算法是正确的
但是肯定在哪个地方整形溢出了

我们仔细找一下就不难看出 问题出现在 mid * mid 这里
前面加法都可能溢出 
乘法就当然会溢出啦
这个时候补救的办法就是 换成除法 if (mid > x / mid) {

这个时候代码就得到了一个通过。

我们看到二分查找法不仅可以应用于在有序数组里查找一个数
也可以应用在查找一个有范围的整数
当然在有范围的区间里查找一个数也相当于在一个升序的数组里查找一个数了
在做有范围的整数的二分查找的时候
如果我们能够尽量地缩小要查找的数的范围
那是最好的
这样可以缩小循环体执行的次数

剩下的就是我们要注意一些细节
看到 left = mid 的时候取中间数要上取整
要采用相应的措施去规避整形溢出的风险

二分查找算法的时间复杂度是对数级别的，
由于我们只使用了常数个临时变量
因此空间复杂度是 O(1)

这道题还有一个经典的做法就是使用牛顿法
牛顿法的基本思想其实不难，就是我们熟知的以直线代替曲线的近似的思想
感兴趣的朋友不妨在互联网上搜索一下
相信会是一个很有意思的问题

这就是我们对求解平方根问题的讲解
感谢大家的收看












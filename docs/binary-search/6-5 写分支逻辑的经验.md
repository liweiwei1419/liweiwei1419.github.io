大家好 这里是算法不好玩

这一节我们介绍的是经验层面的东西

这一节最重要的一句话是

把搜索区间划分成两个部分

需要从目标元素的性质的反面去思考

所以解决二分查找问题的重点

在于分析清楚目标元素的性质

要分析清楚目标元素的性质

就需要认真审题

仔细分析题目给出的示例


例如「力扣」第 35 题

我们分析清楚

题目要找的元素的性质是

第一个大于等于 target 的元素的下标

要找的是大于等于

if 语句就可以写严格小于 target 的时候

nums[mid] 严格小于 target 

mid 这个位置肯定不等于 target

mid 之前的值更小

所以 mid 以及 mid 的左边一定不存在目标元素

下一轮搜索区间是 mid + 1 到 right 左闭右闭区间

这个时候我们设置 left = mid + 1

if 的反面就是我们要找的元素

这个时候我们不用再思考

因为 if 这个条件我们找到的是 

mid + 1 到 right 左闭右闭区间

else 的区间一定是 left 到 mid 左闭右闭区间

这个时候我们设置 right = mid

具体的细节我们可以不用再分析

因为 if 和 else 这两种情况所在的区间

组合起来一定得是原来的整个区间

不能漏掉一个元素

其实我们仔细分析一下

结论肯定是对的

else 这种情况是

当 nums[mid] 大于等于 target 的时候

mid 这个位置有可能就是第一个大于等于 target 的元素

我们不能够把 mid 丢弃掉

但是 mid 的左边也有可能是第一个大于等于 target 的元素


mid 的右边一定不会是第一个大于等于 target 的元素

所以下一轮搜索区间是 [left..mid] 左闭右闭区间

把区间分成两个部分的好处就体现在这里了

只要其中一种情况分析清楚

另外一种情况可以不用分析

取第一种情况的反面区间就可以了


---

我们以要找的元素需要同时满足两个条件为例

为了缩小搜索区间

同时满足两个条件的反面

只需要否定其中一个条件就可以了

例如我们要找的元素是在 3 到 8 之间的整数

也就是大于等于 3 并且小于等于 8

对其中的一个条件取反就可以达到缩小搜索区间的目的

对 x 大于等于 3 取反

就是如果 x < 3 我们就知道了

大于等于 3 并且小于等于 8 的元素一定在 x 的右边

对 x 小于等于 8 取反

就是如果 x > 8 我们就知道了

大于等于 3 并且小于等于 8 的元素一定在 x 的左边

使用这样的方式解决的问题是「力扣」第 4 题

我们会在下一专题「二分查找」的习题集里

和大家详细介绍「力扣」第 4 题的解法

这就是这一节的内容

下一节我们和大家介绍

二分查找的应用

感谢大家的收看



---


> 是我做了很多很多的练习总结出来的，可能我的描述会让大家感觉云里雾里的。大家可以尝试做一些二分查找的问题，再回过头看我这里的描述，或许就明白我在说的是什么。

# 如果要找的元素性质很简单

看到了目标值就可以结束

我们就写成 while left 小于等于 right 这种形式

把区间分成三个部分

最典型的例子还是「力扣」第 704 题

写 while left 小于等于 right 

表示当 left 与 right 重合的时候还要继续查找

第一个分支是要查找的目标元素性质

在这个分支里直接返回

第二分支和第三个分支都很好判断是向左边走还是向右边走

并且这两个分支一般来说都排除 mid 这个位置的值 

所以一个加 1 一个减 1

# 如果要找的元素性质相对复杂

我们在循环体内就需要不断地排除一定不存在目标区间的元素

代码上写成 while left 严格小于 right

并且只写 if 和 else 两个分支

表示在退出循环以后区间里只剩下一个数

这种写法把要找的元素留到退出循环以后返回

会给解决问题带来很多方便 

第 1 left 与 right 重合避免了讨论返回 left 还是 right

第 2 写成两个分支 其实只用考虑一种情况下边界的设置

if 和 else 得到的下一轮搜索的区间

合起来一定得是原来的整个搜索区间 





**说明**：这篇题解专治二分疑难杂症。

先说重点：

1. 二分查找的思想就一个：**逐渐缩小搜索区间**。虽然我们看到的写法有很多，但思想就这一个；
2. 为什么总是有朋友觉得二分难？因为有很多二分的写法，虽然都对，但是对于新手朋友们来说有一定干扰，因为 **不同的写法其实对应着不同的前提和应用场景**，**比起套用模板，审题、练习和思考更重要**。「二分查找」就几行代码，完全不需要记忆，也不应该用记忆的方式解题；
3. 本篇题解只介绍一种我经常使用的二分查找的思考方式，用它能够解决「力扣」上所有的二分查找问题。理解这种二分查找的逻辑，再理解其它写法就相对容易了；
4. **重点 1**：本题解要介绍的「二分查找」的思想其实不是什么新鲜事儿。如下图所示，它像极了「双指针」算法，`left` 和 `right` 向中间走，直到它们重合在一起。

![image.png](https://pic.leetcode-cn.com/1617955110-eWCqKj-image.png)

我认为这种写法最大的好处是：退出循环以后 `left` 与 `right` 重合在一起，不用考虑返回 `left` 还是 `right`。说白了，就是一直在做排除，**把不是目标元素的区间都排除了，最后剩下的那个就是我们要找的**。

5. **重点 2**：只把待搜索区间分成两个部分

根据看到的中间位置的元素的值 `nums[mid]` 可以把待搜索区间分为两个部分：

+ **一定不存在** 目标元素的区间：下一轮搜索的时候，不用考虑它；
+ **可能存在** 目标元素的区间：下一轮搜索的时候，需要考虑它。

由于 `mid` 只可能被分到这两个区间的其中一个，即：`while` 里面的 `if` 和 `else` 就两种写法：

+ 情况 1：如果 `mid` 分到左边区间，即区间分成 `[left..mid]` 与 `[mid + 1..right]`，此时分别设置 `right = mid` 与 `left = mid + 1`；
+ 情况 2：如果 `mid` 分到右边区间，即区间分成 `[left..mid - 1]` 与 `[mid..right]`，此时分别设置 `right = mid - 1` 与 `left = mid`。

这种思路可以很形象地理解为「两边夹」，在解决复杂问题的时候，会使得思考的过程变得简单。

程序开始的时候，我们对输入数组一无所知。

![image.png](https://pic.leetcode-cn.com/1617784079-KQhLcv-image.png){:style="width: 400px"}

我们选择 `nums[mid]` 的值看一下。

![image.png](https://pic.leetcode-cn.com/1617784103-DNDPJy-image.png){:style="width: 400px"}

然后我们只分析：**在什么情况下，目标元素位于哪个区间里**，把区间分成「一定不存在目标元素的区间」和「可能存在目标元素的区间」。而 `mid` 只可能位于这两个区间的其中一个，可以分为下面 4 种情况。

![image.png](https://pic.leetcode-cn.com/1617786936-PtTKbf-image.png){:style="width: 400px"}

虽然看起来比较多，但是归结起来就 2 种情况：`mid` 在左边区间和 `mid` 在右边区间。即：根据 `mid` 的值，可以判断 `nums[mid]` 是「一定不是目标元素」还是「有可能是目标元素」，进而判断 `mid` 的左右两边的区间的性质。


6. 一个 **重要经验**：

如果我们要找的元素的性质比较复杂：例如需要满足「条件 1」并且「条件 2」。我们在编写 `if` 语句的时候，就可以把其中一个条件取反，就可以达到缩减搜索区间的目的。

这一点也不难想明白，「条件 1」并且「条件 2」的反面就是「取反条件 1」**或者**「取反条件 2」。再举一个具体的例子：例如我们要找一个数 $x$，需要满足 $4 \le x \le 9$，即 $x \ge 4$ 并且 $x \le 9$。如果我们看到一个数小于 $4$，我们就知道此时需要在当前位置的右边继续查找，可以得到缩减问题区间的目的。

「力扣」第 4 题（[寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)）的 [视频题解](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)，我们详细介绍了用这种思路分析问题的方法，并给出了 2 版等价的代码。


其它细节放在后面说。

---

**本题题解**：




---


下面解释一些细节：

**问题一**：为什么有些时候取 `mid` 的时候需要上取整？

回答：是否需要上取整，只和区间划分的逻辑有关。如果不调整，会出现死循环。

![image.png](https://pic.leetcode-cn.com/1617778514-OzKyCg-image.png)

初次接触的时候，很多朋友觉得这件事情非常难以理解，我们的建议是：**一旦遇到死循环，可以在程序中输出 `left`、`right` 和 `mid` 的值看一下就很清楚了**。「力扣」第 69 题：[x 的平方根](https://leetcode-cn.com/problems/sqrtx/) 的 [题解](https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/) ，我们演示了如何打印变量、观察到死循环。

结论：当区间只剩下两个元素的时候，`left = mid` 和 `right = mid - 1` 这种划分方式，如果 `mid` 使用默认下取整的方式，在数值上 `left = mid`，而它对应的其中一个区间是 `[mid..right]`，在这种情况下，下一轮搜索区间还是 `[left..right]`，搜索区间没有减少，会进入死循环。

提示：「看到边界设置的代码是 `left = mid` 时，需要把 `mid` 的取法调整为上取整，以避免死循环」，这件事情也完全不用记忆，题目做得多了，自然而然就记住了。还是我们在题解中和大家多次强调的一件事情：**遇到代码出错的时候，一定要耐心调试，把变量打印出来看一下，是最好的学习的方法**。

---

**问题二**：有些学习资料上说 `while (left < right)` 表示区间是 `[left..rihgt)` ，为什么你这里是 `[left..rihgt]`？

回答：区间的右端点到底是开还是闭，完全由编写代码的人决定，不需要固定。只要编码的人逻辑前后一致，并且保持不变（这件事情叫遵守「循环不变量」），就是正确的。

我们通篇讲的都是 **左闭右闭** 区间，理由是这样定义更直接。

---

**问题三**：有些学习资料给出了三种模板，例如「力扣」推出的 LeetBook 之 「[二分查找专题](https://leetcode-cn.com/leetbook/detail/binary-search/)」，应该如何看待它们？

回答：三种模板其实区别仅在于退出循环的时候，区间 `[left..right]` 里有几个数。

+ `while (left <= right)` ：退出循环的时候，`right` 在左，`left` 在右，区间为空区间，所以要讨论返回 `left` 和 `right`；
+ `while (left < right)` ：退出循环的时候，`left` 与 `right` 重合，区间里只有一个元素，这一点是我们很喜欢的；
+ `while (left + 1 < right)` ：退出循环的时候，`left` 在左，`right` 在右，区间里有 2 个元素，需要编写专门的逻辑。这种写法在设置 `left` 和 `right` 的时候不需要加 1 和减 1。看似简化了思考的难度，但实际上屏蔽了我们应该且完全可以分析清楚的细节。退出循环以后一定要讨论返回哪一个，也增加了编码的难度。

我个人的经验是：

+ `while (left <= right)` 用在要找的数的性质简单的时候，把区间分成三个部分，在循环体内就可以返回；
+ `while (left < right)` 用在要找的数的性质复杂的时候，把区间分成两个部分，在退出循环以后才可以返回；
+ 完全不用 `while (left + 1 < right)` ，理由是不会使得问题变得更简单，反而很累赘。

---

### 思路

+ 看到的中间数 `nums[i]` 什么时候不是解，比较好想；
+ 「好想」的这一步对了，它的反面就可以很容易得到，边界设置就不容易出错；
+ 依然是建议在编码的时候，把下一轮搜索区间是什么写在注释里；
+ 理解：把要查找的目标元素留在最后判断的思想。这道题就是把可以插入元素的位置留在最后判断，因为一定可以放在一个位置上，最后剩下的那个位置就是插入元素的位置。

如果二分查找一开始写不出来，可以尝试先写暴力法，分析清楚细节；

+ 在有序数组中查找插入元素的位置，显然可以使用二分查找；
+ 这篇题解提供的思路是“排除法”，即：在循环的过程中，不断排除不需要的解，最后剩下的那个元素就一定是我们想要的。

具体的做法是：

+ 首先，插入位置有可能在数组的末尾（题目中的示例 3），需要单独判断；
+ 其次，如果待插入元素比最后一个元素严格小，并且在这个数组中有和插入元素一样的元素，返回任意一个位置即可；
+ 否则，插入的位置应该是严格大于 `target` 的第 1 个元素的位置。

因此，**严格小于 `target` 的元素一定不是解**，根据这个思路，可以写出如下代码。

**参考代码 1**：

Java 代码：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }

        // 特判
        if (nums[len - 1] < target) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            // 严格小于 target 的元素一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        size = len(nums)
        if size == 0:
            return 0

        # 特判
        if nums[size - 1] < target:
            return size

        left = 0
        right = size - 1

        while left < right:
            mid = left + (right - left) // 2
            # 严格小于 target 的元素一定不是解
            if nums[mid] < target:
                # 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1
            else:
                right = mid
        return left
```

C++ 代码：

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int searchInsert(vector<int> &nums, int target) {
        int size = nums.size();
        if (size == 0) {
            return 0;
        }

        // 特判
        if (nums[size - 1] < target) {
            return size;
        }
        int left = 0;
        int right = size - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 严格小于 target 的元素一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```

**复杂度分析**：

+ 时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，每一次都将问题的规模缩减为原来的一半，因此时间复杂度是对数级别的；
+ 空间复杂度：$O(1)$。


由于插入元素的位置，一定在搜索范围里，因此退出循环的时候，不用再做一次判断。

本题还可以有如下两种写法，请读者比较它们的不同之处。

**参考代码 2**：

Java 代码：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        
        int left = 0;
        // 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len
        int right = len;
        
        while (left < right) {
            int mid = (left + right) >>> 1;
            // 小于 target 的元素一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索的区间是 [mid + 1, right]
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        size = len(nums)
        if size == 0:
            return 0

        left = 0
        # 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len
        right = size

        while left < right:
            mid = (left + right) >> 1
            # 严格小于 target 的元素一定不是解
            if nums[mid] < target:
                # 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1
            else:
                right = mid
        return left
```

C++ 代码：

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int searchInsert(vector<int> &nums, int target) {
        int size = nums.size();
        if (size == 0) {
            return 0;
        }

        int left = 0;
        // 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len
        int right = size;

        while (left < right) {
            int mid = left + (right - left) / 2;
            // 小于 target 的元素一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索的区间是 [mid + 1, right]
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```


**参考代码 3**：

Java 代码：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }

        int left = 0;
        int right = len;

        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] < target) {
                // 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1;
            } else if (nums[mid] == target) {
                // 根据本题特殊性，看到等于 target 的元素，返回任意一个即可
                return mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        size = len(nums)
        if size == 0:
            return 0

        left = 0
        # 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len
        right = size

        while left < right:
            mid = (left + right) >> 1
            # 严格小于 target 的元素一定不是解
            if nums[mid] < target:
                # 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1
            elif nums[mid] == target:
                # 根据本题特殊性，看到等于 target 的元素，返回任意一个即可
                return mid
            else:
                right = mid
        return left
```

C++ 代码：

```cpp
#include <iostream>#include <vector>using namespace std;class Solution {public:    int searchInsert(vector<int> &nums, int target) {        int size = nums.size();        if (size == 0) {            return 0;        }        int left = 0;        int right = size;        while (left < right) {            int mid = left + (right - left) / 2;            if (nums[mid] < target) {                // 下一轮搜索区间是 [mid + 1, right]                left = mid + 1;            } else if (nums[mid] == target) {                // 根据本题特殊性，看到等于 target 的元素，返回任意一个即可                return mid;            } else {                right = mid;            }        }        return left;    }};
```

（本节完）

---

（以前写的文字，备份）



传送门：[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) 

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> **示例 1:**
>
> ```
> 输入: [1,3,5,6], 5输出: 2
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,3,5,6], 2输出: 1
> ```
>
> **示例 3:**
>
> ```
> 输入: [1,3,5,6], 7
> 输出: 4
> ```
>
> **示例 4:**
>
> ```
> 输入: [1,3,5,6], 0
> 输出: 0
> ```

分析：根据题意，结合题目给出的 4 个示例，给出这个问题的等价表述如下。

> 1、如果目标值（严格）大于排序数组的最后一个数，返回这个排序数组的长度，否则进入第 2 点。
>
> 2、返回排序数组从左到右，大于或者等于目标值的第 1 个数的**索引**。

说明：事实上，当给出数组中有很多数和目标值相等的时候，我们返回任意一个与之相等的数的索引值都可以，不过为了简单起见，也为了方便后面的说明，我们返回第 1 个。

题目告诉你“排序数组”，其实就是在**疯狂暗示你用二分查找法**。二分查找法的思想并不难，但写好一个二分法还是有一些注意事项的，在这里我借着这道题位为大家总结一下。

刚接触二分法的时候，我们可能会这样写：

Java 代码：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] < target) {
            return len;
        }

        int l = 0;
        int r = len - 1;

        while (l <= r) {
            int mid = (l + r) / 2;
            // 等于的情况最简单，我们应该放在第 1 个分支进行判断
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                // 题目要我们返回大于或者等于目标值的第 1 个数的索引
                // 此时 mid 一定不是所求的左边界，
                // 此时左边界更新为 mid + 1
                l = mid + 1;
            } else {
                // 既然不会等于，此时 nums[mid] > target
                // mid 也一定不是所求的右边界
                // 此时右边界更新为 mid - 1
                r = mid - 1;
            }
        }
        // 注意：一定得返回左边界 l，
        // 如果返回右边界 r 提交代码不会通过
        // 下面我尝试说明一下理由，如果你不太理解下面我说的，那是我的表达问题
        // 【注意】建议你不要纠结这个问题，因为我马上介绍的二分法模板，可以避免对返回 l 和 r 的思考

        // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1
        // 在上面的 while (l <= r) 退出循环以后，r < l，r = 0 ，l = 1
        // 根据题意应该返回 l，
        // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 r

        return l;
    }
}
```

如果你是把二分法可以进行的条件写成 `while (l <= r)` 的话，在写最后一句 `return` 的时候，如果你不假思索，把左边界 `l` 返回回去，可能误打误撞，你就写对了，但是事实上，返回 `l` 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 `r`（这句话不太理解没有关系，我也不打算讲得很清楚，因为太绕了，这不是我要说的重点）。

你可能在一些资料中，看过别人写二分法的时候，把二分法可以进行的条件写成 `while (l < r)` ，你是不是跟我一样有疑问，咦？当左右边界一样的时候，那个数岂不是会被漏掉。但是我要告诉你，这样写是最好的，这是写二分法最好的“模板”。下面给出我的理由。

> 推荐你在 `while` 循环里写 `l < r`，因为在退出循环的时候，你不必纠结返回 `l` 还是返回 `r`。但还有一些细节要注意。

写 `while (l < r)` 的时候，退出循环时，左边界等于右边界，因此你不必纠结要返回 `l` 还是 `r` ，你返回 `l` 或者 `r` 都是可以的。这是“夹逼”的思想，搜索要找到的数，使得区间越来越小，直到区间成为一个数。这里有 2 个细节要注意：

>1、**如果你确定你要找的数一定在左边界和右边界所表示的区间里出现**，那么可以放心地返回 `l` 或者 `r`；
>
>2、如果你不确定你要找的数一定在左边界和右边界所表示的区间里出现，那么也没有关系，只要在退出循环以后，再针对 `nums[l]` 或者 `nums[r]` （此时 `nums[l] == nums[r]`）单独作一次判断，看它是不是你要找的数即可。

这是我推荐使用你写 `while (l < r)` 的主要原因，可以避免你对返回左边界还是右边界的讨论。下面给出这道问题，使用  `while (l < r)`  模板写法的示例代码。

Python 代码：

```python
class Solution:

    def searchInsert(self, nums, target):
    		# 返回大于等于 target 的索引，有可能是最后一个
        size = len(nums)
        if size == 0:
            return 0
        l = 0
        # 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度
        r = size
				# 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界。
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid
        return l
```

写出这段代码是有一定“技巧”的。

1、首先是取中点的方式：`mid = l + (r - l) // 2`。

当 `l` 和 `r` 是很大的整数的时候，你写 `int mid = (l + r) / 2;` 这里 `l + r` 就有可能超过 `int` 类型能表示的最大值，因此使用 `mid = l + (r - l) // 2` 可以避免这种情况。

事实上  `mid = l + (r - l) // 2`  在 `r` 很大，并 `l` 是负数且很小的时候， `r - l` 也有可能超过 `int` 类型能表示的最大值，只不过一般情况下 `l` 和 `r` 表示的是数组索引值，`l` 是非负数，因此  `r - l`  溢出的可能性很小。

另外，还要注意一点，我们知道当数组的元素个数是偶数的时候，中位数有左中位数和右中位数：

+ 使用 `mid = l + (r - l) // 2` 得到左中位数的索引；

+ 使用 `mid = l + (r - l + 1) // 2` 得到右中位数的索引。

我们使用一个具体的例子来验证这件事情，当索引 `l = 3`，索引 `r = 4` 的时候，左中位数是索引 `l`，右中位数是索引 `r`，这是因为：

`mid = l + (r - l) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3`，

`mid = l + (r - l + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4`，

记忆方法：`(r - l)` 不加 1 选左中位数，加 1 选右中位数。

那么什么时候使用左中位数，什么时候使用右中位数呢？这就要看分支的逻辑了。

2、编写分支的逻辑循序先写“排除逻辑”所在的分支。

> 先考虑能把“中位数”排除在外的逻辑，而不能排除“中位数”的逻辑放在 `else` 分支里，这样做的理由有 2 点：
>
> 1、可以排除“中位数”的逻辑，通常比较好想（但并不绝对，这一点视情况而定）；
>
> 2、分支条数变成 2 ，比原来 3 个分支要考虑的情况少，即**不用单独考虑中位数是否满足题意**，**因为退出循环的时候，左右区间压缩成一个数（索引）的时候，这个索引表示的数要么满足题意，要么不满足题意，而不必在二分逻辑中单独做判断**（这一点很重要，希望读者结合具体例子仔细体会）。

以本题为例，最开始我们就分析了要求我们找到“大于或者等于目标值的第 1 个数的**索引**”。所以

+ 如果中位数小于目标值，就应该被排除，左边界 `l` 就至少是 `mid + 1`，这个逻辑很容易分析清楚；

+ 如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 1 个数的**索引**，**中位数以及中位数的左边都有可能是符合题意的数**，因此右边界就不能把 `mid` 排除，因此右边界 `r` 至多是 `mid` 。

而下一点就更关键了。

3、根据分支编写的情况，选择使用左中位数还是右中位数。

我们应该先写分支，再写中位数，看看应该选左中位数还是右中位数。这个结论不用记住，需要结合具体例子理解。规则如下：

> 二分法之所以有效，是因为在每一轮的逻辑判断中，都可以排除差不多一半的候选数，即**候选区间会收缩，最终收缩成 1 个数的时候，就定位了我们真正要找的那个数**。但是**在区间元素只有 2 个时候，中位数的选择如果不恰当，很可能会出现死循环**。
>
> 为了避免出现死循环，我们需要保证：
>
> 1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；
>
> 2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。

上面的规则说起来很绕，不要去记它，我写的时候都晕。理解上面的这个规则可以通过具体的例子：

> 针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：
>
> Python 代码：
>
> ```python
> while l < r:	# 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整mid = l + (r - l) // 2# 业务逻辑代码if (check(mid)):  # 选择右边界的时候，可以排除中位数  r = mid - 1else:  # 选择左边界的时候，不能排除中位数  l = mid
> ```
>
> + **在区间中的元素只剩下 2 个时候**，例如：`l = 3`，`r = 4`。此时**左中位数就是左边界**，如果你的逻辑执行到 `l = mid` 这个分支，**且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环**；
> + 为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 `l = mid` 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 `r = mid - 1` 让区间收缩，最终成为 1 个数，退出 `while` 循环。
>
> 上面的这种情况如果你理解了，就可以类似地看待提出的规则的第 2 点。

总结一下，我爱用这个模板的原因、技巧和注意事项：

> 1、技巧：无脑地写 `while l < r:` ，这样你就不用判断，在退出循环的时候你应该返回 `l` 还是 `r`；
>
> 2、技巧：先写分支逻辑，并且先写排除中位数的逻辑分支，再根据分支的情况选择使用左中位数还是右中位数；
>
> 3、原因：分支条数只有 2 条，代码执行效率更高，不用单独判断中位数是否符合题目要求，因为在在二分的过程中，区间会逐渐收缩，二分的时候，代码逻辑的关注点是排除将近一半的候选数；
>
> 4、注意1：如果你确定你要找的数就在候选区间里，那么退出循环的时候，区间最后收成为 1 个数后，直接把这个数返回即可；如果你最后要找的数有可能不在候选区间里，区间最后收成为 1 个数后，还要单独判断一下这个数是否符合题意；
>
> 5、注意2：左中位数还是右中位数选择的标准根据分支的逻辑而来，这个标准就是每一次循环让区间收缩，在区间只剩下 2 个元素的时候，为了避免死循环发生，如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因。

最后给出两个模板，大家看的时候看注释，不用记这个模板：

Python 代码：

```python
def binary_search_1(l, r):
    # 当分支逻辑不能排除右边界的时候选择左中位数
    # 如果选择右中位数，当区间只剩下 2 个元素的时候，
    # 一旦进入 r = mid 这个分支，右边界不会收缩，代码进入死循环
    while l < r:
        mid = l + (r - l) // 2
        if check(mid):
            # 先写可以排除中位数的逻辑
            l = mid + 1
        else:
            # 右边界不能排除
            r = mid
```

Python 代码：

```python
def binary_search_2(l, r):
    # 当分支逻辑不能排除左边界的时候选择右中位数
    # 如果选择做中位数，当区间只剩下 2 个元素的时候，
    # 一旦进入 l = mid 这个分支，左边界不会收缩，代码进入死循环
    while l < r:
        mid = l + (r - l + 1) // 2
        if check(mid):
            # 先写可以排除中位数的逻辑
            r = mid - 1
        else:
          	# 左边界不能排除
            l = mid
```

说明：我写的时候，一般是先把中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 `(r - l)` 这个括号里面加 1 。

本题选择“左中位数”，选择“右中位数”的是 [「力扣」第 69 题：x 的平方根](https://leetcode-cn.com/problems/sqrtx/)。

我想我应该是成功地把你绕晕了，在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，**在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的**。

---

（以下是原始文章，备份用）

# 特别好用的二分查找法模板（Python 代码、Java 代码）

| 题目地址                                                     | 题解                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [LeetCode 第 35 题：搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) | [特别好用的二分查找法模板（Python 代码、Java 代码）](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/) |

分析：根据题意，结合题目给出的 4 个示例，不难分析出这个问题的等价表述如下。

> 1、如果目标值（严格）大于排序数组的最后一个数，返回这个排序数组的长度，否则进入第 2 点。
>
> 2、返回排序数组从左到右，大于或者等于目标值的第 1 个数的**索引**。

事实上，当给出数组中有很多数和目标值相等的时候，我们返回任意一个与之相等的数的索引值都可以，不过为了简单起见，也为了方便后面的说明，我们返回第 1 个符合题意的数的索引。

题目告诉你“排序数组”，其实就是在**疯狂暗示你用二分查找法**。二分查找法的思想并不难，但写好一个二分法并不简单，就借着这道题为大家总结一下。

### 一、传统二分查找法模板

刚接触二分查找法的时候，我们可能会像下面这样写代码，我把这种写法容易出错的地方写在了注释里：

Java 代码：

```Java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] < target) {
            return len;
        }

        int l = 0;
        int r = len - 1;

        while (l <= r) {
            int mid = (l + r) / 2;
            // 等于的情况最简单，我们放在第 1 个分支进行判断
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                // 题目要我们返回大于或者等于目标值的第 1 个数的索引
                // 此时 mid 一定不是所求的左边界，
                // 此时左边界更新为 mid + 1
                l = mid + 1;
            } else {
                // 既然不会等于，此时 nums[mid] > target
                // mid 也一定不是所求的右边界
                // 此时右边界更新为 mid - 1
                r = mid - 1;
            }
        }
        // 注意：一定得返回左边界 l，
        // 如果返回右边界 r 提交代码不会通过
        // 下面我尝试说明一下理由，如果你不太理解下面我说的，那是我的表达问题
        // 【注意】建议你不要纠结这个问题，因为我马上介绍的二分法模板，可以避免对返回 l 和 r 的思考

        // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1
        // 在上面的 while (l <= r) 退出循环以后，r < l，r = 0 ，l = 1
        // 根据题意应该返回 l，
        // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 r

        return l;
    }
}
```

说明：如果你把二分查找法可以进行的条件写成 `while (l <= r)` 的话，在写最后一句 `return` 的时候，如果你不假思索，把左边界 `l` 返回回去，可能误打误撞，你写对了。但是事实上，返回 `l` 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 `r`，这句话不太理解没有关系，我也不打算讲得很清楚，因为太绕了，这不是我要说的重点。

> 传统二分查找法的问题在于，当退出 `while` 循环的时候，应该返回左边界还是右边界比较容易出错。

那么是不是可以回避这个问题呢？答案是肯定的，并且只要你掌握了下面我介绍的“神奇的”二分查找法模板，你会屡试不爽的。

### 二、“神奇的”二分查找法模板

在一些资料中，你可能看过别人写二分查找法，把循环可以进行的条件写成 `while (l < r)` ，当时你是不是跟我一样有疑问，咦？当左右边界一样的时候，那个数岂不是会被漏掉。但是我要告诉你，这样写是最好的，这是最好二分查找法“模板”的一部分。

> 理由很简单，写 `while (l < r)` 的时候，退出循环时，左边界等于右边界，因此你不必纠结要返回 `l` 还是 `r` ，此时返回 `l` 或者 `r` 都是可以的。

二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，**使得搜索区间越来越小，直到区间成为一个数**。不过这里有个细节要注意：

>1、**如果你确定你要找的数一定在左边界和右边界所表示的区间里出现**，那么可以放心地返回 `l` 或者 `r`；
>
>2、如果你不确定你要找的数一定在左边界和右边界所表示的区间里出现，那么也没有关系，只要在退出循环以后，再针对 `nums[l]` 或者 `nums[r]` （此时 `nums[l] == nums[r]`）单独作一次判断，看它是不是你要找的数即可。

写 `while (l < r)` 可以避免你对返回左边界还是右边界的讨论。下面给出这道问题，使用 `while (l < r)` 模板写法的参考代码。

Python 代码：

```Python
class Solution:

    def searchInsert(self, nums, target):
    	# 返回大于等于 target 的索引，有可能是最后一个
        size = len(nums)
        if size == 0:
            return 0
        l = 0
        # 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度
        r = size
		
        # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid
        return l
```

Java 代码：

```Java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (target > nums[len - 1]) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
}
```

不过写出这段代码还是有一定“技巧”的。

### 三、技巧、调试方法和注意事项

1、首先，得弄清楚取中点的方式。

（1）当 `l` 和 `r` 是很大的整数的时候，你写 `int mid = (l + r) / 2;` 这里 `l + r` 就有可能超过 `int` 类型能表示的最大值，因此使用 `mid = l + (r - l) // 2` 可以避免这种情况。

事实上  `mid = l + (r - l) // 2`  在 `r` 很大，并 `l` 是负数且很小的时候， `r - l` 也有可能超过 `int` 类型能表示的最大值，只不过一般情况下 `l` 和 `r` 表示的是数组索引值，`l` 是非负数，因此  `r - l`  溢出的可能性很小。

（2）另外还要注意，当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分：

+ 使用 `mid = l + (r - l) // 2` 得到左中位数的索引；

+ 使用 `mid = l + (r - l + 1) // 2` 得到右中位数的索引。

当数组的元素个数是奇数的时候，二者都能选到最中间的那个中位数。

我们使用一个具体的例子来验证这件事情，当索引 `l = 3`，索引 `r = 4` 的时候，左中位数是索引 `l`，右中位数是索引 `r`，这是因为：

`mid = l + (r - l) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3`，

`mid = l + (r - l + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4`。

> 记忆方法：**`(r - l)` 不加 1 选左中位数，加 1 选右中位数**。

那么，什么时候使用左中位数，什么时候使用右中位数呢？这就要看分支的逻辑了。

2、编写分支的逻辑循序先写“排除逻辑”所在的分支。

**这里介绍很重要的一个技巧**：先考虑能把“中位数”排除在外的逻辑，而不能排除“中位数”的逻辑放在 `else` 分支里，这样做的理由有 2 点：

> （1）可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定；
>
> （2）分支条数变成 2 条，比原来 3 个分支要考虑的情况少，即**不用单独考虑中位数是否满足题意**，**因为退出循环的时候，左右区间压缩成一个数（索引）的时候，这个索引表示的数要么满足题意，要么不满足题意，而不必在二分逻辑中单独做判断**（这一点很重要，希望读者结合具体例子仔细体会）。

以本题为例，最开始我们就分析了要求我们找到“大于或者等于目标值的第 1 个数的**索引**”。所以对于这道题而言：

（1）如果中位数小于目标值，就应该被排除，左边界 `l` 就至少是 `mid + 1`；

（2）如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 1 个数的**索引**，**中位数以及中位数的左边都有可能是符合题意的数**，因此右边界就不能把 `mid` 排除，因此右边界 `r` 至多是 `mid`，此时右边界不向左边收缩。

**而下一点就更关键了**。

3、根据分支编写的情况，选择使用左中位数还是右中位数。

先写分支，根据分支的逻辑选中位数，选左中位数还是右中位数，这要做的理由是为了防止出现死循环。

> 死循环就容易发生在区间元素只有 2 个时候，此时中位数的选择尤为关键。

为了避免出现死循环，我们需要确保：

> 1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；
>
> 2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。

上面的规则说起来很绕，可以暂时跳过，不要去记它，我写的时候都晕。理解上面的这个规则可以通过具体的例子：

针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：

Python 伪代码：

```python
while l < r:
      # 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整
    mid = l + (r - l) // 2
    # 业务逻辑代码
    if (check(mid)):
        # 选择右边界的时候，可以排除中位数
        r = mid - 1
    else:
        # 选择左边界的时候，不能排除中位数
        l = mid
```

+ **在区间中的元素只剩下 2 个时候**，例如：`l = 3`，`r = 4`。此时**左中位数就是左边界**，如果你的逻辑执行到 `l = mid` 这个分支，**且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环**；
+ 为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 `l = mid` 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 `r = mid - 1` 让区间收缩，最终成为 1 个数，退出 `while` 循环。

上面的这种情况如果你理解了，就可以类似地理解提出的规则的第 2 点。

> 按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在 [「力扣」第 69 题：x 的平方根](https://leetcode-cn.com/problems/sqrtx/)的题解[《二分查找 + 牛顿法（Python 代码、Java 代码）》](https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/) 。

### 四、使用总结

总结一下，我爱用这个模板的原因、技巧、优点和注意事项：

> 1、原因：无脑地写 `while l < r:` ，这样你就不用判断，在退出循环的时候你应该返回 `l` 还是 `r`；
>
> 2、技巧：先写分支逻辑，并且先写排除中位数的逻辑分支（因为容易想到），再根据分支的情况选择使用左中位数还是右中位数；
>
> 3、优点：分支条数只有 2 条，代码执行效率更高，不用单独判断中位数是否符合题目要求，**写分支的逻辑的目的是尽量排除更多的候选元素**，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；
>
> 4、注意事项 1：左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，在区间只剩下 2 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；
>
> 5、注意事项 2：如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 1 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 1 个数后，还要单独判断一下这个数是否符合题意；

最后给出两个模板，大家看的时候看注释，而不必也无需记忆它们，最好的理解这个模板的方法还是应用它。

Python 伪代码1： 分支是右区间不收缩的时候，选中位数选左中位数，因为如果你选右中位数，会出现死循环。

```Python
def binary_search_1(l, r):
    # 当分支逻辑不能排除右边界的时候选择左中位数
    # 如果选择右中位数，当区间只剩下 2 个元素的时候，
    # 一旦进入 r = mid 这个分支，右边界不会收缩，代码进入死循环
    while l < r:
        mid = l + (r - l) // 2
        if check(mid):
            # 先写可以排除中位数的逻辑
            l = mid + 1
        else:
            # 右边界不能排除
            r = mid
    # 退出循环的时候，视情况，是否需要单独判断 l （或者 r）这个索引表示的元素是否符合题意
```

Python 伪代码2：分支是左区间不收缩的时候，选中位数选右中位数，因为如果你选左中位数，会出现死循环。

```Python
def binary_search_2(l, r):
    # 当分支逻辑不能排除左边界的时候选择右中位数
    # 如果选择做中位数，当区间只剩下 2 个元素的时候，
    # 一旦进入 l = mid 这个分支，左边界不会收缩，代码进入死循环
    while l < r:
        mid = l + (r - l + 1) // 2
        if check(mid):
            # 先写可以排除中位数的逻辑
            r = mid - 1
        else:
          	# 左边界不能排除
            l = mid
    # 退出循环的时候，视情况，是否需要单独判断 l （或者 r）这个索引表示的元素是否符合题意
```

**说明**：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 `(r - l)` 这个括号里面加 1 。

我想我应该是成功地把你绕晕了，在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，**在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的**。

### 五、应用提升

这里给出一些练习题，这些练习题都可以使用这个“神奇的”二分查找法模板比较轻松地写出来，并且得到一个不错的分数，大家加油！

![LeetCode 第 704 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/704.png)


说明：[传送门](https://leetcode-cn.com/problems/binary-search/)。这道题是二分查找的模板题，因为目标值有可能在数组中并不存在，所以退出 `while` 循环的时候，要单独判断一下。


![LeetCode 第 69 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/69.png)


说明：[传送门](https://leetcode-cn.com/problems/sqrtx/)。

（1）题解链接已经在上文中已经给出，这道题根据分支的逻辑应该选右中位数；

（2）这道题因为还有更高效的“牛顿法”，所以看起来排名并不是特别理想。


![LeetCode 第 300 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/300.png)



说明：[传送门](https://leetcode-cn.com/problems/longest-increasing-subsequence)，第 300 题的一个子过程就是本题（第 35 题），我在这道题的题解[《动态规划 + 贪心算法（二分法）（Python 代码、Java 代码）》](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/) 中给了两个 Python 的示例代码，它们是对本文中给出的注意事项：

> 如果你确定要搜索的数在区间里，循环完成以后直接返回即可；如果你不确定要搜索的数在区间里，循环完成以后需要再做一次判断。

的具体代码实现。

![LeetCode 第 153 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/153.png)


说明：[传送门](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)，二分查找法还可以用于部分有序数组中元素的查找。


![LeetCode 第 154 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/154.png)

说明：[传送门](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/description/)。


![LeetCode 第 287 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/287.png)


说明：[传送门](https://leetcode-cn.com/problems/find-the-duplicate-number/)，这道题是对“数”作二分，而不是对索引做二分，具体可以参考我写的题解[《二分法（Python 代码、Java 代码）》](https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/)。

![LeetCode 第 1095 题](https://liweiwei1419.github.io/images/leetcode-solution-new/0035/1095.png)

说明：[传送门](https://leetcode-cn.com/problems/find-in-mountain-array/submissions/)。这道题很有意思，做这一道题等于做了 3 道二分查找的问题，并且，你还会发现，这 3 个二分查找的问题写出来的分支都是一样的，因此它们选中位数的时候，都选择了左中位数。


---

# LeetCode 第 35 题：搜索插入位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> 示例 1：
>
> ```
> 输入: [1, 3, 5, 6], 5
> 输出: 2
> ```
>
>
> 示例 2：
>
> ```
> 输入: [1, 3, 5, 6], 2
> 输出: 1
> ```
>
>
> 示例 3：
>
> ```
> 输入: [1, 3, 5, 6], 7
> 输出: 4
> ```
>
> 示例 4：
>
> ```
> 输入: [1, 3, 5, 6], 0
> 输出: 0
> ```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-insert-position
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 方法一：暴力解法

从左向右遍历，找到第 1 个大于等于 `target` 的数的索引。

可以先做一个特殊判断，如果最后一个数都**严格**小于 `target`，那么插入元素的位置就是数组最后一个位置的后面。数组最后一个位置的索引是 `len - 1` ，下一个位置当然就是 `len`。

时间复杂度：$O(N)$

### 方法二：二分查找

根据暴力解法的分析，找到第 1 个大于等于 `target` 的数的索引即可。

> **于是严格小于一定不是解。**

根据此编写“减而治之”的二分查找法。

### 最优代码：

Java 代码：

```java
/**
 * @author liweiwei1419
 * @date 2019/11/19 4:06 下午
 */
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        int left = 0;
        // len - 1 的下一位也有可能是插入的位置，因此右边界设置为 len
        int right = len;

        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] == target) {
                // 分支 1：mid 右边（不包含 mid）一定不是解，因此下一轮搜索的范围是 [left, mid]
                right = mid;
            } else if (nums[mid] < target) {
                // 分支 2：mid 左边（包含 mid）一定不是解，因此下一轮搜索的范围是 [mid + 1, right]
                left = mid + 1;
            } else {
                // 分支 3： nums[mid] > target
                // mid 右边（不包含 mid）一定不是解，因此下一轮搜索的范围是 [left, mid]
                // 可以合并到分支 1
                right = mid;
            }
        }
        return left;
    }
}
```

+ 比较下面两种写法的不同

Java 代码：先做特判

```java
public class Solution {
    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        // 特判
        if (target > nums[len - 1]) {
            return len;
        }

        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:

    def searchInsert(self, nums: List[int], target: int) -> int:
        # 返回大于等于 target 的索引，有可能是最后一个
        size = len(nums)
        # 特判 1
        if size == 0:
            return 0
        # 特判 2：如果比最后一个数字还要大，直接接在它后面就可以了
        if target > nums[-1]:
            return size

        left = 0
        right = size - 1
        # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界
        while left < right:
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            if nums[mid] < target:
                left = mid + 1
            else:
                assert nums[mid] >= target
                right = mid
        return left


if __name__ == '__main__':
    # nums = [1, 3, 5, 6]
    nums = [1, 2, 3, 5, 5, 5]

    target = 5
    solution = Solution()
    result = solution.searchInsert(nums, target)
    print('结果：', result)

```

Java 代码：把 `len` 作为一般情况

```java
public class Solution2 {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len;

        while (left < right) {
            int mid = (left + right) >>> 1;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:

    # 返回的是大于等于 target 的索引，有可能是最后一个

    def searchInsert(self, nums: List[int], target: int) -> int:
        size = len(nums)
        if size == 0:
            return 0
        left = 0
        right = size
        while left < right:
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            if nums[mid] >= target:
                right = mid
            else:
                assert nums[mid] < target
                # [1,5,7] 2
                left = mid + 1
        return left


if __name__ == '__main__':
    nums = [1, 3, 5, 6]
    target = 5
    solution = Solution()
    result = solution.searchInsert(nums, target)
    print(result)
```

Python 代码：

```python
from typing import List


class Solution:

    def searchInsert(self, nums: List[int], target: int) -> int:
        # 返回大于等于 target 的索引，有可能是最后一个
        size = len(nums)
        # 特判
        if size == 0:
            return 0

        left = 0
        # 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度
        right = size
        # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界
        while left < right:
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            if nums[mid] < target:
                left = mid + 1
            else:
                assert nums[mid] >= target
                # [1,5,7] 2
                right = mid
        # 调试语句
        # print('left = {}, right = {}, mid = {}'.format(left, right, mid))
        return left


if __name__ == '__main__':
    # nums = [1, 3, 5, 6]
    nums = [1, 2, 3, 5, 5, 5]

    target = 5
    solution = Solution()
    result = solution.searchInsert(nums, target)
    print('结果：', result)

```

---

0035-搜索插入位置（读者评论区回答）.py

```python
from typing import List


class Solution:

    # 返回的是大于等于 target 的索引，有可能是最后一个

    def searchInsert(self, nums: List[int], target: int) -> int:
        length = len(nums)
        left = 0
        # 修改 1：如果 target 比数组的最后一个元素还要大，那么插入的位置就应该是 length，因此右边界应该为 length
        right = length
        while left < right:

            # 修改 4：根据下面两个分支的逻辑，应该选左中位数，如果选右中位数，右边界不更新的话，会陷入死循环
            # 以下代码各选一行都是可以的，没有被我注释的那一行代码更优
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1

            # 修改 2：（理解这里很关键，根据题意）这里应该加等于号，结合题目意思，nums[mid] > target 的时候，mid 有可能就是要定位的索引
            # 因此不能把 mid 排除，并且还要把 target == nums[mid] 的情况归到这个分支来
            if target <= nums[mid]:
                right = mid
            else:
                # 修改 3：当 nums[mid] < target 的时候，因为我们要找的是第 1 个大于等于 target 的索引，因此 mid 肯定不是所求，故左边界是 mid + 1
                assert target > nums[mid]
                left = mid + 1
        return left


if __name__ == '__main__':
    nums = [1, 3, 5, 6]
    target = 5
    solution = Solution()
    result = solution.searchInsert(nums, target)
    print(result)

```


---
title: LeetCode 专题：二分查找
date: 2018-9-1 08:00:00
author: liwei
top: false
mathjax: true
categories: leetcode 专题
tags:
  - 二分查找
permalink: leetcode-tag/binary-search
---

# LeetCode 专题 ：二分查找

## 一、二分查找模板例题

「力扣」第 704 题是二分查找的 **最基本** 问题。

### 例 1：「力扣」第 704 题：二分查找

题目链接：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```



**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

---

注意：首先要求带查找的数组应该是排好序的。

**参考代码 1**：

```java
public class BinarySearch {
  
    public static int search(int[] arr, int target) {
        // 首先保证数组是有序的，否则不能使用二分查找法
        SortTestHelper.testSorted(arr);
        int l = 0;
        int r = arr.length - 1;
        // arr[0,r]
        while (l <= r) {
            // int mid = (l + r) / 2;
            int mid = l + (r - l) / 2;
            if (arr[mid] == target) {
                return mid;
            }
            if (target < arr[mid]) {
                // 回到定义中就好理解了
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return -1;
    }
}
```

可以使用递归的方式实现二分查找。递归实现通常在思维上理解更容易，但递归在性能上会略差，因为会调用系统栈。递归实现的二分查找如「参考代码 2」。

**参考代码 2**：

```java
public class BinarySearch2 {
    /**
     * 首先要求带查找的数组应该是排好序的
     *
     * @param arr    待查找的已经排好序的数组
     * @param target 待查找的数
     * @param left   左边界，可以取到
     * @param right  右边界，可以取到
     * @return
     */
    public static int binarySearch(int[] arr, int target, int left, int right) {
        if (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (target < arr[mid]) {
                return binarySearch(arr, target, left, mid - 1);
            } else if (target > arr[mid]) {
                return binarySearch(arr, target, mid + 1, right);
            }
        }
        return -1;
    }
}
```

注意：1、先写递归到底的情况；

2、注意下面的这个代码片段

```java
else if (target < arr[mid]) {
    return binarySearch(arr, target, left, mid - 1);
} else if (target > arr[mid]) {
    return binarySearch(arr, target, mid + 1, right);
}
```

一定要写 `return` 语句，要不然总是返回 $-1$。

#### “好用的”二分查找模板

这里推荐的“好用的”二分法模板是“大雪菜”整理的二分查找模板，传送门：[二分查找算法模板](https://www.acwing.com/blog/content/31/)，我个人觉得使用这个模板可以减少编码出错的可能，编码也比较简单。

Python 代码：

```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """

        size = len(nums)

        if size == 0:
            return -1

        l = 0
        r = size - 1

        while l < r:
            mid = l + (r - l + 1) // 2
            if nums[mid] <= target:
                # mid 在，因此，不能排除 mid
                l = mid
            else:
                assert nums[mid] > target
                # mid 不在，所以可以排除 mid
                r = mid - 1
        # 最后要判断一下
        if nums[l] == target:
            return l
        return -1
```

说明：1、`mid = l + (r - l + 1) // 2` 这些写法中点靠右边，而底下的逻辑是从右边向左边靠拢的，因此不会出现死循环；

2、为了避免不存在的情况出现，最后要判断一下，那个数是不是我们要找的数。

Python 代码：

```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """

        size = len(nums)

        if size == 0:
            return -1

        l = 0
        r = size - 1

        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                # mid 可以排除，所以要 + 1
                l = mid + 1
            else:
                assert nums[mid] >= target
                # mid 不能排除，所以至少是 mid 这个位置
                r = mid
        # 为了避免不存在的情况出现，最后要判断一下
        if nums[l] == target:
            return l
        return -1
```



参考资料：1、[你真的会写二分查找吗](https://www.cnblogs.com/luoxn28/p/5767571.html)；

2、[《剑指 Offer》（第 2 版）第 56 题：数字在排序数组中出现的次数](https://www.zybuluo.com/liweiwei1419/note/1398107)。

（本节完）
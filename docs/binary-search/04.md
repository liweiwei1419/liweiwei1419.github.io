---
title: 第 4 节 把区间分成两个部分
icon: shoucang
category: 二分查找
tags:
  - 二分查找
---

上一节我们讲解了「力扣」上一类二分查找问题的共同特点，这一节我们讲解针对这一类问题的解法。第 3 节和第 4 节是重点，但是绝对不是难点，刚开始可能会不习惯，题目做多了，就慢慢理解了。

我们再复习一下：

::: info 这些问题的共同特点（十分重要，请阅读 10 遍）

如果当前猜的数 `nums[mid]` 符合某个性质，我们还不能确定它一定就是我们要找的元素，必须向左边（或者向右边）继续看下去，才能确定 `nums[mid]` 是不是我们要找的元素。

:::

解决这一类问题可以「把区间分成两个部分」。这样的「二分查找」叫做「两边夹」或者叫「排除法」，思路其实很简单：

::: info 重点
每一次排除掉一定不存在问题答案的区间，把 `left` 和 `right` 根据 `mid` 看到的值逐渐向中间靠拢，直到它们重合。
:::

如下图所示：

![二分查找动画](https://tva1.sinaimg.cn/large/008i3skNgy1gxavzkufbmg30u00gwwjo.gif)

根据这种思路，我们就可以肯定：

+ 找到了问题的答案（`left` 和 `right` 重合的位置就是问题的答案）；
+ 或者搜索范围里不存在问题的答案。

大家常见的「二分查找」法的两个模板（其实是一个模板）就是这种思想的体现：

## 「二分查找」法的两个模板

::: info  说明
+ `while (left < right)` 表示当 `left` 与 `right` 重合的时候停止搜索，这样我们就不用思考返回 `left` 还是 `right`；
+ `while` 里面只写两个分支，即只有 `if` 和 `else`，表示：非此即彼，把其中一种情况考虑好，不满足这种情况的区间就是上一个区间的反面区间。
:::

温馨提示：模板代码只是告诉我们所有的二分查找都可以写成以下两种形式。


**代码 1**：

```java
// 目标元素可能存在在区间 [left..right]
while (left < right) {
    int mid = (left + right) / 2;
    if (判别条件) {
        // 下一轮搜索区间 [mid + 1..right]
        left = mid + 1;
    } else {
        // 下一轮搜索区间 [left..mid]
        right = mid;
    }
}
// 退出循环以后 left == right 成立
// 视情况判断 nums[left] 是否是我们要找的
```

**代码 2**：

```java
// 目标元素可能存在在区间 [left..right]
while (left < right) {
    int mid = (left + right + 1) / 2;
    if (判别条件) {
        // 下一轮搜索区间是 [left..mid - 1]
        right = mid - 1;
    } else {
        // 下一轮搜索区间是 [mid..right]
        left = mid;
    }
}
// 退出循环以后 left == right 成立
// 视情况判断 nums[left] 是否是我们要找的
```



::: danger 模板代码没有告诉我们：
+ 什么时候向左边找、什么时候向右边找；
+ 看到的 `mid` 位置的值是保留还是排除。  

这两个问题的答案需要从题目中获得，因此我们必须 **认真审题**。
:::






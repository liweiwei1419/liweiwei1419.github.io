大家好 这里是算法不好玩

这一节我们和大家分享二分查找的一种写法

把区间分成两个部分

把区间分成两个部分的意思是

根据看到的中间元素 nums[mid] 的值把搜索区间分成两个部分

一个部分一定不存在目标元素

另一个部分有可能存在目标元素

下一轮搜索只在有可能存在目标元素的区间里继续查找

我们通过让左边界 left 和 右边界 right

向中间靠拢的方式

让它们最后重合在一起

最后重合在一起的位置就是我们要找的目标元素的位置

---

在循环体内我们需要判断

mid 位置是否有可能是目标元素

并且下一轮搜索

应该在 mid 的左边继续查找

还是在 mid 的右边继续查找


```java
public class Solution {

    public int search(int[] nums, int target) {
        int len = nums.length;

        int left = 0;
        int right = len - 1;
        // 目标元素可能存在在区间 [left..right]
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target) {
                // 下一轮搜索区间 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索区间 [left..mid]
                right = mid;
            }
        }
        if (nums[left] == target) {
            return left;
        }
        return -1;
    }
}
```

```java
public class Solution {

    public int search(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        // 目标元素可能存在在区间 [left..right]
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] > target) {
                // 下一轮搜索区间是 [left..mid - 1]
                right = mid - 1;
            } else {
                // 下一轮搜索区间是 [mid..right]
                left = mid;
            }
        }
        if (nums[left] == target) {
            return left;
        }
        return -1;
    }
}
```


现在大家看到的是「力扣」第 704 题

使用这种思考方式的两版代码

循环可以继续的条件是

while left < right

在循环体内只写两个分支

这样写的好处是退出循环以后

left 与 right 重合

很多问题 left 与 right 重合的位置

就是我们要找的目标元素的位置



第 704 题由于我们不能够确定

最后 left 与 right 重合的位置

就是我们要找的目标元素的位置

所以还需要单独做一次判断




根据题目给出的条件

如果 mid 以及 mid 的左边不存在目标元素

下一轮搜索的时候就应该在 mid 的右边继续查找

这个时候设置 left = mid + 1


如果 mid 的左边不存在目标元素

mid 有可能是目标元素

这个时候我们设置 left = mid

不能够排除掉 mid 这个位置


如果 mid 以及 mid 的右边不存在目标元素

下一轮搜索的时候就应该在 mid 的左边继续查找

这个时候我们设置 right = mid - 1


如果 mid 的右边不存在目标元素

mid 有可能是目标元素

这个时候我们设置 right = mid

不能排除掉 mid 这个位置


这 4 种情况其实是配对的

如果排除了 mid 位置的值并且向右边继续查找

它的反面就是保留了 mid 位置的值并且向左边继续查找

这两个区间组成了原来的整个区间


如果排除了 mid 位置的值并且向左边继续查找

它的反面就是保留了 mid 位置的值并且向右边继续查找

同样地这两个区间组成了原来的整个区间

我们一直在找下一轮搜索区间是什么



我们和大家多次提到过

二分查找的思想是逐渐地缩小搜索区间

所以编写「判别条件」是很关键的

不同的问题不一样

我们会在第 5 节和大家分享编写「判别条件」的经验

把刚才大家看到的区间划分的两种配对的情况

写成代码就是这个样子

请大家注意

这两版代码不是告诉大家它们可以套用

这两版代码完全不需要记忆

也不可以记忆

到底判别条件是什么逻辑

是和具体的问题密切相关的

只要我们认真审题

仔细分析

便不难把代码写对

二分查找问题考的不是技巧

而是仔细和认真


这里有一个细节

当边界设置是 left = mid

和 right = mid - 1 的时候



取中间数需要上取整



为什么需要上取整呢 

我们在下一节和大家说

这就是这一节的内容

感谢大家的收看
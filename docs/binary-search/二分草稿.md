



而在这种情况下

取中间位置的元素就需要根据二分查找的逻辑

考虑到底是上取整还是下取整

我们看到了一个等于目标值的元素以后
这个元素有可能是我们要找的元素

也有可能不是我们要找的元素

解决这样的问题把区间分成三个部分

不太容易把代码写对

我们在下一节向大家介绍的二分查找算法的思想是

把搜索区间分成两个部分
左边界 left 和 右边界 right
通过向中间靠拢的方式
最后重合在一起
最后重合在一起的位置就是我们要找的目标元素的位置

也就是说
在循环体中不断地排除
一定不存在目标元素的部分
在退出循环体的时候才真正找到了我们需要的元素














> 一定不存在目标元素的区间，可能存在目标元素的区间。


二分查找基本思想非常地简单



把确定了不是目标元素的都排除掉
剩下的那个元素就是我们要找的元素



## 把区间分成两个部分


借甜姐的楼向大家问好哈。这道题如果模拟实现的话其实考的是「循环单向链表」（链表尾指向链表头部，且每个结点只有一个后继结点），由于 Java 里面没有现成的类库可以使用，因此先尝试用 LinkedList 发现超时，然后用 ArrayList。

发现超时然后去看源码，发现原因是非常正确的做法。不太建议花时间自己去实现「循环单向链表」，容易把自己绕进去。有时间看一看数学解法更有收获。

祝大家刷题愉快！



这个讲师是所有讲算法题里对初学者最好的，从暴力解法开始，一点点告诉你解这道题的思路和细节。如果想走捷径，就不要看。


我们把这种二分查找算法的要点为大家归纳如下



第一  循环可以继续的条件写成 while left < right

在只把区间分成两个部分的前提下（重点）

在退出循环以后一定有 left 与 right 重合

请大家注意

只把区间分成两个部分这个前提很重要

有了这个前提

我们才可以说退出循环以后一定有 left 与 right 重合

这个时候我们就不用判断是返回 left 位置的值

还是返回 right 位置的值

这一点可以简化思考难度的地方



第二 只

这句话



我们接下来在可能存在目标元素的区间里继续查找







对应地还有两种情况



























当区间里只剩下一个元素的时候

如果我们可以确定在一开始的设定的搜索范围里一定有解

那么 left 和 right 最后重合的这个地方就一定是

我们要找的那个元素



如果不确定在一开始的设定的搜索范围里一定有解

退出循环的时候单独做一次判断就可以了









我们说把区间分成两个部分

依然是看一眼 mid 所在位置的元素的值

根据 mid 的值

首先需要判断 mid 这个位置是否在下一轮搜索的区间里

其次需要判断下一轮应该在 mid 的左边还是 mid 的右边继续查找

其实这样的两句话可以把它归纳成













分为两种情况

mid 在下一轮搜索的区间里

此时下一轮搜索区间为 

[left..mid] 或者 [mid..right]

如果 mid 在左边区间

设置 right = mid

如果 mid 在右边区间

设置 left = mid



如果 mid 不在下一轮搜索的区间里

此时下一轮搜索区间为 

[left..mid - 1] 或者 [mid + 1..right]

如果 mid 的左边存在目标元素

此时设置 right = mid - 1

如果 mid 的右边存在目标元素

设置 left = mid















--可能存在目标元素的区间可以在搜索区间的左边
也可以在搜索区间的右边--







进而确定接下来在哪个区间继续查找

根据 mid 位置的值是不是可以排除
又可以分别分为两种情况 

一共就 4 种情况
这 4 种情况不需要记忆
我们通过几道例题
向大家演示如何思考使用二分查找算法解决的问题
在解决这些问题的过程中
我们会把细节和大家一点一点讲清楚



这一节我们和大家介绍的把区间分成两个部分的意思是
这个区间根据中间看到的元素的值
可以分为一定不存在目标元素的区间
和可能存在目标元素的区间


这一节我们要和大家分享的是「力扣」第 35 题
搜索插入位置

这道题给了我们一个有序数组和一个目标值
让我们返回插入元素的位置
其实就看题目的说明
我们不能够很准确地知道什么是插入元素的位置
我们看一下示例

示例 1
数组中存在目标值 5 
返回 5 的下标 2


示例 2
数组中不存在目标元素 2
第一个大于目标值 2 的元素是 3 
返回 3 的下标 1

结合示例 1 和示例 2 我们可以猜出
插入的位置意思是
第 1 个大于等于目标值的元素的位置

把这个位置以及这个位置以后的所有元素向后移动一位
目标值就可以放在这个位置上
得到一个更长的有序数组

理解题目要我们找的是什么是很重要
示例 3
目标值 7 比数组中最大的元素 6 还要大
7 应该放在数组的末尾的下一个位置
因此我们返回数组的长度

示例 4
目标值 0 比数组中最小的元素 1 还要小
0 应该放在数组的开头
因此返回 0

示例 5 和示例 4 是一样的

最后我们看到提示
数组的长度大于等于 1
并且数组中没有重复的元素



根据示例我们知道
需要找到大于等于目标值的第 1 个元素的位置

解题的思路依然是
根据看到的目标元素的值
决定下一轮应该往哪一个方向继续查找

我们边写代码边向大家展示二分查找算法的思路

```java
public class Solution {


    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] < target) {
            return len;
        }


        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target) {
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else if (nums[mid] == target) {
                return mid;
            } else {
                // nums[mid] > target
                // mid 有可能是 ，下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

虽然分析的时候分成了三种情况
但一般而言
我们把区间分成两个部分
这里 return mid; 和 right = mid; 这两种情况可以合并
就写成 right = mid;

这是因为只有分成 2 个区间的时候
写 while (left < right) 退出循环以后才有 
left 与 right 在同一个位置

我们就看搜索区间里只有 2 个元素的情况
这个时候 mid 在左边这个元素的位置 
left = mid + 1 对应的区间是 mid + 1 到 right
这个时候下一轮搜索区间成为了 1 个数
right = mid 对应的区间是 left 到 mid
这个时候下一轮搜索区间也成为了 1 个数

left 和 right 重合
退出循环
我们才敢说 left 或者 right 所在的位置就是插入元素的位置

```java
public class Solution {


    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] < target) {
            return len;
        }


        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target) {
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // mid 有可能是，下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

```java
public class Solution {


    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target) {
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // mid 有可能是，下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

















在上一节我们给大家留了一个问题
二分查找法为什么一定看在中间位置的元素的值呢
其它位置是不是可以

对于绝大多数情况来说
只要取在数组内部的某一个位置
都是可以的

在我们对数组里的值一无所知的情况下
猜中间位置在平均意义上是最好的

假如我们知道了一些额外的信息
例如我们知道了要找的数比较小
一开始就可以猜一个比较小的数
而不用很死板地一定要猜中间位置的元素

另外还要和大家说的一点是
由于整数除法在计算机中是下取整
因此在这个区间里只有偶数个元素的时候
取中间的那个位置取的是偏左边的那个元素
如果要娶的是偏右边的那个元素
我们需要在括号里加一

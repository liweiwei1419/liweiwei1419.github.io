## 「力扣」第 42 题：接雨水（单调栈）

我写的题解地址：https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/

> 给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
> 上面是由数组 `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
>
> 示例：
>
> ```
> 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出: 6
> ```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/trapping-rain-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

> 可以使用单调栈的原因：左边第 1 个比当前大的元素。

整体思路是：**分析每一个位置能够存水的高度，求和**。

每一个位置的宽度都是 1 ，因此每一个位置能够存水的高度可以枚举得到。

### 方法一：暴力枚举

这道题难就难在，暴力枚举的写法都不是很好看出来。





有点“中心扩散”的意思，每一个格子能够储存的水量，取决与以下 3 个变量：

1、当前位置左边（不包括当前位置）的最高高度 `leftMax`；

2、当前位置右边（不包括当前位置）的最高高度 `leftRight`；

（明白第 1 点和第 2 点非常关键）

3、当前位置的高度 `height[i]` ，这里 `i` 是数组的索引，从 0 开始。

根据木桶原理，当前能够存水的高度是 `leftMax` 和 `leftRight` 的最小值，但是不要忘记了，这两个最小值也一定要高过（不能等于）当前柱子的高度，才可以存水。

下面我们拿示例分析一下：

![image.png](https://pic.leetcode-cn.com/2074f3d183beb2972441728fa8aca3a271fb426ae6a51a4d6d09ff363775a63d-image.png)

就以 5 号索引能存水的高度为例：（以下分析有些步骤比较多余，只是为了让大家更好地理解解题思路）

+ 5 号索引能存水的高度取决于**它的左边的柱形的最高高度和它的右边的柱形的最高高度**，这里分别是 2 （索引位置 3）和 3（索引位置 7），取最小值 2；
+ 4 号索引和 6 号索引只要高度不超过 2 ，就不会影响到 5 号索引位置的存水高度（需要绘图示意）；
+ 如果 4 号索引 位置（或者它左边的任何一个位置）的高度超过了 2，5 号索引位置的存水高度就会变成 3，同理分析 6 号索引及其右边；
+ 如果 5 号索引位置自己有高度，只要不超过（不能等于）它两侧的最高高度，它都是可以存水的。

分析出以上几点，就不难写出以下的代码。

**参考代码 1**：

```Java []
public class Solution6 {

    // 暴力解法：中心扩散，找到两边最高的那个高度，还要减去自己的高度

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }
        int res = 0;
        for (int i = 1; i < len - 1; i++) {
            int leftMax = leftMax(i, height);
            int rightMax = rightMax(i, height, len);

            // 核心逻辑
            if (height[i] < Math.min(leftMax, rightMax)) {
                res += Math.min(leftMax, rightMax) - height[i];
            }
        }
        return res;
    }

    private int leftMax(int center, int[] height) {
        int res = 0;
        for (int i = center - 1; i >= 0; i--) {
            res = Math.max(res, height[i]);
        }
        return res;
    }

    private int rightMax(int center, int[] height, int n) {
        // 看看向右最多能走多远
        int res = 0;
        for (int i = center + 1; i < n; i++) {
            res = Math.max(res, height[i]);
        }
        return res;
    }

    public static void main(String[] args) {
        int[] height = new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        // int[] height = new int[]{2,0,2};
        Solution6 solution6 = new Solution6();
        int res = solution6.trap(height);
        System.out.println(res);
    }
}
```

**复杂度分析**：
+ 时间复杂度：$O(N^2)$，这里 $N$ 是高度数组的长度。
+ 空间复杂度：$O(1)$，算法中使用到的变量个数是常数个。

这里时间复杂度并不是太令人满意，思考的方向是能不能把 $O(N^2)$ 降到 $O(N)$，这里要用的思想很简单，就是“空间换时间”。

我们可以通过一次遍历，计算出已经扫过的高度的最大值，具体如下：

1、从左向右：记录当前遍历位置左侧的最高高度。

2、从右向左：记录当前遍历位置右侧的最高高度。

注意边界：最左边位置和最右边位置的最高高度是 0。

**参考代码 2**：

```Java []
public class Solution {

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }

        int[] leftMax = new int[len];
        int temp = height[0];
        for (int i = 1; i < len; i++) {
            temp = Math.max(temp, height[i - 1]);
            leftMax[i] = temp;
        }

        int[] rightMax = new int[len];
        temp = height[len - 1];
        for (int i = len - 2; i >= 0; i--) {
            temp = Math.max(temp, height[i + 1]);
            rightMax[i] = temp;
        }

        int res = 0;
        for (int i = 1; i < len - 1; i++) {
            int minHeight = Math.min(leftMax[i], rightMax[i]);
            // 核心逻辑
            if (height[i] < minHeight) {
                res += minHeight - height[i];
            }
        }
        return res;
    }
}
```

如果你觉得要比较一下当前高度和左右两侧的最小高度比较麻烦，可以在遍历的时候，就把当前高度计算进去。

**参考代码 3**：

```Java []
import java.util.Arrays;

public class Solution {

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }

        int[] leftMax = new int[len];
        int[] rightMax = new int[len];

        leftMax[0] = height[0];
        for (int i = 1; i < len; i++) {
            leftMax[i] = Math.max(height[i], leftMax[i - 1]);
        }

        rightMax[len - 1] = height[len - 1];
        for (int i = len - 2; i >= 0; i--) {
            rightMax[i] = Math.max(height[i], rightMax[i + 1]);
        }

        int res = 0;
        for (int i = 1; i < len - 1; i++) {
            res += (Math.min(leftMax[i], rightMax[i]) - height[i]);
        }
        return res;
    }

}
```

### 方法三：双指针

关键：如果左边低的话，左边的存水量就可以确定了。

Python 代码：

```python
from typing import List


class Solution:

    def trap(self, height: List[int]) -> int:
        size = len(height)
        if size < 3:
            return 0

        # 注意：这里与 height[i] 比较的含义
        left_max = [0] * size
        for i in range(1, size):
            left_max[i] = max(left_max[i - 1], height[i])

        right_max = [0] * size
        for i in range(size - 2, -1, -1):
            right_max[i] = max(right_max[i + 1], height[i])

        res = 0

        for i in range(size - 1):
            # 由遍历过程可以知道，left_max[i] 和 right_max[i] 都大于等于 height[i]
            res += min(left_max[i], right_max[i]) - height[i]
        return res
```

### 方法四：单调栈

画图，多写几遍帮助理解。

![image-20190923160822499](/Users/liwei/Library/Application Support/typora-user-images/image-20190923160822499.png)

![image-20191125105941682](/Users/liwei/Library/Application Support/typora-user-images/image-20191125105941682.png)

C++ 代码：

![image-20191125110133683](/Users/liwei/Library/Application Support/typora-user-images/image-20191125110133683.png)

Java 代码：这段代码比较折磨人，难懂

```java
import java.util.Stack;

/**
 * @author liwei
 * @date 2019/8/27 12:38 AM
 */
public class Solution5 {

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }
        int res = 0;
        // 单调栈里面存的是索引
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < len; i++) {
            // 最后一层的水平线，因为加法是一层一层加上去的
            int last = 0;
            while (!stack.empty() && height[stack.peek()] <= height[i]) {
                int top = stack.pop();
                // 挨得近的第 1 次一般是加 0
                res += (i - top - 1) * (height[top] - last);
                // top 变成目前最低水位
                last = height[top];
            }
            // 重点理解这句话的意思
            if (!stack.empty()) {
                res += (i - stack.peek() - 1) * (height[i] - last);
            }
            stack.push(i);
        }
        return res;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:

    def trap(self, height: List[int]) -> int:
        size = len(height)
        if size < 3:
            return 0
        res = 0
        stack = []
        for i in range(size):
            last = 0
            while stack and height[stack[-1]] <= height[i]:
                top = stack.pop()
                res += (i - top - 1) * (height[top] - last)
                last = height[top]
            if stack:
                res += (height[i] - last) * (i - stack[-1] - 1)
            stack.append(i)
        return res
```



![image-20191213115054967](/Users/liwei/Library/Application Support/typora-user-images/image-20191213115054967.png)



# LeetCode 第 0042 题：接雨水（困难）

我写的题解地址：https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/

> 给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
> 上面是由数组 `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
>
> 示例：
>
> ```
> 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出: 6
> ```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/trapping-rain-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 方法一：暴力解法

> 暴力解法：中心扩散，找到两边最高的那个高度，还要减去自己的高度

Java 代码：

```java
public class Solution {

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }
        int res = 0;
        for (int i = 1; i < len - 1; i++) {
            int leftMax = leftMax(i, height);
            int rightMax = rightMax(i, height, len);

            // 核心逻辑
            if (height[i] < Math.min(leftMax, rightMax)) {
                res += Math.min(leftMax, rightMax) - height[i];
            }
        }
        return res;
    }

    private int leftMax(int center, int[] height) {
        int res = 0;
        for (int i = center - 1; i >= 0; i--) {
            res = Math.max(res, height[i]);
        }
        return res;
    }

    private int rightMax(int center, int[] height, int n) {
        // 看看向右最多能走多远
        int res = 0;
        for (int i = center + 1; i < n; i++) {
            res = Math.max(res, height[i]);
        }
        return res;
    }
}
```



+ 时间复杂度：$O(N^2)$

+ 空间复杂度：$O(1)$





### 方法：双指针

![image-20191126094656821](/Users/liwei/Library/Application Support/typora-user-images/image-20191126094656821.png)

![image-20191126104552428](/Users/liwei/Library/Application Support/typora-user-images/image-20191126104552428.png)

Java 代码：注意：这里要用 `while (left <= right)`，因为当 `left == right` 成立的时候，还得计算一下。

```java
public class Solution {

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }

        int res = 0;

        int leftMax = height[0];
        int rightMax = height[len - 1];

        // 注意初值的选取，前面做了特判，因此这里有效
        // 头和尾都不存雨水
        int left = 1;
        int right = len - 2;

        while (left <= right) {
            int minVal = Math.min(leftMax, rightMax);
            if (minVal == leftMax) {
                if (minVal > height[left]) {
                    res += minVal - height[left];
                }
                leftMax = Math.max(leftMax, height[left]);
                left++;
            } else {
                if (minVal > height[right]) {
                    res += minVal - height[right];
                }
                rightMax = Math.max(rightMax, height[right]);
                right--;
            }
        }
        return res;
    }
}
```

Java 代码：

```java
public class Solution {

    public int trap(int[] height) {
        int len = height.length;
        // 特判
        if (len < 3) {
            return 0;
        }
        
        int res = 0;

        int leftMax = 0;
        int rightMax = 0;
        // 注意初值的选取
        int left = 0;
        int right = len - 1;

        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);

            if (height[left] < height[right]) {
                res += leftMax - height[left];
                left++;
            } else {
                res += rightMax - height[right];
                right--;
            }
        }
        return res;
    }
}
```





### 方法：单调栈









![image-20191125075110217](/Users/liwei/Library/Application Support/typora-user-images/image-20191125075110217.png)

![image-20191126112820746](/Users/liwei/Library/Application Support/typora-user-images/image-20191126112820746.png)







### 方法：

![image-20191126113808551](/Users/liwei/Library/Application Support/typora-user-images/image-20191126113808551.png)

![image-20191126114011183](/Users/liwei/Library/Application Support/typora-user-images/image-20191126114011183.png)

![image-20191126114028581](/Users/liwei/Library/Application Support/typora-user-images/image-20191126114028581.png)
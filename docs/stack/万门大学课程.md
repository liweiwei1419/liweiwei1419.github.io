





![image-20191210124655858](https://tva1.sinaimg.cn/large/007S8ZIlly1gg3x7ljv29j31hc0tstnp.jpg)

### 最小栈



```python
import sys
from ArrayStack import ArrayStack

class MinStack(ArrayStack):
    
    def __init__(self):
        super(MinStack, self).__init__()
    
    def push(self, v):       
        newMin = min(v, self.min())
        super(MinStack, self).push(NodeWithMin(v, newMin))
    
    def min(self):
        if (super(MinStack, self).is_empty()):
            return sys.maxsize
        else:
            return super(MinStack, self).top()._min;
    

class NodeWithMin:
    def __init__(self, v, min):
        self._value = v
        self._min = min  
```

空间上更小的做法。

**有重复元素的时候，必须插入。**

```python
class MinStack2(ArrayStack):
    
    def __init__(self):
        super(MinStack2, self).__init__()
        self.min_stack = ArrayStack()
        
    def push(self, value):
        if value <= self.min():
            self.min_stack.push(value)
        super(MinStack2, self).push(value)
        return value
          
    def min(self):
        if self.min_stack.is_empty():
            return sys.maxsize
        else:
            return self.min_stack.top()    
      
    def pop(self):
        value = super(MinStack2, self).pop()
        if value == self.min():
            self.min_stack.pop()
        return value
```

# Two Stack with One Array

```python
class twoStacks:
     
    def __init__(self, n): 
        self.size = n
        self.arr = [None] * n
        self.top1 = -1
        self.top2 = self.size
         
    # Method to push an element x to stack1
    def push1(self, x):
         
        # There is at least one empty space for new element
        if self.top1 < self.top2 - 1 :
            self.top1 = self.top1 + 1
            self.arr[self.top1] = x
 
        else:
            print("Stack Overflow ")
 
    # Method to push an element x to stack2
    def push2(self, x):
 
        # There is at least one empty space for new element
        if self.top1 < self.top2 - 1:
            self.top2 = self.top2 - 1
            self.arr[self.top2] = x
 
        else :
           print("Stack Overflow ")
 
    # Method to pop an element from first stack
    def pop1(self):
        if self.top1 >= 0:
            x = self.arr[self.top1]
            self.top1 = self.top1 -1
            return x
        else:
            print("Stack Underflow ")
 
    # Method to pop an element from second stack
    def pop2(self):
        if self.top2 < self.size:
            x = self.arr[self.top2]
            self.top2 = self.top2 + 1
            return x
        else:
            print("Stack Underflow ")

```

### Three Stack with One Array

1、数组分块；

2、链表、双向链表（利用链表的动态结构）

![image-20191210131311877](/Users/liwei/Library/Application Support/typora-user-images/image-20191210131311877.png)

![image-20191210131327554](/Users/liwei/Library/Application Support/typora-user-images/image-20191210131327554.png)



Stack Sorting

```python
def sortStack(s):
    r = ArrayStack()
    
    while not s.is_empty():
        tmp = s.pop()
        
        while not r.is_empty() and r.top() > tmp:
            s.push(r.pop())
            
        r.push(tmp)
    
    return r
```





![image-20191210131739556](/Users/liwei/Library/Application Support/typora-user-images/image-20191210131739556.png)



### 反转字符串

Reverse a String 

```python
def reverse(s):
    lst = []
    for i in s:
        lst.append(i)
    result = []
    while len(lst) != 0:
        result.append(lst.pop())
    return ''.join(result)
```

### Palindrome

```python
def isPalindrome(s):
    r = reverse(s)
    return r == s
```

### Valid Parentheses

```python
def isValid(s):
    stack = []
    for c in s:
        if (c == '(' or c == '[' or c == '{'):
            stack.append(c)
        else:
            if len(stack)==0:
                return False
            if (   (c == ')' and stack[-1] == '(')
                or (c == ']' and stack[-1] == '[')
                or (c == '}' and stack[-1] == '{')):
                stack.pop()
            else:
                return False
    return len(stack)==0
```

###  Decode String

```python
def decodeString(s):
    stack = []
    stack.append(["", 1])
    num = ""
    for ch in s:
        if ch.isdigit():
            num += ch
        elif ch == '[':
            stack.append(["", int(num)])
            num = ""
        elif ch == ']':
            st, k = stack.pop()
            stack[-1][0] += st*k
        else:
            stack[-1][0] += ch
    return stack[0][0]
```



### Basketball Game

> ### Ex.6 
>
> You're now a baseball game point recorder.
>
> Given a list of strings, each string can be one of the 4 following types:
>
> - Integer (one round's score): Directly represents the number of points you get in this round.
> - "+" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.
> - "D" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.
> - "C" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.
>
> Each round's operation is permanent and could have an impact on the round before and the round after.
>
> You need to return the sum of the points you could get in all the rounds.
>
> Input: ["5","2","C","D","+"] 
>
> Output: 30 
>
> - Round 1: You could get 5 points. The sum is: 5. 
>
> - Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5. 
>
> - Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. 
>
> - Round 4: You could get 5 + 10 = 15 points. 
>
> - The sum is: 30.

```python
def calPoints(ops):
    stack = []
    for op in ops:
        if op == '+':
            stack.append(stack[-1] + stack[-2])
        elif op == 'C':
            stack.pop()
        elif op == 'D':
            stack.append(2 * stack[-1])
        else:
            stack.append(int(op))

    return sum(stack)
```



### Ex.7 Asteroid Collision





> We are given an array asteroids of integers representing asteroids in a row.
>
> For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
>
> Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.
>
> Example 1:
>
> - Input: asteroids = [5, 10, -5] 
> - Output: [5, 10] 
> - Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide. 
>
> Example 2:
>
> - Input: asteroids = [10, 2, -5] 
> - Output: [10] 
> - Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10. 
>
> Example 3:
>
> - Input: asteroids = [-2, -1, 1, 2]
> - Output: [-2, -1, 1, 2]
> - Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right.
> - Asteroids moving the same direction never meet, so no asteroids will meet each other.



Python 代码：

```python
def asteroidCollision(asteroids):
    ans = []
    for new in asteroids:
        while ans and new < 0 < ans[-1]:
            if ans[-1] < -new:
                ans.pop()
                continue
            elif ans[-1] == -new:
                ans.pop()
            break
        else:
            ans.append(new)
    return ans
```

说明：居然可以在 `while` 后面加上 `else`。






























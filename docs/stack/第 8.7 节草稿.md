


### 1、使用栈实现队列



+ 画图，使用两个 `stack` 实现一个 `queue`；
+ `push` 的时候一直在 `stack1` 里，只要涉及到 `peek` 和出队操作，都在 `stack2` 里；
+ 注意 1：`stack2` 是空的时候，才能从 `stack1` 里都拿出来；
+ 在 `stack2` 非空的时候，不能这么做。



Python 代码：

+ 均摊复杂度分析。

```python
class QueueWithTwoStacks:
    
    def __init__(self):
        self.insertStack = []
        self.popStack = []

    def enqueue(self, e):
        self.insertStack.append(e)
        return e
    
    def dequeue(self):
        if len(self.insertStack)==0 and len(self.popStack)==0:
            return None
        
        if len(self.popStack)==0:
            while len(self.insertStack)!=0:
                self.popStack.append(self.insertStack.pop())
        
        return self.popStack.pop()
```

### 2、使用队列实现栈

画图

使用一个队列就可以了，每一步都把 `size - 1` 个元素放在队列的后面；



时间复杂度：$O(N)$。

Python 代码：

```python
class StackWithQueue:
    
    def __init__(self):
        self.queue = LinkedList()

    # Push element x onto stack.
    def push(self, x):
        self.queue.add_last(x)

    # Removes the element on top of the stack.
    def pop(self):
        size = self.queue.size()
        for i in range(1, size):
            self.queue.add_last(self.queue.remove_first())
        self.queue.remove_first()
        
    def top(self):
        size = self.queue.size()
        for i in range(1, size):
            self.queue.add_last(self.queue.remove_first())
        result = self.queue.remove_first()
        self.queue.add_last(result)
        return result

```

### 



# 剑指Offer.5.用两个栈实现队列

https://www.bilibili.com/video/BV1jJ411C7V2?from=search&seid=13340100407984068805

![image-20200826111953843](/Users/liwei/Library/Application Support/typora-user-images/image-20200826111953843.png)

把这一点说清楚：

![image-20200826112016147](/Users/liwei/Library/Application Support/typora-user-images/image-20200826112016147.png)

## 例 1：「力扣」第 84 题：柱状图中最大的矩形

遇到一时半会想不明白的问题，通常先考虑最直接的办法：暴力解法。

### 方法一：暴力解法

这道问题的暴力解法比「接雨水」那道题要好想得多。矩形的面积由底边长度和高度共同决定，我们可以使用控制变量法，这里我们固定高度是比较好做的，底边的长度可以通过「中心扩散」的方式得到。

我们可以枚举高度，即依次遍历高度数组，然后求出以当前高度为矩形的高度，宽最多是多少。那么我们就需要：

+ 左边看一下，最多能延伸多长，找到严格小于它的第 $1$ 个元素的位置；
+ 右边看一下，最多能延伸多长；找到严格小于它的第 $1$ 个元素的位置；

即以当前位置为中心向两边扩散，看最多能扩散多远。对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值即可。

**参考代码 1**：

```Java []
public class Solution {

    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        // 特判
        if (len == 0) {
            return 0;
        }

        int res = 0;
        for (int i = 0; i < len; i++) {
            int left = i;
            int right = i;
            
            // 找左边第 1 个严格小于 heights[i] 的下标
            while (left > 0 && heights[left - 1] >= heights[i]) {
                left--;
            }
            // 找右边第 1 个严格小于 heights[i] 的下标
            while (right < len - 1 && heights[right + 1] >= heights[i]) {
                right++;
            }

            // System.out.println("左：" + left + "，右："+ right + "，高："+ heights[i]);
            int width = right - left + 1;
            res = Math.max(res, width * heights[i]);
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N^2)$，这里 $N$ 是输入数组的长度。在每一次中心扩散的时候，最坏情况下要遍历完整个数组，因此整体的时间复杂度是 $O(N^2)$；
+ 空间复杂度：$O(1)$。

暴力解法的缺点是：在每一次遍历的过程中没有记住一些信息。下面给出的优化解法基于这样一个事实：在遍历柱形高度的时候，如果遇到的柱形高度一直是严格上升的（这个特殊的例子特别关键），此时我们还无法确定任何一个柱形能得到的最大矩形是什么。

![image-20191213144038746](https://tva1.sinaimg.cn/large/006tNbRwly1g9yp4ae5anj31ev0u0jum.jpg)

因为它的高度所确定的最大矩形可以确定，因此，我们就把它拿出（这一步操作已经显示出我们利用的栈的特性了：后进先出），它的宽度是什么呢？是它之前那个柱形的位置，与马上要进来的这个柱形的位置之间的距离。

栈顶元素弹出以后（请注意，我这里虽然是把它移除了栈，但是在图形上我没有把它真正去掉，只是做了一个虚化，这是为了方便我们观察），我们接着比较新栈顶和马上要进来的这个柱形的高度，发现还是比新栈顶的高度严格小，那么新栈顶的高度所确定的最大矩形也可以确定。

![image-20191213144913849](https://tva1.sinaimg.cn/large/006tNbRwly1g9yp4bv9eej31900ps76l.jpg)

它的高度自然是这个柱形的高度，宽度是它之前的那个柱形的位置和马上要进来的这个柱形的位置之间的距离。

请注意：计算黄色区域能确定的矩形的时候，要假想原来红色柱形还在。

它不可以向左延伸扩展，因为左边严格小于它。但它可以向右延伸扩展，只不过扩展的步数，我们一下子计算出来了。

通过这样的方式，**一个柱子一个柱子** 去计算它们的高度所能确定的最大矩形，与暴力解法的不同在于 **计算顺序不同**。

+ 不是按照遍历的顺序一个一个柱子取计算，单调栈计算的顺序取决于这个柱子出栈的顺序；
+ 比暴力解法快的地方在于：在左边能够扩展的步数与右边能够扩展的步数可以以 $O(1)$ 的方式计算出来；
+ 从计算宽度这件事情，我们知道，需要记录的是柱子的位置，即下标，通过下标获得高度，进而比较元素大小，这是比较常见的做法，即 **单调栈中一般而言存下标**。


**参考代码 2**：（原始代码）

```Java []

```


**参考代码 3**：（加了哨兵元素的代码）

```Java []

```


还要解决两个问题（这是在调试的过程中会遇到的）：

+ 遍历完成以后，栈里还有元素怎么办？

使用哨兵技巧，在原始数组里添加一个元素 $0$，遍历到最后一个元素的时候，它肯定会让所有原来的元素出栈，而它自己没有必要进栈。

+ 如果左边不能扩展，在边界怎么办，其实要么分类讨论，要么也用一个哨兵，我这里两种方式都展示一下。






多源 BFS[ 1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)


快排：

C++ 代码：

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    void quickSort(vector<int> &a, int left, int right) {
        if (left >= right) {
            return;
        }

        // 最好做随机化，否则遇到极端测试用例（顺序数组或者倒序数组），复杂度变成 O(N^2)
        
        // 从 left + 1 这个下标开始看，因为 left 这个下标已经看过了
        int l = left + 1;
        int r = right;
        int pivot = a[left];

        // 这里需要的逻辑关系是 l <= r 的时候继续判断
        // 因此 l != r 是不准确的，因为当 r < l 的时候应该退出循环
        while (true) {
            // 永远记得：访问下标的时候，先做下标是否越界判断
            // 因此把 l < r 提到前面，并且要加 = 号
            // 因为 l == r 的时候，l == r 这个位置还有可能没有被程序看到
            while (l <= r && a[r] >= pivot) {
                r--;
            }
            // 左边找大的
            while (l <= r && a[l] <= pivot) {
                l++;
            }

            // 这个时候如果相遇 l == r 这个位置已经被程序看到，可以退出循环了
            if (l >= r){
                break;
            }

            int t = a[l];
            a[l] = a[r];
            a[r] = t;

            // 交换完以后，[left, l] <= pivot，[r, right] >= pivot
            // l 和 r 不能不动，都需要再向中间走一步以看到新的元素
            l++;
            r--;
        }

        // 将基准数归位
        // 这个时候 [left + 1 , r] 所有的元素都 <= pivot
        // 这个时候 [l , right] 所有的元素都 >= pivot
        // 交换 l 是不合适的，因为下标 l 的数值可能大于 pivot，为此把 l 改成 r

        a[left] = a[r];
        a[r] = pivot;

        // 递归排序左右子序列
        // 此时 r 位置排定
        // 未排定的部分是 [left, r - 1] 与 [r + 1, right]
        quickSort(a, left, r - 1);
        quickSort(a, r + 1, right);

    }

    vector<int> sortArray(vector<int> &nums) {
        int size = nums.size();
        quickSort(nums, 0, size - 1);
        return nums;
    }
};
```



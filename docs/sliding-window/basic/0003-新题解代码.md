+ [题解](https://leetcode-cn.com/problems/wtcaE1/solution/hua-dong-chuang-kou-ru-men-wen-ti-java-b-x4cx/)


![输入图片说明](https://images.gitee.com/uploads/images/2021/0904/000737_31892656_426516.png "屏幕截图.png")

```java
public class Solution {

    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        if (len < 2) {
            return len;
        }

        char[] charArray = s.toCharArray();
        int left = 0;
        int right = 0;
        int[] freq = new int[128];
        
        int res = 1;
        while (right < len){
            freq[charArray[right]]++;
            // 为什么这里是 while 请见上图
            while (freq[charArray[right]] == 2){
                freq[charArray[left]]--;
                left++;
            }
            res = Math.max(res, right - left + 1);
            right++;
        }
        return res;
    }
}
```


---

方法二：哈希表记录字符上一次出现的下标




```Java []
import java.util.HashMap;
import java.util.Map;

public class Solution {

    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        }
        int pointer = 0;
        int maxLen = 1;
        Map<Character, Integer> map = new HashMap<>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (map.containsKey(chars[i])) {
                if (map.get(chars[i]) >= pointer) {
                    // 更新 pointer
                    pointer = map.get(chars[i]) + 1;
                }
            }
            maxLen = Integer.max(maxLen, i - pointer + 1);
            map.put(chars[i], i);
        }
        return maxLen;
    }
}
```
```Python []
class Solution:
    def lengthOfLongestSubstring(self, s):
        # 特判
        l = len(s)
        if l < 2:
            return l
        # 隔板法
        # key:字符，val 出现的索引
        map = dict()
        point = 0
        res = 1
        for i in range(l):
            # 关键1：map[s[i]] >= point，等于是可以的
            if s[i] in map and map[s[i]] >= point:
                # 先把隔板向后移动一位
                point = map[s[i]] + 1
            # 然后记录最长不重复子串的长度
            res = max(res, i - point + 1)
            # 关键2：无论如何都更新位置
            map[s[i]] = i
        return res
```


```java
import java.util.Arrays;

public class Solution {

    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        if (len < 2) {
            return len;
        }

        // 记录了每个元素在数组中的下标
        int[] position = new int[128];
        Arrays.fill(position, -1);

        char[] charArray = s.toCharArray();
        int res = 1;
        int left = 0;
        for (int right = 0; right < len; right++) {
            // 如果已经出现过，左边界应该更新到上一次相同字符的下一个位置
            if (position[charArray[right]] != -1) {
                left = Math.max(left, position[charArray[right]] + 1);
            }
            // 循环不变量的定义
            res = Math.max(res, right - left + 1);
            position[charArray[right]] = right;
        }
        return res;
    }
}
```






区别在于如何判断滑动窗口内出现了重复的字符。




判断一个元素有没有出现过，使用哈希表是最自然的想法。

以下面的例子进行说明：

| $d$ | $a$ | $b$ | $a$ | $d$ | $c$ |
| ---- | ---- | ---- | ---- | ---- | ---- |
| $0$ | $1$    | $2$   | $3$    | $4$    | $5$   |

判断连续区间内是否出现重复元素，可以使用 `set`，又要存储位置，所以使用 `dict`。到索引为 $3$ 的时候，出现重复，我们可以在 $a$ 的**下一个位置**插一个“小木板”，表示从这个“小木板”到当前位置没有重复。如果出现重复的索引在“小木板”之前，例如到索引 $4$ 的时候，此时“小木板”在索引 $2$ 处，两个 $d$ 之间已经有了两个 $a$ ，可以无视这种情况。

需要注意的一点是：只有重复出现的位置大于等于隔板位置的时候，才要更新，更新的位置是当前位置 + 1。即只要出现重复，隔板就向后移动一位，然后每一轮都计算当前与隔板的距离。


「力扣」第 3 题：刘宇波老师的代码



Java 代码：

```Java
public class Solution {

    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        // 特判
        if (len < 2) {
            return len;
        }
        int[] counter = new int[128];
        int res = 1;

        int left = 0;
        // 滑动窗口的逻辑是尝试向右移动一位，因此，初始值是 -1
        int right = -1;

        // 认为左边界更重要，有重复的子串，我们记录左边，舍弃右边，因此左边界如果越界了，算法停止
        while (left < len) {
            // right + 1 表示最多到 len - 1
            // counter[s.charAt(right + 1)] == 0 表示在 [left, right] 这个区间里没有出现
            if (right + 1 < len && counter[s.charAt(right + 1)] == 0) {
                // 右边第 1 个字母加入频率数组，频数 + 1
                counter[s.charAt(right + 1)]++;
                right++;
            } else {
                // 如果下一个字符已经越界了，或者右边第 1 个字母是频率数组是曾经出现过的
                // 把左边从频数数组中挪掉，频数减 1
                counter[s.charAt(left)]--;
                left++;
            }
            // 经过上面的分支，窗口 [left, right] 内一定没有重复元素，故记录最大值
            res = Math.max(res, right - left + 1);
        }
        return res;
    }
}
```

Python 代码：

```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        size = len(s)
        # 特判
        if size < 2:
            return size

        left = 0
        # 滑动窗口的逻辑是尝试向右移动一位，因此，初始值是 -1
        right = -1
        # 设置成 128 与测试用例有关
        counter = [0 for _ in range(128)]
        # 因为自己一定是不重复的子串，在字符串非空的情况下，至少结果为 1
        res = 1
        # 认为左边界更重要，有重复的子串，我们记录左边，舍弃右边，因此左边界如果越界了，算法停止
        while left < size:
            # right + 1 表示最多到 len - 1
            # counter[s.charAt(right + 1)] == 0 表示在 [left, right] 这个区间里没有出现
            if right + 1 < size and counter[ord(s[right + 1])] == 0:
                # 表示没有重复元素，right 可以加 1
                counter[ord(s[right + 1])] += 1
                right += 1
            else:
                # 如果下一个字符已经越界了，或者右边第 1 个字母是频率数组是曾经出现过的
                # 把左边从频数数组中挪掉，频数减 1
                counter[ord(s[left])] -= 1
                left += 1
            # 经过上面的分支，窗口 [left, right] 内一定没有重复元素，故记录最大值
            res = max(res, right - left + 1)
        return res
```
# 「力扣」第 30 题：串联所有单词的子串（困难）

+ 参考资料：[30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

给定一个字符串 **s** 和一些 **长度相同** 的单词 **words。**找出 **s** 中恰好可以由 **words** 中所有单词 **串联** 形成的子串的起始位置。

注意子串要与 **words** 中的单词完全匹配，中间不能有其他字符，但不需要考虑 **words** 中单词串联的顺序。

**示例 2：**

```
输入：

  s = "wordgoodgoodgoodbestword",

  words = ["word","good","best","word"]

输出：[]
```

## 解题思路

根据示例 2 单词出现的次数也需要记录。

## 方法：哈希表 + 固定滑动窗口

关键词：**所有单词的长度都一样，**s consists of lower-case English letters。

> 这道题的解法有点暴力。

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Solution {

    public List<Integer> findSubstring(String s, String[] words) {
        int sLen = s.length();
        int wordLen = words[0].length();

        List<Integer> res = new ArrayList<>();
        if (sLen == 0 || wordLen == 0) {
            return res;
        }

        // 第 1 步：将每个单词以及出现的次数记录到 freq 中
        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        // 固定的滑动窗口长度的问题
        int windowSize = words.length * wordLen;
        for (int i = 0; i < sLen; i++) {
            // 这种技巧避免讨论边界情况
            if (i + windowSize > sLen) {
                break;
            }

            // 枚举截取的字符串
            String temp = s.substring(i, i + windowSize);
            // 复制一次（不理解为什么要这么做）
            Map<String, Integer> copy = new HashMap<>(freq);
            // 又要做一次截取
            for (int j = 0; j < windowSize; j += wordLen) {
                String key = temp.substring(j, j + wordLen);
                if (copy.containsKey(key)) {
                    // 包含了就要减去
                    copy.put(key, copy.get(key) - 1);
                    // 减以后正好没有了，就从 hashMap 里移除了
                    if (copy.get(key) == 0) {
                        copy.remove(key);
                    }
                } else {
                    break;
                }
            }

            // 有点暴力匹配的意思
            if (copy.size() == 0) {
                res.add(i);
            }
        }
        return res;
    }
}
```

焦心宇的解法

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Solution {

    public List<Integer> findSubstring(String s, String[] words) {

        // 字符串数组长度
        int wordsLen = words.length;
        List<Integer> res = new ArrayList<>();
        // 特判
        if (wordsLen == 0) {
            return res;
        }
        // 存取每个字符串出现的次数
        Map<String, Integer> freq = new HashMap<>();
        for (String ws : words) {
            freq.put(ws, freq.getOrDefault(ws, 0) + 1);
        }

        // 字符串数组里面的每个字符串长度
        int wordLen = words[0].length();
        // 字符串s总长度
        int sLen = s.length();

        // 难点：依次判断每个子串是否符合
        for (int i = 0; i < sLen - (wordLen * wordsLen) + 1; i++) {

            // 记录每个子串里面与之对应的 words 数组中字符串出现的次数
            Map<String, Integer> wordmap = new HashMap<>();
            // 字符串数组里面符合的字符串个数

            int count = 0;
            while (count < wordsLen) {
                // 截取下一个新的 str 字符串（巨难理解）
                String str = s.substring(i + (count * wordLen), i + (count + 1) * wordLen);
                // 如果子串里面存在这个 key 则放入到 wordmap 中
                if (freq.containsKey(str)) {
                    wordmap.put(str, wordmap.getOrDefault(str, 0) + 1);
                } else {
                    // 如果该字符串 str 都不在 words 中出现 说明子串不符合
                    break;
                }
                // 如果子串里面该 str 字符串出现的次数严格大于 words 里面 str 字符串的次数 说明不符合要求
                if (wordmap.get(str) > freq.get(str)) {
                    break;
                }
                // 每匹配完 words 里面的一个字符串之后将计数加一
                count++;
            }

            // 如果符合就将子串 i 的下标结果放入到结果集合中
            // 说明该子串符合要求 则放入他的起始下标
            if (count == wordsLen) {
                res.add(i);
            }
        }
        return res;
    }
}
```

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Solution {

    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<>();
        if (s == null || s.length() == 0 || words == null || words.length == 0) {
            return res;
        }


        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        int wordSize = words.length;
        int wordLen = words[0].length();
        // 一个单词的长度，这一点非常关键，wordLen 的长度有限
        for (int i = 0; i < wordLen; i++) {
            int left = i;
            int right = i;
            int count = 0;
            Map<String, Integer> windowFreq = new HashMap<>();
            while (right + wordLen <= s.length()) {
                String rightWord = s.substring(right, right + wordLen);
                windowFreq.put(rightWord, windowFreq.getOrDefault(rightWord, 0) + 1);
                right += wordLen;
                count++;

                // 这条很关键
                while (windowFreq.getOrDefault(rightWord, 0) > freq.getOrDefault(rightWord, 0)) {
                    String leftWord = s.substring(left, left + wordLen);
                    count--;
                    windowFreq.put(leftWord, windowFreq.get(leftWord) - 1);
                    left += wordLen;
                }

                // 这一点非常像第 76 题
                if (count == wordSize) {
                    res.add(left);
                }
            }
        }
        return res;
    }
}
```

#### 
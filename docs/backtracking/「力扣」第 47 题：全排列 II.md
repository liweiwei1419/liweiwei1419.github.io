

想明白了上面这个思路，其实可以使用一个 `pre` 变量，记录上一次搜索的起点，只要起点一样就跳过这个分支，这种思路更加直接。感谢 [@july](/u/july-13/) 提供的思路。

**参考代码 2**：

```
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;

public class Solution {

    public List<List<Integer>> permuteUnique(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        // 修改 1：排序（升序或者降序都可以），为了剪枝方便
        Arrays.sort(nums);

        boolean[] used = new boolean[len];
        // 使用 Deque 是 Java 官方 Stack 类的建议
        Deque<Integer> path = new ArrayDeque<>(len);
        dfs(nums, len, 0, used, path, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth, boolean[] used, Deque<Integer> path, List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        // 这个 pre 值必须是整个数组中没有出现的，因此下边界 - 1 或者是上边界 + 1，均可
        // 如果数组中有 int 类型的最大值或者最小值，可能会存在问题，好在这题里没有极端数据
        int pre = nums[0] - 1;
        for (int i = 0; i < len; ++i) {
            if (!used[i] && pre != nums[i]) {
                path.addLast(nums[i]);
                used[i] = true;

                dfs(nums, len, depth + 1, used, path, res);

                used[i] = false;
                path.removeLast();

                pre = nums[i];
            }
        }
    }
}

```

b**补充说明**b**补充说明**：

下面这个代码片段：

```java
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    continue;
}
```

中的 `used[i - 1]` 加不加 `!` ，提交到力扣的代码测评系统中都是可以通过的，下面我解释一下原因。

1、不加 `!` ，表示如果之前相同的元素使用过，说明以这个相同元素**作为当前位置**的排列已经得到，因此如果这个分支继续走，一定和之前搜索过的结果重复，所以剪枝；

说明：这是从同一层的角度考虑的。

2、加 `!` 表示，如果之前相同的元素还未使用过，说明以这个相同元素还会出现在当前分支即将要搜索的候选区间里，也一定和之前搜索过的结果重复，所以剪枝。

说明：这是从同一父亲结点的角度考虑的。

因此，它们虽然是不同的编码方式，但是语义都是一样的，那就是：**发现已经排定的数相同（父亲结点一样，是兄弟结点），和接下来搜索将要纳入排列的候选集合相同，因此得到的分支也一定一样，因此需要“剪枝”**。

（我写的有一些文绉绉的，建议大家自己在纸上画图理解“搜索”和“剪枝”的过程。）
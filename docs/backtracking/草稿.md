

# 「回溯算法」

回溯算法：

+ 如果做一件事情有不同的做法，而每一种做法是分阶段进行的，我们要得到所有的做法，就很适合使用回溯算法；
+ 在一个**树形问题**上**尝试**搜索所有可能的解；（树形问题，递归来做，尝试搜索，暴力枚举思想，同学们不要对暴力和枚举有偏见，计算机擅长做，在一些场景下，我们就是暴力枚举去做它）；
+ 代码的执行流程是一次深度优先遍历；
+ 在同一个阶段，尝试每一种解法的时候，所有的状态需一致，因此在递归方法返回的时候，就需要进行状态重置，这个过程叫回溯
+ 复杂度很高，因此，需要剪枝

回溯算法的人生哲学：月光宝盒，回到过去，去尝试下一步新的可能性。

面试官有的时候就像是你的女朋友，有些时候是你们共同面对的问题，他可能就是抛出一个开放的问题，或者说给你挖个坑。你可以问他或者质疑他，或者和他一起讨论。



---

「力扣」第 131 题：分割回文串

```python
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        def backtrack(s,start,length,dp,path,res):
            if start == length:
                # 当字符串走到头了,就将path内部全部加入到res中
                res.append(path[:])
                return
            else:
                for i in range(start,length):
                    if not dp[start][i]:
                        continue
                    path.append(s[start:i+1])
                    backtrack(s,i+1,length,dp,path,res)
                    path.pop()
        length = len(s)
        dp = [[0] * length] * length
        res = []
        if length == 0:
            return res
        for right in range(length):
            for left in range(right+1):
                if s[left] == s[right] and (right - left <= 2 or dp[left+1][right-1]):
                    dp[left][right] = 1
        backtrack(s,0,length,dp,[],res)
        return res
```





如果完成一件事情有很多种方法，并且每一种方法分成若干步骤，那多半就可以使用“回溯”算法完成。

“回溯”算法的基本思想是“尝试搜索”，一条路如果走不通（不能得到想要的结果），就回到上一个“路口”，尝试走另一条路。

因此，“回溯”算法的时间复杂度一般不低。如果能提前分析出，走这一条路并不能得到想要的结果，可以跳过这个分支，这一步操作叫“剪枝”。

做“回溯”算法问题的基本套路是：

1、使用题目中给出的示例，画树形结构图，以便分析出递归结构；

一般来说，树形图不用画完，就能够分析出递归结构和解题思路。

2、分析一个结点可以产生枝叶的条件、递归到哪里终止、是否可以剪枝、符合题意的结果在什么地方出现（可能在叶子结点，也可能在中间的结点）；

3、完成以上两步以后，就要编写代码实现上述分析的过程，使用代码在画出的树形结构上搜索符合题意的结果。

在树形结构上搜索结果集，使用的方法是执行一次“深度优先遍历”。在遍历的过程中，可能需要使用“状态变量”。

> **注意：这道题的状态变量是字符串，每一次拼接都生成一个新的字符串，因此没有回溯的过程，无须状态重置。请各位在代码中体会这个细节。**

----






@忘了二进制吧 棒棒哒！

回溯法这个名称讲全了其实是“回溯搜索”，特指使用深度优先遍历到状态空间里搜索。您这里每一次尝试都是创建新的 `road` 变量去尝试得到结果集，因此不需要“回溯”，最后直接 `res.append(road)` 就可以了。

全局使用一个 `road` 变量的话，就得“回溯”，即状态重置、恢复现场。

剪枝的操作在您的代码中没有显式体现，而是暗含在 `if sum_ == target:` 和 `elif sum_ < target:` 以后的 `else` 部分。

本质上，我们写出来的算法都是深度优先遍历在树形递归结构的状态空间里搜索可行解。





搜索不一定等于递归。



回溯强调的是恢复现场，特指压缩了空间的回溯算法。



![image-20191125192456785](/Users/liwei/Library/Application Support/typora-user-images/image-20191125192456785.png)



![image-20191125184108286](/Users/liwei/Library/Application Support/typora-user-images/image-20191125184108286.png)



![image-20191127192204797](/Users/liwei/Library/Application Support/typora-user-images/image-20191127192204797.png)



![img](https://i0.hdslb.com/bfs/album/c5940a095a44b9b962bb4d02e01d9f5860a6b699.jpg@1036w_1e_1c.jpg)





## 递归回溯中的一些套路

https://mp.weixin.qq.com/s/SzR593rG-L_VPjXDLdOr-Q



## 回溯算法详解（修订版）

https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ





### 总结

回溯算法是在一个树形问题上做一次深度优先遍历，用于搜索所有可能的解。

它能解决的问题的特点是：1、有若干个解；2、每一个解的求解过程可以分为若干个步骤（阶段），得到所有解的过程是一个不断尝试的过程。

### 为什么使用深度优先遍历？

+ 首先是正确性，只有遍历状态空间，才能得到**所有**符合条件的解；

+ 在深度优先遍历的时候，**不同状态之间的切换很容易**，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局就使用一份状态变量完成搜索；

+ 如果每一个状态都去创建新的变量，时间复杂度是 $O(N)$，并且也有空间的消耗。

+ 搜索问题的状态空间一般很大，在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重；

+ 就本题而言，只需要叶子结点的那个状态，在叶子结点执行拷贝，时间复杂度是 $O(N)$。路径变量在深度优先遍历的时候，结点之间的转换只需要 $O(1)$。

### 为什么不使用广度优先遍历？

+ 如果使用广度优先遍历，**从浅层转到深层（请读者想象广搜的过程），状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，上面已经分析过了，从性能来说是不划算的**；

+ 从编写代码的角度上来说，如果使用广度优先遍历就得使用队列，然后编写结点类。而使用深度优先遍历，我们可以直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。于是我们不用编写结点类，不必手动编写栈完成深度优先遍历。

这道题用广度优先遍历写是完全可以的，我尝试过，代码写出来非常不美观。感兴趣的朋友也可以尝试写一下，尝试写广搜的目的是更好地体会**为什么“深搜”能成为强大的“回溯搜索算法”，而广搜不是。**



如果大家玩得转“剪枝”，或许在开篇列出的一些简单的游戏问题就不在话下了，感兴趣的朋友不妨挑战一下。关于“剪枝”的技巧，以后有机会，我再和大家做一次分享。

## 复杂度分析

我们来看一下这个算法的复杂度分析：

回溯算法的复杂度主要由递归树的结点个数决定，下面我们就来计算一下这棵递归树有多少个结点。

因为程序在叶子结点和非叶子结点的行为是不一样的，为此我们先计算非叶子结点的个数

我们一层一层地去计算它

根结点这一层只有 1 个空列表，相当于什么都不做，我们忽略掉

第 2 层根据语义是在 n 个数中找出 1 个数

第 3 层根据语义是在 n 个数中找出 2 个数，由于排列是计算顺序的，因此我们使用计算排列数的计算公式

依次加到最后一层非叶子结点，我们把公式展开，再提取公因式 n 的阶乘，里面的和再做一个缩放

将这个和缩放成等比数列前 n 项和的形式，再利用等比数列前 n 项和得到一个表达式，然后再缩放

最后得到的是 2 的阶乘

对于每一个非叶子结点，在内部其实我们是做了一次循环，因此非叶子结点的时间复杂度是 big O n 乘以 n 的阶乘

叶子结点的个数我们是很清楚的，就是 n 的阶乘，但是每一个叶子结点，我们都做了一次拷贝，因此

叶子结点的时间复杂度依然是 big O n 乘以 n 的阶乘

因此总的时间复杂度就是 big O n 乘以 n 的阶乘

在这里要向大家说明以下，这个复杂度的推导在绝大多数情况下是不要求掌握的，并且我们做的只是估算，我们只需要知道回溯算法的时间复杂度是指数级别，在它本质上是一种遍历的算法。

为了保存 n 的阶乘这么多全排列，每一个排列占用 n 个空间，因此这个问题的空间复杂度也是 big O n 乘以 n 的阶乘

这道问题是回溯算法的入门问题，希望大家能够仔细体会，回溯算法使用一份状态变量去遍历整个状态空间的方法，我们只需要在合适的状态做一个保存即可，这种遍历方式相对于广度优先遍历是节约空间的。

这就是这道题的视频讲解，感谢大家的收看。

这个问题的时间复杂度与空间复杂度下面我们来看一下这个问题的复杂度主要由这个递归树的结点决定我们就来数一下的为树的节点有多少个

**复杂度分析**：（可以暂时跳过，或者永远跳过，不是很重要，为了知识完整性写在这里。）

说明：回溯算法的时间复杂度一般都比较高，有些问题分析起来很复杂，我个人觉得没有必要掌握，而且剪枝剪得好的话，复杂度会降得很低很多，因此分析最坏时间复杂度的意义也不是很大，视情况而定。

+ 时间复杂度：$O(N \times N!)$

首先计算“非叶子结点的个数”。依次为（按照层数来）

$$
1 + A_N^1 + A_N^2 + \cdots + A_N^{N-1} = 1 + \cfrac{N!}{(N - 1)!} + \cfrac{N!}{(N - 2)!} + \cdots + N!
$$

说明：根结点为 $1$，计算复杂度的时候忽略；$A_N^1$ 表示排列数，计算公式为 $A_n^m = \cfrac{n!}{(n - m)!}$。

在第 1 层，结点个数为：在 $N$ 个数选 1 个的排列，即 $A_N^1$；

在第 2 层，结点个数为：在 $N$ 个数选 2 个的排列，即 $A_N^2$。

以此类推，全部的非叶子结点的总数是：

$$
\cfrac{N!}{(N - 1)!} + \cfrac{N!}{(N - 2)!} + \cdots + N! = N! \left( \cfrac{1}{(N - 1)!} + \cfrac{1}{(N - 2)!} + \cdots + 1 \right) \le N! \left( 1 + \cfrac{1}{2} + \cfrac{1}{3} + \cdots + \cfrac{1}{N - 1} \right) < 2N!
$$

将常系数 $2$ 视为 $1$，每个内部结点循环 $N$ 次，故非叶子结点的时间复杂度为 $O(N \times N!)$；

然后计算叶子结点的个数。最后一层共 $N!$ 个叶节点，在叶子结点处拷贝需要 $O(N)$，叶子结点的时间复杂度也为 $O(N \times N!)$。

+ 空间复杂度：$O(N \times N!)$。递归树的深度是 $\log N$；全排列的总数是 $N!$，每个全排列占空间 $N$，一共是 $N \times N!$ 这么多空间。取较大者。

## 练习

下面提供一些我做过的“回溯”算法的问题，都是特别基础的使用回溯算法解决的问题，以便大家学习和理解“回溯算法”。以下提供一个经验：

做回溯搜索问题**第 1 步都是先画图，画图是非常重要的，只有画图才能帮助我们想清楚递归结构，看清楚、想清楚如何剪枝**。具体的做法是：就拿题目中的示例，想一想人手动操作是怎么做的，一般这样下来，这棵递归树都不难画出。

大家在和小伙伴讲解回溯算法甚至是和面试官讲解回溯算法的时候，画一个树形图相信也是非常形象的。再过渡到编码，相信也是十分自然的事情。

在画图的过程中需要思考清楚的问题有：

1、分支如何产生，即：每一步有哪些选择；

2、题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？

3、哪些搜索是会产生不需要的解的，这里要特别清楚深搜是怎么运行的，在深搜的过程中，状态变量发生了什么变化。例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？

\+ 这一点也告诉我们，画图可以帮助更清楚地分析代码的执行流程，以准确捕捉需要剪枝的条件。

擅长使用

![image-20200120041346413](https://upload-images.jianshu.io/upload_images/414598-6d1b74b7889fee99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

另外，由于执行的深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子：**请大家看上面的树形图想象**，代码是如何从叶子结点 `[1, 2, 3]` 到叶子结点 `[1, 3, 2]` 的。深度优先遍历是这样执行的：

\+ 从 `[1, 2, 3]` 回到 `[1, 2]` 的时候，需要撤销刚刚已经选择的数 `3`；

\+ 由于在上一层只有一个数 `3` 能选择，我们已经尝试过了，因此程序回到再上一层，需要撤销对 `2` 的选择，好让后面的程序知道，选择 `3` 了以后还能够选择 `2`。

使用深度优先遍历编写代码，可以直接借助系统栈空间，为我们保存所需要的状态变量。在编码中需要注意：遍历到相应的结点的时候，状态变量的值是必须是正确的。此处我们来认识 `path` 变量作为状态变量，它在深度优先遍历中的变化：往下走一层的时候，`path` 变量在尾部追加一个数字，而往回走的时候，需要撤销上一次的选择，这一操作也是在 `path` 的尾部去掉一个数字，因此 `path` 变量是一个栈。


```

```








正是因为待搜索的状态一般情况下很多。如果我们能够提前知道深度优先遍历，在哪一些分支的搜索得不到结果，我们就可以提前跳过这个分支的遍历，这种操作，就像在一个树形结构中剪去一个枝叶，这个操作形象地称为「剪枝」。






在这一章，我们来看一下将递归这种技术使用在非二叉树的结构中，从而认识回溯这一基础算法思想。

在解决二叉树的问题的中我们已经看到了递归算法的威力和有趣之处，也体会到了使用递归算法的痛点。当然，递归算法也绝不仅仅只是适用于二叉树问题的解决。从这一节开始，我们会在更多、更广义的问题上，使用递归算法。



我们从一个比较简单的问题入手，介绍什么是树形问题。

## 回溯算法

+ 回溯搜索算法就是在树形图上的深度优先遍历；

参考的练习题在第 1 部分。

## 难点 1

理解「回溯」，倒不如把「回溯」理解成「深度优先遍历」，「回溯」只是现象，本质是 DFS

+ 回溯算法本质上是遍历的算法，全程使用一份状态变量去搜索状态空间里的所有状态，是节约空间的；
+ 深度优先遍历呈现「一条道走到底，不撞南墙」不回头的特点。

## 难点 2

「深度优先遍历」与「广度优先遍历」的区别于练习：

+ 回溯算法本质上是 **遍历** 的算法，全程使用一份状态变量去搜索状态空间里的所有状态，是节约空间的；
+ 深度优先遍历呈现「一条道走到底，不撞南墙」不回头的特点。


回溯法是解决很多算法问题的常见思想，甚至可以说是传统人工智能的基础方法。其本质依然是使用递归的方法**在树形空间中寻找解**。在这一章，我们来具体看一下将递归这种技术使用在非二叉树的结构中，从而认识回溯这一基础算法思想。

在解决二叉树的问题的中我们已经看到了递归算法的威力和有趣之处，也体会到了使用递归算法的痛点。当然，递归算法也绝不仅仅只是适用于二叉树问题的解决。从这一节开始，我们会在更多、更广义的问题上，使用递归算法。

递归算法还能够解决的一个典型问题，是具有 **树形结构** 的问题，当 **我们发现一个问题与一个更小的问题之间存在递归关系** 的时候，此时，递归关系呈现出来的就是一个树形结构。

为此，我们从一个比较简单的问题入手，介绍什么是树形问题。



回溯搜索，是枚举（穷举），更准确的说法是遍历

### 搜索

- 解释清楚什么是「**状态**」，什么是「状态树」；
- 一棵树对应了一个状态空间；

由于深度优先遍历只要有可以走的路，就不停往下走的特点。

### 理解「状态空间」的方法

理解「状态空间」的方法其实是很简单的，通过一个具体的、规模较小的问题画出结构

在树或者图上，以「深度优先」的方式进行遍历，有回头的过程，回到重复结点的时候，需要将 **状态变量** 的值恢复成为。

DFS 深度优先搜索是一种在回退之前尽可能深入每个分支的遍历算法。介绍深度优先搜索在图（树）问题中的建模、应用，还介绍了基于深度优先搜索的回溯算法。

BFS 广度优先搜索是一种先访问所有同层结点，再继续深入下一层的遍历算法，用于得到无权图的最短路径。介绍了广度优先搜索在图（树）问题中的建模和应用。

- 从高度最小单元格开始依次向并查集中添加元素，由于只能游向高度小于等于当前单元格的高度的地方，所以我们把上、下、左、右四个方向中小于等于当前单元格高度的单元格和当前单元格进行合并；
- 合并完成以后，检查一下左上角到右下角是不是连在一起的；如果不是的话，继续加入比这一次考虑的高度还高一点的单元格，并且执行同样的逻辑，如果是的话，当前这个单元格的高度就是我们要等待的最少的时间。

深度优先遍历

会员题里面还需要筛选一下问题

785：二分图基本问题

886：基于 785 做完，可以用 BFS 和 并查集

迷宫问题：广度优先遍历

第 129 题：制作 keynote 展示动图

二分图那里要说清楚

1. 根据前序和后序遍历构造二叉树

剑指 Offer 33. 二叉搜索树的后序遍历序列

1. 验证前序遍历序列二叉搜索树（会员题）

第 124 题：树形 DP 重新写

三维动态规划：https://leetcode-cn.com/problems/dice-roll-simulation/solution/

把思维导图也更新一下

131 题

「力扣」第 1079 题：活字印刷（中等）

> 知识点：设计递归函数的返回值。

37 解数独：https://www.jianshu.com/p/8ae8bc6916f0

回溯

1. 所有可能的路径

780 官方：https://leetcode-cn.com/problems/reaching-points/solution/dao-da-zhong-dian-by-leetcode/

第 784 题：花花酱的讲解：

http://zxi.mytechroad.com/blog/searching/leetcode-784-letter-case-permutation/





第 39 题

C++ 写法：

![image-20211125091402292](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4n64gc1j31az0u0n0q.jpg)




```java
class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
 
     TreeNode(int x) {
         val = x;
     }
 }
 
 public class Solution {
     public List<List<Integer>> pathSum(TreeNode root, int sum) {
         List<List<Integer>> result = new ArrayList<>();
         if (root == null) {
             return result;
         }
         // 根结点
         if (root.left == null && root.right == null) {
             if (root.val == sum) {
                 List<Integer> temp1 = new ArrayList<>();
                 temp1.add(root.val);
                 result.add(temp1);
                 return result;
             }
         }
         List<List<Integer>> leftLists = pathSum(root.left, sum - root.val);
         mergeOneAndList(root, leftLists, result);
         List<List<Integer>> rightLists = pathSum(root.right, sum - root.val);
         mergeOneAndList(root, rightLists, result);
         return result;
     }
 
     private void mergeOneAndList(TreeNode node, List<List<Integer>> listList, List<List<Integer>> result) {
         for (int i = 0; i < listList.size(); i++) {
             List<Integer> temp1 = new ArrayList<>();
             temp1.add(node.val);
             temp1.addAll(listList.get(i));
             result.add(temp1);
         }
     }
 }
```



```python
class Solution(object):
    def pathSum(self, root, sum):
        results = []
        self.__dfs([], root, sum, results)
        return results


    def __dfs(self, path, root, sum, results):
        if root is None:
            return
        if root.left is None and root.right is None and root.val == sum:
            result = []
            result.extend(path)
            result.append(root.val)
            results.append(result)
            return
        path.append(root.val)
        if root.left:
            self.__dfs(path, root.left, sum - root.val, results)
        if root.right:
            self.__dfs(path, root.right, sum - root.val, results)
        # 这一步很关键
        path.pop()
```



```python
from typing import List




class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None




class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:


        res = []
        if root is None:
            return res


        if root.left is None and root.right is None:
            if root.val == sum:
                temp1 = [root.val]
                res.append(temp1)
                return res


        left_list = self.pathSum(root.left, sum - root.val)
        self.__merge_one_list(root, left_list, res)


        right_list = self.pathSum(root.right, sum - root.val)
        self.__merge_one_list(root, right_list, res)
        return res




    # 这个方法过于复杂，也不太好理解
    @staticmethod
    def __merge_one_list(node, temp_list_list, res):
        for temp_list in temp_list_list:
            l = [node.val]
            l.extend(temp_list)
            res.append(l)
```



```java
import java.util.ArrayList;
import java.util.List;


public class Solution {


    private List<List<Integer>> result = new ArrayList<>();


    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        getSum(root, new ArrayList<Integer>(), 0, sum);
        return result;
    }


    private void getSum(TreeNode node, ArrayList<Integer> list, int current, int sum) {
        if (node == null) {
            return;
        }
        current += node.val;
        list.add(node.val);
        if (node.left == null && node.right == null) {
            if (current == sum) {
                result.add(list);
            } else {
                // 什么都不做
                // 在这里可以把不满足的节点都遍历出来
                return;
            }
        }
        if (node.left != null) {
            getSum(node.left, new ArrayList<Integer>(list), current, sum);
        }
        if (node.right != null) {
            getSum(node.right, new ArrayList<Integer>(list), current, sum);
        }
    }
}
```



![image-20211125091513113](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4ocb4b8j311i0u0di1.jpg)



```
@gouaili 您好，很抱歉，您的问题已经不在我能回答的范围之内。

以下是我针对这道问题的思考。

如果岛屿的形状呈柱形图（直方图，即岛屿的形状有一边是“整齐的”），可以使用[「力扣」第 84 题：“柱状图中最大的矩形”](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 的思路（双指针、单调栈）完成。

有一个思路是我自己想到的，或许可以使用“广度优先遍历”的思路完成，从一个“陆地”开始，尝试向“四面八方”扩散，记录能扩散的最大的面积，遍历完成之后再取最大值，这个思路的编码会比较复杂，也在我的能力范围之外，仅供参考。

您也可以在「力扣」的 [「圈子」](https://leetcode-cn.com/circle/) 版块提问，以获得更专业的回答。
```



![image-20211125091605545](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4p6tihvj31jk0pe0vx.jpg)



![image-20211125091617501](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4peqtidj310q0lg76s.jpg)



![image-20211125091628461](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4pn1sxaj31a40u0dl8.jpg)

## 0784



![image-20211125091646667](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4pxq3txj31ay0n078k.jpg)

![image-20211125091657265](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4q3n7yhj31ae0ngtb0.jpg)









```cpp
class Solution {
public:
    bool bfs(vector<vector<int>>& heights, vector<vector<bool>>& mask, int max_h){
        queue<pair<int, int>> q;
        q.push(make_pair(0, 0));
        mask[0][0] = true;
        vector<vector<int>> offset = {{1,0},{0,1},{0,-1},{-1,0}};;
 
        while(!q.empty()){
            auto [i, j] = q.front();
            q.pop();
            for(auto _offset: offset){
                int _i = i + _offset[0], _j = j + _offset[1];
                if(_i < 0 || _j < 0 || _i >= heights.size() || _j >= heights[0].size() ||
                    mask[_i][_j] || abs(heights[_i][_j] - heights[i][j]) > max_h){
                        continue;
                    }
                mask[_i][_j] = true;
                q.push(make_pair(_i, _j));
                //cout << _i << " + " << _j << endl;
                if(_i == heights.size() - 1 && _j == heights[0].size() - 1) return true;
            }
        }
        return false;
    }
    int minimumEffortPath(vector<vector<int>>& heights) {
        int n = heights.size();
        int m = heights[0].size();
        if(n <= 1 && m <= 1) return 0;
        int left = 0, right = 10000;
        while(left < right){
            int mid = ((right - left) >> 1) + left;
            vector<vector<bool>> mask(n, vector<bool>(m, false));
            //cout << "-----" << endl;
            if(bfs(heights, mask, mid)){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return left;
    }
};
```


回溯搜索，是枚举（穷举），更准确的说法是遍历

### 搜索

- 解释清楚什么是「**状态**」，什么是「状态树」；
- 一棵树对应了一个状态空间；

由于深度优先遍历只要有可以走的路，就不停往下走的特点。

### 理解「状态空间」的方法

理解「状态空间」的方法其实是很简单的，通过一个具体的、规模较小的问题画出结构

在树或者图上，以「深度优先」的方式进行遍历，有回头的过程，回到重复结点的时候，需要将 **状态变量** 的值恢复成为。

DFS 深度优先搜索是一种在回退之前尽可能深入每个分支的遍历算法。介绍深度优先搜索在图（树）问题中的建模、应用，还介绍了基于深度优先搜索的回溯算法。

BFS 广度优先搜索是一种先访问所有同层结点，再继续深入下一层的遍历算法，用于得到无权图的最短路径。介绍了广度优先搜索在图（树）问题中的建模和应用。

- 从高度最小单元格开始依次向并查集中添加元素，由于只能游向高度小于等于当前单元格的高度的地方，所以我们把上、下、左、右四个方向中小于等于当前单元格高度的单元格和当前单元格进行合并；
- 合并完成以后，检查一下左上角到右下角是不是连在一起的；如果不是的话，继续加入比这一次考虑的高度还高一点的单元格，并且执行同样的逻辑，如果是的话，当前这个单元格的高度就是我们要等待的最少的时间。

深度优先遍历

会员题里面还需要筛选一下问题

785：二分图基本问题

886：基于 785 做完，可以用 BFS 和 并查集

迷宫问题：广度优先遍历

第 129 题：制作 keynote 展示动图

二分图那里要说清楚

1. 根据前序和后序遍历构造二叉树

剑指 Offer 33. 二叉搜索树的后序遍历序列

1. 验证前序遍历序列二叉搜索树（会员题）

第 124 题：树形 DP 重新写

三维动态规划：https://leetcode-cn.com/problems/dice-roll-simulation/solution/

把思维导图也更新一下

131 题

「力扣」第 1079 题：活字印刷（中等）

> 知识点：设计递归函数的返回值。

37 解数独：https://www.jianshu.com/p/8ae8bc6916f0

回溯

1. 所有可能的路径

780 官方：https://leetcode-cn.com/problems/reaching-points/solution/dao-da-zhong-dian-by-leetcode/

第 784 题：花花酱的讲解：

http://zxi.mytechroad.com/blog/searching/leetcode-784-letter-case-permutation/





第 39 题

C++ 写法：

![image-20211125091402292](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4n64gc1j31az0u0n0q.jpg)




```java
class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
 
     TreeNode(int x) {
         val = x;
     }
 }
 
 public class Solution {
     public List<List<Integer>> pathSum(TreeNode root, int sum) {
         List<List<Integer>> result = new ArrayList<>();
         if (root == null) {
             return result;
         }
         // 根结点
         if (root.left == null && root.right == null) {
             if (root.val == sum) {
                 List<Integer> temp1 = new ArrayList<>();
                 temp1.add(root.val);
                 result.add(temp1);
                 return result;
             }
         }
         List<List<Integer>> leftLists = pathSum(root.left, sum - root.val);
         mergeOneAndList(root, leftLists, result);
         List<List<Integer>> rightLists = pathSum(root.right, sum - root.val);
         mergeOneAndList(root, rightLists, result);
         return result;
     }
 
     private void mergeOneAndList(TreeNode node, List<List<Integer>> listList, List<List<Integer>> result) {
         for (int i = 0; i < listList.size(); i++) {
             List<Integer> temp1 = new ArrayList<>();
             temp1.add(node.val);
             temp1.addAll(listList.get(i));
             result.add(temp1);
         }
     }
 }
```



```python
class Solution(object):
    def pathSum(self, root, sum):
        results = []
        self.__dfs([], root, sum, results)
        return results


    def __dfs(self, path, root, sum, results):
        if root is None:
            return
        if root.left is None and root.right is None and root.val == sum:
            result = []
            result.extend(path)
            result.append(root.val)
            results.append(result)
            return
        path.append(root.val)
        if root.left:
            self.__dfs(path, root.left, sum - root.val, results)
        if root.right:
            self.__dfs(path, root.right, sum - root.val, results)
        # 这一步很关键
        path.pop()
```



```python
from typing import List




class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None




class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:


        res = []
        if root is None:
            return res


        if root.left is None and root.right is None:
            if root.val == sum:
                temp1 = [root.val]
                res.append(temp1)
                return res


        left_list = self.pathSum(root.left, sum - root.val)
        self.__merge_one_list(root, left_list, res)


        right_list = self.pathSum(root.right, sum - root.val)
        self.__merge_one_list(root, right_list, res)
        return res




    # 这个方法过于复杂，也不太好理解
    @staticmethod
    def __merge_one_list(node, temp_list_list, res):
        for temp_list in temp_list_list:
            l = [node.val]
            l.extend(temp_list)
            res.append(l)
```



```java
import java.util.ArrayList;
import java.util.List;


public class Solution {


    private List<List<Integer>> result = new ArrayList<>();


    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        getSum(root, new ArrayList<Integer>(), 0, sum);
        return result;
    }


    private void getSum(TreeNode node, ArrayList<Integer> list, int current, int sum) {
        if (node == null) {
            return;
        }
        current += node.val;
        list.add(node.val);
        if (node.left == null && node.right == null) {
            if (current == sum) {
                result.add(list);
            } else {
                // 什么都不做
                // 在这里可以把不满足的节点都遍历出来
                return;
            }
        }
        if (node.left != null) {
            getSum(node.left, new ArrayList<Integer>(list), current, sum);
        }
        if (node.right != null) {
            getSum(node.right, new ArrayList<Integer>(list), current, sum);
        }
    }
}
```



![image-20211125091513113](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4ocb4b8j311i0u0di1.jpg)



```
@gouaili 您好，很抱歉，您的问题已经不在我能回答的范围之内。

以下是我针对这道问题的思考。

如果岛屿的形状呈柱形图（直方图，即岛屿的形状有一边是“整齐的”），可以使用[「力扣」第 84 题：“柱状图中最大的矩形”](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 的思路（双指针、单调栈）完成。

有一个思路是我自己想到的，或许可以使用“广度优先遍历”的思路完成，从一个“陆地”开始，尝试向“四面八方”扩散，记录能扩散的最大的面积，遍历完成之后再取最大值，这个思路的编码会比较复杂，也在我的能力范围之外，仅供参考。

您也可以在「力扣」的 [「圈子」](https://leetcode-cn.com/circle/) 版块提问，以获得更专业的回答。
```



![image-20211125091605545](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4p6tihvj31jk0pe0vx.jpg)



![image-20211125091617501](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4peqtidj310q0lg76s.jpg)



![image-20211125091628461](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4pn1sxaj31a40u0dl8.jpg)

## 0784



![image-20211125091646667](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4pxq3txj31ay0n078k.jpg)

![image-20211125091657265](https://tva1.sinaimg.cn/large/008i3skNgy1gwr4q3n7yhj31ae0ngtb0.jpg)
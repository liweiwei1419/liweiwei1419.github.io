
大家好，今天要和大家分享的是 LeetCode 第 78 题：子集问题。

我们看到：
1、子集以列表的形式返回，每一个列表的元素依然是一个列表，每一个列表是输入数组的一个子集。

2、我们看到有 **含有一个元素的列表**，也有含有两个元素的列表。还有两类特殊的列表，它们分别是空列表和包含所有元素的列表；

3、并且每个列表是不计顺序的，也就是说，`[1, 3]` 这个列表和 `[3, 1]` 在结果集中表示的是同一个子集。

----

根据子集的定义：子集是输入数组的一部分。我们就可以根据输入数组的每一个元素是否在子集中展开讨论。

我们以求解 `[1, 2, 3]` 的子集为例向大家说明这个思路。

具体的做法是：**依次考虑**输入数组的每一个元素是否在子集中。

+ 首先从一个空列表开始；

+ 先考虑**是否选择**元素 `1` 在子集中。有两种情况：不选 `1` 和选 `1`；

+ 元素 `1` 考虑完了，我们**基于元素 `1` 考虑的结果**，接下来考虑**是否选择**元素 `2`，依然有两种情况：不选 `2` 和 选 `2`；

+ 在当前考虑了两个元素的结果下，接着考虑**是否选**择第 3 个元素，还可以有两种情况：不选 3 和 选 3。

到此为止，我们 3 个元素都考虑完了，我们看到这是一个树形结构：在叶子结点的所有元素就是所有的子集。那么，要得到所有的叶子结点，我们可以使用深度优先遍历或者广度优先遍历，遍历整棵树，在遍历到叶子结点的时候，把叶子结点的值添加到结果集中。

---

通常我们使用的是深度优先遍历，使用深度优先遍历的好处在这里为大家归纳了 2 点：

1、我们看到这棵树的结点是很多，但是我们是否有必要把所有的结点都保存下来呢？我们只关心叶子结点的值。

我们首先明确一下结点的含义：从根结点到任意一个结点沿途所选择的数的路径。深度优先遍历就能够帮我们节约空间，在遍历的过程中全程使用 1 份路径变量，我们称之为状态变量，它表示了我们求解这个问题的一个阶段。

这个路径在深度优先遍历的过程中发生伸展和收缩。对于这个路径变量，就像一根绳子一样，变长、变短。它在从浅层到深层的过程中，我们在结尾添加一个元素，从深层到浅层回溯的过程中，我们是在它的结尾删除一个元素，很显然它是一个栈。

我们只需要在深度优先遍历，遍历到叶子结点的时候，把路径变量的值记录下来即可，这样做是比较节约空间的。

如果广度优先遍历，不同层的结点的状态的差异是很大的，例如这到这，又比如这到这。因此遍历到每一个结点的状态我们都需要记录下来，这样的话，中间的那些状态变量都要被记录下来，占用的空间就比较多。

那么大家再想一想，为什么深度优先遍历我们不需要记录所有的结点呢，这是因为深度优先遍历没有像广度优先遍历一样状态变量的值跳跃的过程。它就是像走迷宫一样，相邻的状态变量的值差异很小，只是在末尾有变化。

2、我们知道深度优先遍历，必须使用到栈。而编程语言提供的方法栈就可以为我们所用，通过编写递归函数，把需要的状态变量写成方法的参数，这样就我们就不用显式的编写栈和结点类。

这两点可能我这里说得比较晦涩，大家不妨使用广度优先遍历的思路去做一下这道题，再和使用深度优先遍历的思路做一个对比，相信就不难理解我这里说的这两点。

---

深度优先遍历的思想其实也是很值得拿出来单独说的，它其实就是一条道走到底，不撞南墙不回头。当前结点虽然有很多选择，但是如果都没有尝试过的话，首先先选一条路走，直到无路可走，才会回头。每一个结点都是这样，最后回到原点。

由于深度优先遍历有一个回退的过程，我们又叫它回溯算法。回溯算法可以使用较少的状态变量去搜索（遍历）所有可能的状态值（状态空间）。因此在状态空间很大的情况下，可以使用较少的性能消耗完成搜索（遍历）。

我想这就是回溯算法可以成为强大的搜索算法的原因。

---


下面我们开始写代码：

1、首先把输入数组的长度存一下；

2、再做一个特殊判断，如果输入数组的长度为 0 ，返回一个空列表；

3、创建一个结果变量，它是列表中套着列表；

4、接着就是编写递归函数，我们需要的参数有：

输入数组，（为了不每一次都从列表中读取输入数组的长度，我们传一下 `len` 这个变量），当前考虑到的数组元素的下标，一个路径变量（记录从根结点到任意结点的路径，它是一个栈），还有结果集变量；

这里的几个变量我们也可以声明成成员变量，这样就不需要在方法的传递中传递这么多参数，我们在这里为了清晰期间，就不写成成员变量了。

5、下面我们编写这个函数；

（1） 首先是递归终止条件，当递归到最后一个元素的下一个元素的时候，即是 `index == len` 的时候，所有的元素都考虑完了，此时就说明到了叶子结点，我们把这个时候的路径变量存一下；

在这里有一个小细节，如果你只是这样写 `res.add(path);` ，只是存了 `path` 这个变量的引用，`path` 在深度优先遍历完成以后为空，得到的结果集列表就全部是空列表。

这里需要特别注意，如果你一开始没有注意到也没有关系，因为这个细节是可以通过调试代码，调试出来的。

所以在这里一定要在外面套一层。如果是广度优先遍历的话，就不用这么做了。

（2） 接下来就是递归的过程了。

我们看到这棵递归树是一棵二叉树。除了叶子结点以外，每一个结点有选和不选两个子节点。

我们先写不选，那就是什么都不做，**直接进入下一层递归**。下一层递归的参数与这个分支的参数唯一的不同就在于当前考虑的数的下标要 `+ 1`，表示下一层递归考虑下一个数。

接下来，考虑另一个分支。选择这个当前考虑的元素，我们就需要把它添加到 `path` 这个列表中。

然后进入下一层递归，下一层递归的写法和上面这一行是一样的，我们复制一下，虽然代码是一样的，但是参数的值是不一样的，我们在这里在 `path` 的末尾增加了一个元素。

递归完成以后有一个回溯的过程，需要撤销对上一次操作的选择。

这就是这个问题的代码。

下面我们写一个测试方法。


Java 代码：
```java
public static void main(String[] args) {
    Solution solution = new Solution();
    int[] nums = new int[]{1, 2, 3};
    List<List<Integer>> res = solution.subsets(nums);
    System.out.println(res);
}
```

得到的结果和我们画出来的这个树形图是一致的。

我们还可以调换一下这两个递归函数的位置：
+ 我们先考虑选择当前元素；
+ 然后再考虑不选择当前元素，再观察一下结果。

可以看到，结果集的顺序就正好是反过来的，这样我们就更有理由相信我们写的代码是没有问题的。


---

下面我们看一下时间复杂度。

看一下这棵树的结点个数


我们先数一下这棵树有多少个节点，根据高中排列组合的知识我们知道，要得到一个子集，根据每一个数选择或者不选择，这就 2 个选择，由分步计数原理，有 N 个数，那就是 N 个 2 连乘，有 $2^N$ 个叶子结点，每一个结点我们保存下来需要 N 步，因此时间复杂度度就是 $O(N \times 2^N)$，这里我们没有讨论得很细致，我个人觉得也不是很必要。

空间复杂度：有 $2^N$ 这么多子集，每个子集最多占 $N$ 个空间，因此，空间复杂度也是 $O(N \times 2^N)$。




---


### 思路 2


下面我们来看一下方法 2。可以按照求全排列的思路。

我们还可以一位一位地去考虑这个位置可以填哪些元素。

依然从一个空列表开始。

第 1 个位置可以填的数有 3 个选择，它们分别是 1 、 2 、3 。


第 2 个位置可以填的数在这个结点有 2 个选择，可以选 2 和 3 ，在这个结点只有 1 个选择，只能选择 3 ，如果我再选择 1 的话，[2, 1] 和 [1, 2] 是重复的。


在 [3] 这个结点就没有可以考虑的数了，因为不论选择 [1] 还是选择 [2] 都会出现重复。

再最后一层，我们只能选择 3 。


可以看到我们只要按顺序考虑接下来要考虑的数，当前的数考虑完了，我们不用回头。按顺序考虑，就不会重复了，请大家比较一下这里和全排列问题的不同。

可以看到这样得到的一个树形结构，每一个结点就是我们要找的所有的子集。

这棵树我们是边想边画出来，其实还可以从另一个角度看待这棵树，那就是：

+ 第 1 层是只有 0 个元素的子集；
+ 第 2 层是只有 1 个元素的子集；
+ 第 3 层是只有 2 个元素的子集；
+ 第 4 层是只有 3 个元素的子集。

这里有一个个人的经验，就是我们需要先动起手来，然后才会有可能把要解决的问题的思路看得更清楚。

---

由于所有的结点就是所有的自己，那么我们依然需要遍历整棵树，我们依然是使用深度优先遍历。不同的是我们不是在叶子结点做一个记录，而是我们需要把所有的结点都记录下来。

有了求解之前的问题经验，我们知道依然需要一个记录从根节点到中间节点（或者说是叶子结点）的变量，它记录了深度优先遍历的路径，并且它是一个栈。


下面我们看一下如何写这一版代码。

---


前面的步骤和的一个方法是一样的。
这里我们修改一个定义，把 index 改成 begin ，表示我们从输入数组的哪一个位置开始考虑，之前的那些数我们就不考虑了。


下面我们就来看下深度优先遍历怎么写

（1）首先要写递归终止条件，但是这道题比较特殊，递归终止条件是隐藏在我们要写的递归方法中，我们暂且先跳过

（2）然后我们编写一层循环，从当前考虑的位置开始，遍历到数组的结尾，依次考虑当前位置到结尾位置的元素是否被选择进子集。


每一个我们考虑这个数，就把这个数添加到 path 的结尾，然后进入下一层递归。

这一层递归结束以后，我们要恢复 path 这个变量在进入这一层递归之前的选择，好让它进入同一层递归，这一步叫回溯，或者是状态重置，撤销选择。

由于所有的结点我们都需要记录下来，因此应该在这个位置记录结果集，依然是保存一个副本，外面套一层 ArrayList。


这个递归树的结点更少，时间复杂度就是这棵树的结点个数，时间复杂度是，保存每一个结点最多需要 O(N) 时间复杂度，因此总的时间复杂度是 $O(N \times 2^N)$。

空间复杂度和上一个解法是一样的，也是 $O(N \times 2^N)$。

---

### 思路 3 ：位运算

这个问题还有第 3 种思路，这个思路不太容易想到，我们就当做知识点学习一下。

我们思路依然是考虑到每个数选和不选，这件事情就很像二进制里的 `0` 和 `1`。`0` 就对应了不选，`1` 就对应了选择。

因此，一个整数的二进制表达式就等价于一个长度为 32 的布尔数组。

依然以 `[1, 2, 3]` 为例。


因此我们可以考虑有 3 个位数的所有二进制数，每一个二进制数就对应了一个子集。

这个二进制数唯一一点与布尔数组不同的是，我们是从右边向左边看。因为我们读取二进制数的时候，总是习惯从右边向左边看。


考虑所有 N 位的二进制数。这个二进制数最大值，就是所有的位数都为 1。N 个位置都为 1 的二进制数，就是 1 << N 以后再减 1 ，大家仔细想一想是不是这么回事。

然后而每一个二进制数就对应了。输入数组的一个子集。因为每一个二进制位表示

下面我们来写一下代码。



---


首先依然是保存数组的长度。

然后我们计算一下位数为 N 的二进制数的个数，我们可以计算 2^N ，或者直接用二进制运算，将 1 左移 N 位，就是 2^N。

然后我们从 0 开始遍历，遍历到 size。

每一个 i ，就对应了一个子集，因此我们在循环里面顶一个列表，最多有 N 位。

然后我们依次遍历这 N 个位置，检测这 N 个位置是否是 1。 


检测某一位上是否是 1 ，具体的做法就是与运算，结果是 1 ，就说明这一位是 1，就需要考虑它。

一种做法是用 1 左移这么多位，再和原来的数做与运算，如果这个位数是 0 的话，就说明这个数不选，跳过。否则就是要选第 j 个元素。

另一种写法，是 1 不动，i 左移 j 位，去和 1 做与运算。这个我们待会写。

我们来看一下时间复杂度：

有 2^N 这么多元素，每一个元素有 N 位需要遍历，因此时间复杂度依然是 $O(N \times 2^N)$

空间复杂度也是  $O(N \times 2^N)$。


这就是这道题的三个解法。

我们简单总结一下：我们按照某种顺序或者说标准，去考虑子集的可能出现的情况，得到了所有的子集，这样的做法才能够保证不重不漏。


---

这就是这一节的内容，感谢大家的收看。


---


我们接着看一下这个问题的第 2 个问题，这个问题是 LeetCode 上第 90 号问题：子集 II。


这个问题给了一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

我们来看一下示例:

输入数组是 [1, 2, 2]

输出数组，比 [1, 2, 3] 会少一些，这是因为输入数组包就包含了重复的元素，而子集中的所有元素是不计算顺序的。

也就是这个 2 在前，还是这个 2 在前，或者是 [2, 2, 1], [2, 1 , 2] ，这个子集列表 [1, 2, 2] 都代表了。


那么怎么得到不重复的子集呢？我们参考第 47 题 全排列 II 的做法：

1、如果我们就用 78 题的做法，要发现两个列表是一样的，需要对两个列表都排序，再逐个位置去比对；

2、那么既然都需要排序，我们在搜索的开始就对输入数组进行排序，在深度优先遍历的过程中，跳过可能产生重复元素的分支，这样搜索到的所有子集就不会重复了。

我们来看一下示例：

这里输入数组已经是排好序的。深度优先遍历的过程是这样的，我们先选择 1 ，然后接着选择 1’ ，然后选择 2 ，然后撤销选择。

再根结点考虑第 2 个 1 的时候：

由于第 1 个 1 考虑的后面的元素的集合是 1，2。

第 2 个 1 考虑的后面的元素的集合只有 2。

因此这个 1 再往下搜索出来的结果，肯定包含了这个 1 搜索出来的结果，因此我们将这个 1 剪枝，即是将这一个分支跳过。

而检测到这个分支的条件就只要检测当前考虑的数和之前考虑的那个数是否相等，相等就说明一定会出现重复，跳过即可。


---
title: 第 3 节 「树状数组」如何组织原始输入数据的结构
icon: yongyan
category: 树状数组
tags:
  - 树状数组
---


和「堆」一样，**树状数组的 $0$ 号下标不放置元素，从 $1$ 号下标开始使用**。从上图可以观察到，与数组 `C` 的某个结点有关的数组 `A` 的某些结点，它们的下标之间有如下关系。 


| 数组 `C` 的值由数组 `A` 的哪些元素而来                       | 数组 `A` 的元素个数 |
| ------------------------------------------------------------ | ------------------- |
| `C[1] = A[1]`                                                | $1$                 |
| `C[2] = A[1] + A[2]`                                         | $2$                 |
| `C[3] = A[3]`                                                | $1$                 |
| `C[4] = A[1] + A[2] + A[3] + A[4]`                           | $4$                 |
| `C[5] = A[5]`                                                | $1$                 |
| `C[6] = A[5] + A[6]`                                         | $2$                 |
| `C[7] = A[7]`                                                | $1$                 |
| `C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]` | $8$                 |

这件事情是由下标数值的二进制决定的，把下标写成二进制的形式，**最低位的 $1$ 以及后面的 $0$ 表示了预处理数组 `C` 管理了多少输入数组 `A` 的元素**。我们看一下下面的图：

![在这里插入图片描述](https://pic.leetcode-cn.com/ea2749d0af7e68f26289224ff3fb2051e2093eefb958ddf24bf67f4cae0a347f.png) 

例如：$6$ 的二进制表示为 $0110$，这里只保留最低 4 位。将 $6$ 进行二级制分解得到：

$$
6 = 1 \times 2^2 + 1\times 2^1
$$

最后的这部分 $1\times 2^1$ 决定了 `C[6]` 管理了多少个输入数组 `A` 的数据，这里是 2 个，即从下标 `6` 开始（包括 `6`）向前数 2 个数，因此 `C[6] = A[5] +A[6]`，其它同理。

这就是开头所说的：「树状数组」里某个元素管理了原始输入数组多少数据是由下标决定的。我们看到：

+ 「树状数组」组织成的树是有层级的，**下标的二进制表示的最低位 1 后面的 0 的个数决定了，当前结点在第几层**；
+ 这样组织数据，**从叶子结点到父结点是可以通过一个叫做 `lowbit` 的函数计算出来，并且可以知道小于等于当前下标的同一层结点的所有结点**，为了说清楚这一点，需要有一定的篇幅，我们放在下一节。


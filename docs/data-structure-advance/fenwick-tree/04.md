---
title: 第 4 节 详解 lowbit 函数
icon: yongyan
category: 树状数组
tags:
  - 树状数组
---


这样命名的含义是截取一个正整数的二进制表示里的最低位的 $1$ 和它后面的所有的 $0$。`lowbit` 的定义如下：

```java
lowbit(x) = x & (-x);
```

说明：

+ 这里 `x` 一定是正整数，即 `x >= 1`；
+ 这里 `&` 表示按位与运算；
+ `-x` 也可以写成 `(~x + 1)` ，这里 `~` 表示「按位取反」。这是负数的定义，负数用补码表示，它的值等于这个负数的绝对值按位取反以后再加 $1$，因此 `lowbit(x) = x & (~x + 1);`。

下面是一些关于负数和补码的知识，如果您比较熟悉的话，可以忽略。

### 复习负数和补码的相关知识（熟悉的朋友可以忽略）

说明：我的表述不一定准确，我的基础不好，欢迎指正。

+ 计算机底层存储整数使用 32 位；
+ 最高位表示符号位：1 表示负数， 0 表示正数；
+ 负数使用补码表示。

补码按照如下规则定义：

+ 正数的补码是它自己；
+ 负数的补码是它对应正整数按位取反以后再加 1。


例如：计算 $-5$ 的二进制表示：

| 步骤                                   | 二进制表示                            |
| -------------------------------------- | ------------------------------------- |
| 第 1 步：写出 $5$ 的二进制表示；       | `00000000 00000000 00000000 00000101` |
| 第 2 步：将 $5$ 的二进制表示按位取反； | `11111111 11111111 11111111 11111010` |
| 第 3 步：在第 2 步的基础上再加 $1$。   | `11111111 11111111 11111111 11111011` |

这样设计的好处是：**符号位参与计算，并且保证了结果正确**，我们再看一个例子。


例 2：计算 $16 - 8$。

| 步骤                              | 二进制表示                            |
| --------------------------------- | ------------------------------------- |
| 第 1 步：写出 $16$ 的二进制表示； | `00000000 00000000 00000000 00010000` |
| 第 2 步：写出 $-8$ 的二进制表示； | `11111111 11111111 11111111 11111000` |
| 第 3 步：计算 $16 - 8$。          | `00000000 00000000 00000000 00001000` |

计算 $16 - 8$，直接加，高位溢出，但不影响结果。


### `lowbit` 运算解释：

+ 先按位取反正好让最低位的 $1$ 变成 $0$，最低位的 $1$ 后面的 $0$ 变成 $1$，最低位的 $1$ 前面的 $1$ 变成 $0$，$0$ 变成 $1$；
+ 再加 $1$ 使得低位的 $1$ 全变成 $0$，原来变成 $0$ 的 $1$ 由于进位又变回了 $1$；
+ 再按位取余，正好就留下了一个 $1$。


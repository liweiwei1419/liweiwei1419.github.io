---
title: 7.3 详解「排除法」
icon: yongyan
category: 二分查找
tags:
  - 减治思想
---

## 从哪些元素一定不是目标元素考虑

做对这一类问题的思路是「排除法」。在本题解最开始其实已经介绍了，我们的思路是做排除法：具体是根据看到的 `mid` 位置的元素，排除掉不可能存在目标元素的区间，进而确定下一轮在可能存在目标元素的子区间。

## 具体做法

### 把循环可以继续的条件写成 `while (left < right)`

在循环的过程中 `left` 不断右移，`right` 不断左移。从形式上看，退出循环的时候一定有 `left == right` 成立。此时要注意：`left` （`right`） 这个位置的值可能程序还没有读取到，因此 **有可能** 需要再对 `left`（`right`） 这个位置的值是否是目标元素的值做一次判断。

写 `if` 和 `else` 语句的时候，思考当 `nums[mid]` 满足什么性质的时候，`mid` 不是解，进而接着判断 `mid` 的左边有没有可能是解，`mid` 的右边有没有可能是解。

**说明**：

+ 做题的经验告诉我，「思考什么时候不是解」比较好想。生活中其实也是这样，我往往说不大清楚我想要什么，但是我很确定我不想要什么；
+ 此时 `mid` 作为待查找数组就分为两个区间，一个部分可能存在目标元素，一个部分一定不存在目标元素，`mid` 作为这两个区间的分界点。

根据 `mid` 被分到左边区间还是右边区间，代码写出来只有以下 2 种（重难点）。

### 边界收缩行为 1

 `mid` 被分到左边。即区间被分成 `[left, mid]` 与 `[mid + 1, right]`，这里用“闭区间”表示区间端点可以取到，下同；

代码写出来是这样的：

```java
if (check(mid)) {
    // 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置
    left = mid + 1;
} else {
    // 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置
    right = mid;
}
```

**说明**：这里的 `check(mid)` 函数通常是一个表达式（例如上面的“参考代码 1”），在一些情况下有可能逻辑比较复杂，建议专门抽取成一个私有方法，以突显主干逻辑。

### 边界收缩行为 2

 `mid` 被分到右边。即区间被分成 `[left, mid - 1]` 与 `[mid, right]`；

同上，代码写出来是这样的（由于注释是对称的，这里省略，留给读者填充）：

```java
if (check(mid)) {
    right = mid - 1;
} else {
    left = mid;
}
```

### 根据「边界收缩行为」修改取中间数的行为（重难点）

::: danger 提示

修改取中间数的行为是为了避免出现死循环，题目做得多了，就慢慢理解了。

::: 

先说一下中间数的取法。一般是这样的：

```java
int mid = (left + right) / 2;
```

这种写法在绝大多数情况下没问题，但是在 `left` 和 `right` 特别大的场景中，`left + right` 会发生整形溢出，得到一个负数，`mid` 的值随之也是负数。改进的写法是：

```java
int mid = left + (right - left) / 2;
```

这两种写法事实上没有本质的区别，在 `left` 和 `right` 都表示数组索引的时候，几乎不会越界，因为绝大多数情况下不会开那么长的数组。

这里有一个细节，`/` 是整除，它的行为是「向下取整」，造成了 **`int mid = (left + right) / 2` 这种写法 `mid` 永远取不到带搜索区间里最右边的位置**（读者可以举一个只有 `2` 个元素的子数组，理解这句话）。

面对上面的「**边界收缩行为 2**」（`mid` 被分到右边），在待搜索区间收缩到只剩下 2 个元素的时候，**就有可能**（请读者在练习的过程中体会这里我的描述为什么是「有可能」而不是「一定」）造成死循环。如下图：

![LeetCode 第 35 题：“搜索插入位置”.png](https://pic.leetcode-cn.com/eda3857e94d6ead3ed2d2f473fdaf8eaa1252a481e3220511d3a89e4d2f112ac-LeetCode%20%E7%AC%AC%2035%20%E9%A2%98%EF%BC%9A%E2%80%9C%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E2%80%9D.png)



::: danger 提示

当待搜索区间**只剩下** $2$ 个元素的时候，才有可能会进入死循环。如果读者不太明白，可以暂时先不去理解这一点，直到编码过程中，出现死循环的时候，再去调试就很清楚了。

::: 

##  `while (left < right)` 不表示左闭右开

> 待补充。
**思路**：

+ 二分查找算法就一种思想：减而治之（逐渐缩小问题规模），也可以视为「排除法」（一直排除一定不是目标元素的区间，思想依然是逐渐缩小搜索区间）；
+ 根据看到的中间位置的元素的值 `nums[mid]` 可以把待搜索区间分为两个部分：「一定不存在目标元素的区间」和「可能存在目标元素的区间」。因此 `mid` 只可能被分到这两个区间的其中一个，即：`while` 里面的 `if` 和 `else` 就两种写法：
  + 如果 `mid` 分到左边区间，即区间分成 `[left..mid]` 与 `[mid + 1..right]`，此时分别设置 `right = mid` 与 `left = mid + 1`；
  + 如果 `mid` 分到右边区间，即区间分成 `[left..mid - 1]` 与 `[mid..right]`，此时分别设置 `right = mid - 1` 与 `left = mid`。
+ 分类讨论的时候，不断排除不是目标元素的区间，以确定下一轮搜索的区间。即一直思考下一轮搜索区间是什么，以 **左闭右闭区间** 的形式表现出来，这样到底变化 `left` 还是变化 `right`，加不加 $1$ 就会很清楚；
+ 在退出循环的时候。如果区间一定存在目标元素，直接返回 `left` 或者 `right`。否则还需要单独做一次判断；
+ 在循环体里，对 `nums[mid]` 与 `target` 的大小关系的判断需要分类讨论。
  + 这里需要仔细一点，向左走还是向右走结果错了的话会导致整个结果都错。如果写成三个分支去判断；
  + **最后要合并成两个分支。这样退出循环的时候，`left` 和 `right` 才会合并到一起**。我们才可以不用纠结到底返回 `left` 还是返回 `right`。
+ 如果对二分不是很熟悉，可以慢一点，写上注释，耐心调试，二分查找没有那么难写；
+ 从「要找的问题反面」去思考一般而言相对容易，这是因为只要一个分支的逻辑的判断是正确的，另一个分支的逻辑就是其反面，考虑的内容会少一些。
+ 看到边界是 `left = mid` 的时候，取中间数的计算表达式应该上取整，即在括号里加 `1`，这是 **为了防止在区间只有两个元素的时候出现死循环**；
+ 编码时应该先写主干逻辑，然后分支逻辑作为私有函数；
+ 当然可以在 `if` 和 `else` 语句里写出三种情况，但是我们建议：如果真的是分三种情况的话，写完以后需要将其中两种情况合并，否则在退出循环以后，不一定有 `left == right` 成立。
+ 在「力扣 」第 35 题（搜索插入位置）的 [题解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/) 里写了如何用 **左右逼近** 的方式找到目标元素；
+ 下图解释了取 `mid` 的时候上下取整的原因。

![image.png](https://pic.leetcode-cn.com/1617778514-OzKyCg-image.png)
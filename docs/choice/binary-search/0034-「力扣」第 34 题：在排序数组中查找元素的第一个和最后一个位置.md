# 「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置



给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 $O(\log n)$ 级别。

如果数组中不存在目标值，返回 `[-1, -1]`。

示例 1：

```
输入: nums = [5, 7, 7, 8, 8, 10], target = 8
输出: [3, 4]
```

示例 2： 

```
输入: nums = [5, 7, 7, 8, 8, 10], target = 6
输出: [-1,-1]
```



Java 代码：（讲解代码）

```java
public class Solution {

    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return new int[]{-1, -1};
        }

        int firstPosition = searchFirstPosition(nums, len, target);
        if (firstPosition == -1) {
            return new int[]{-1, -1};
        }
        int lastPosition = searchLastPosition(nums, len, target);
        return new int[]{firstPosition, lastPosition};
    }

    private int searchFirstPosition(int[] nums, int len, int target) {
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target) {
                // mid 以及 mid 的左边一定不是目标元素第 1 次出现的位置
                // 下一轮搜索的区间是 `[mid + 1, right]`
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 `[left, mid]`
                right = mid;
            }
        }
        if (nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int searchLastPosition(int[] nums, int len, int target) {
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] > target) {
                // mid 以及 mid 的右边一定不是目标元素最后一次出现的位置
                // 下一轮搜索的区间是 `[left, mid - 1]`
                right = mid - 1;
            } else {
                // 下一轮搜索的区间是 `[mid, right]`
                left = mid;
            }
        }
        return left;
    }
}
```



---

参考代码：

![image-20191126064614567](https://tva1.sinaimg.cn/large/007S8ZIlly1gfaqcd1h22j31300g8wjl.jpg)

![image-20191126065106917](https://tva1.sinaimg.cn/large/007S8ZIlly1gfaqcenqzrj30u01094a2.jpg)



Java 代码：

```java
import java.util.Arrays;

/**
 * @author liwei
 * @date 2019/7/1 6:01 AM
 */
public class Solution4 {

    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        // 特判，这一步很重要，否则执行到后序方法可能会出现数组下标越界
        // 同时后序两个方法也不用做特殊判断了
        if (len == 0) {
            return new int[]{-1, -1};
        }

        int num1 = findLowerBound(nums, target);
        // 细节：如果左边界都搜索不到，右边界也没有必要看了
        if (num1 == -1) {
            return new int[]{-1, -1};
        }
        int num2 = findUpBound(nums, target);
        return new int[]{num1, num2};
    }


    private int findLowerBound(int[] nums, int target) {
        // 找大于等于 target 的第 1 个数的索引，小于一定不符合要求
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // 根据分支逻辑，这里选择左中位数
            // int mid = left + (right - left) / 2;
            int mid = (left + right) >>> 1;
            // 因为找大于等于 target 的第 1 个数，因此小于一定不符合要求
            // 把它写在分支的前面
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        // 因为有可能不存在目标元素，最后一定要单独判断一下
        if (nums[left] != target) {
            return -1;
        }
        return left;
    }

    private int findUpBound(int[] nums, int target) {
        // 找小于等于 target 的最后 1 个数的索引，大于一定不符合要求
        // 因为有可能不存在，最后一定要单独判断一下
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // 根据分支逻辑，这里选择右中位数
            // int mid = left + (right - left + 1) / 2;
            int mid = (left + right + 1) >>> 1;
            // 因为找小于等于 target 的最后 1 个数，因此大于一定不符合要求
            // 把它写在分支的前面
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        // 因为有可能不存在目标元素，最后一定要单独判断一下
        if (nums[left] != target) {
            return -1;
        }
        return left;
    }

    public static void main(String[] args) {
        int[] nums = {5, 7, 7, 8, 8, 10};
        int target = 8;
        Solution4 solution4 = new Solution4();
        int[] res = solution4.searchRange(nums, target);
        System.out.println(Arrays.toString(res));
    }
}

```

Python 代码：

```python
from typing import List


class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        num1 = self.__find_lower_bound(nums, target)
        # 如果左边界都搜索不到，右边界也没有必要看了
        if num1 == -1:
            return [-1, -1]
        num2 = self.__find_up_bound(nums, target)
        return [num1, num2]

    def __find_lower_bound(self, nums, target):
        # 找大于等于 target 的第 1 个数的索引，小于一定不符合要求
        # 特判和后处理，都在这个方法中完成，查找 up bound 的时候可省略
        size = len(nums)
        if size == 0:
            return -1
        left = 0
        right = size - 1
        while left < right:
            # 根据分支逻辑，这里选择左中位数
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            # 因为找大于等于 target 的第 1 个数，因此小于一定不符合要求
            # 把它写在分支的前面
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        # 因为有可能不存在目标元素，最后一定要单独判断一下
        if nums[left] != target:
            return -1
        return left

    def __find_up_bound(self, nums, target):
        # 找小于等于 target 的最后 1 个数的索引，大于一定不符合要求
        # 因为有可能不存在，最后一定要单独判断一下
        size = len(nums)
        left = 0
        right = size - 1
        while left < right:
            # 根据分支逻辑，这里选择右中位数
            # mid = left + (right - left + 1) // 2
            mid = (left + right + 1) >> 1
            # 因为找小于等于 target 的最后 1 个数，因此大于一定不符合要求
            # 把它写在分支的前面
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid
        # 后处理在上一步做过了，因此直接返回 left 即可
        return left


if __name__ == '__main__':
    solution = Solution()
    nums = [5, 7, 7, 8, 8, 10]
    target = 8
    result = solution.searchRange(nums, target)
    print(result)
```

Java 代码：

```java
public class Solution2 {

    // 推荐的二分法的版本

    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return new int[]{-1, -1};
        }
        int lowerBound = findLowerBound(nums, target);
        if (lowerBound == -1) {
            return new int[]{-1, -1};
        }
        int upBound = findUpBound(nums, target);
        return new int[]{lowerBound, upBound};
    }


    private int findLowerBound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            // 这种取中点的做法，一定要保证左边在增加
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        // 此时 left = right

        if (nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int findUpBound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            // 注意：这里 (right - left + 1) / 2; 加 1 ，是为了让取中点这件事情靠近右边
            int mid = left + (right - left + 1) / 2;
            // 1 2 3 4 5 6 7 8
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                // nums[mid] <= target
                left = mid;
            }
        }
        if (nums[right] == target) {
            return right;
        }
        return -1;
    }

}
```

Java 代码：

```java
public class Solution3 {

    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return new int[]{-1, -1};
        }
        int lowerBound = findLowerBound(nums, target);
        if (lowerBound == -1) {
            return new int[]{-1, -1};
        }
        int upBound = findUpBound(nums, target);
        return new int[]{lowerBound, upBound};
    }

    // 写了一个不太好理解的二分法的版本

    private int findLowerBound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid;
            } else {
                right = mid;
            }
        }

        // left + 1 == right;

        if (nums[left] == target) {
            return left;
        }
        if (nums[right] == target) {
            return right;
        }
        return -1;
    }

    private int findUpBound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                right = mid;
            } else {
                left = mid;
            }
        }

        if (nums[right] == target) {
            return right;
        }
        if (nums[left] == target) {
            return left;
        }
        return -1;
    }
}
```



---




思路：使用二分查找，我使用的是二分查找法我认为最好用的模板写法。

1、循环可以继续的条件是 `l < r`，这样退出循环的时候 `l == r` 成立，因此就不用纠结返回 `l` 还是 `r` 了；

不过要特别注意一点：我们是通过夹逼的方式把搜索的范围逼到一个点，那么这个点是不是符合要求还要单独做判断。

2、循环体比较简单，真正地做到了“二分”，即“写两个分支”作判断，只要分支条件写正确，其中一个分支一定可以排除掉中点，而另一个分支则保留了中点；

3、取“中点”的操作有 2 种，根据循环体的收缩情况，采用合适的中点方法，这一点很重要，否则会出现死循环。

（1）`mid = l + (r - l) // 2`，特点：在只有两个数的时候，靠近左边。

（2）`mid = l + (r - l + 1) // 2`，特点：在只有两个数的时候，靠近右边。

例如：循环体是 `l = mid + 1` 和 `r = mid` 的时候，表示左端点不断右移，则选择（1），否则会出现死循环；

循环体是 `l = mid` 和 `r = mid - 1` 的时候，表示右端点不断左移，则选择（2），否则会出现死循环。

Python 代码：

```python
class Solution:
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        left = self.__find_lower_bound(nums, target)
        if left == -1:
            return [-1, -1]

        right = self.__find_up_bound(nums, target)
        return [left, right]

    def __find_lower_bound(self, nums, target):
        # 找到小于等于 target 的第 1 个元素的索引
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                assert nums[mid] >= target
                r = mid
        # 最后还要单独判断一下
        if nums[l] != target:
            return -1
        return l

    def __find_up_bound(self, nums, target):
        # 找到大于等于 target 的最后 1 个元素的索引
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l + 1) // 2
            if nums[mid] > target:
                r = mid - 1
            else:
                assert nums[mid] <= target
                l = mid
        # 最后还要单独判断一下
        if nums[l] != target:
            return -1
        return l


if __name__ == '__main__':
    solution = Solution()
    nums = [5, 7, 7, 8, 8, 10]
    target = 8
    result = solution.searchRange(nums, target)
    print(result)
```

总结：1、`while l < r` 就不用纠结返回  `l` 还是 `r` 了，因为循环终止条件是 `l==r` 为真；

2、`mid = l + (r - l) // 2` 和 `mid = l + (r - l + 1) // 2` 要注意。

正确的写法是：先写出分支，再写中点取法，否则很可能出现死循环。



---


题解地址：[十分好用的二分查找法模板（Python 代码、Java 代码）](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/)。

说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。

传送门：[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)。

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>
> 如果数组中不存在目标值，返回 [-1, -1]。
>
> 示例 1:
>
> 输入: nums = [5,7,7,8,8,10], target = 8
> 输出: [3,4]
> 示例 2:
>
> 输入: nums = [5,7,7,8,8,10], target = 6
> 输出: [-1,-1]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 十分好用的二分查找法模板（Python 代码、Java 代码）

**思路分析**：毋庸置疑，肯定用二分法，二分法的核心思想是“夹逼法”或者称为“排除法”。

> 1、尽最大可能排除不符合题意的元素，在每一轮循环中不断减少候选区间的范围，直到候选区间收缩成 1 个数。
>
> 2、因为数组中很可能不存在目标值，因此在第 1 步使用“排除法”最后剩下的这个数，再判断一下它是否等于 `target` 即可。


我把这道题的两个子问题做了一下修改，并写出了关键部分：

1、子问题 1（“开始位置”）：找到等于 `target` 的第 $1$ 个元素的索引，如果找不到等于 `target` 的数，返回 $-1$；  

关键：如果小于，肯定不是解，此时 `left = mid + 1`。


2、子问题 2（“结束位置”）：找到等于 `target` 的最后 $1$ 个元素的索引，如果找不到等于 `target` 的数，返回 $-1$。

关键：如果大于，肯定不是解：此时 `right = mid - 1`。

在「力扣 」第 35 题：“搜索插入位置”的题解[《特别好用的二分查找法模板（Python 代码、Java 代码）》](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/) 里我写了如何使用二分查找法的模板。

下面给出的参考代码，并且在一些细节处给出了注释，如果你有疑问的话，不妨再看一看我上面给出的文章，相信你很容易找到答案。

**参考代码**：

Python 代码：

```Python []
from typing import List


class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        size = len(nums)
        # 特判，这一步很重要，否则执行到后序方法可能会出现数组下标越界
        # 同时后序两个方法也不用做特殊判断了
        if size == 0:
            return [-1, -1]

        num1 = self.__find_lower_bound(nums, target)
        # 细节：如果左边界都搜索不到，右边界也没有必要看了
        if num1 == -1:
            return [-1, -1]

        num2 = self.__find_up_bound(nums, target)
        return [num1, num2]

    def __find_lower_bound(self, nums, target):
        # 找等于 target 的第 1 个数的索引，小于一定不符合要求
        size = len(nums)

        left = 0
        right = size - 1
        while left < right:
            # 根据分支逻辑，这里选择左中位数
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            # 因为找大于等于 target 的第 1 个数，因此小于一定不符合要求
            # 把它写在分支的前面
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        # 因为有可能不存在目标元素，最后一定要单独判断一下
        if nums[left] != target:
            return -1
        return left

    def __find_up_bound(self, nums, target):
        # 找等于 target 的最后 1 个数的索引，大于一定不符合要求
        # 因为有可能不存在，最后一定要单独判断一下
        size = len(nums)
        left = 0
        right = size - 1
        while left < right:
            # 根据分支逻辑，这里选择右中位数
            # mid = left + (right - left + 1) // 2
            mid = (left + right + 1) >> 1
            # 因为找小于等于 target 的最后 1 个数，因此大于一定不符合要求
            # 把它写在分支的前面
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid
        # 因为有可能不存在目标元素，最后一定要单独判断一下
        if nums[left] != target:
            return -1
        return left


if __name__ == '__main__':
    solution = Solution()
    nums = [5, 7, 7, 8, 8, 10]
    target = 8
    result = solution.searchRange(nums, target)
    print(result)
```

Java 代码：

```Java []
import java.util.Arrays;

public class Solution {

    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        // 特判，这一步很重要，否则执行到后序方法可能会出现数组下标越界
        // 同时后序两个方法也不用做特殊判断了
        if (len == 0) {
            return new int[]{-1, -1};
        }

        int num1 = findLowerBound(nums, target);
        // 细节：如果左边界都搜索不到，右边界也没有必要看了
        if (num1 == -1) {
            return new int[]{-1, -1};
        }
        int num2 = findUpBound(nums, target);
        return new int[]{num1, num2};
    }


    private int findLowerBound(int[] nums, int target) {
        // 找等于 target 的第 1 个数的索引，小于一定不符合要求
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // 根据分支逻辑，这里选择左中位数
            // int mid = left + (right - left) / 2;
            int mid = (left + right) >>> 1;
            // 因为找大于等于 target 的第 1 个数，因此小于一定不符合要求
            // 把它写在分支的前面
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        // 因为有可能不存在目标元素，最后一定要单独判断一下
        if (nums[left] != target) {
            return -1;
        }
        return left;
    }

    private int findUpBound(int[] nums, int target) {
        // 找等于 target 的最后 1 个数的索引，大于一定不符合要求
        // 因为有可能不存在，最后一定要单独判断一下
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // 根据分支逻辑，这里选择右中位数
            // int mid = left + (right - left + 1) / 2;
            int mid = (left + right + 1) >>> 1;
            // 因为找小于等于 target 的最后 1 个数，因此大于一定不符合要求
            // 把它写在分支的前面
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        // 因为有可能不存在目标元素，最后一定要单独判断一下
        if (nums[left] != target) {
            return -1;
        }
        return left;
    }

    public static void main(String[] args) {
        int[] nums = {5, 7, 7, 8, 8, 10};
        int target = 8;
        Solution4 solution4 = new Solution4();
        int[] res = solution4.searchRange(nums, target);
        System.out.println(Arrays.toString(res));
    }
}
```


**复杂度分析**：

+ 时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别。
+ 空间复杂度：$O(1)$，只使用了常数个数的辅助变量、指针。

**补充说明**：

上面我把

```java
int mid = left + (right - left) / 2;
```

注释掉，而选用

```java
int mid = (left + right) >>> 1;
```

并且把 
```java
int mid = left + (right - left + 1) / 2;
```
注释掉，而选用

```java
int mid = (left + right + 1) >>> 1;
```

的原因，大家可以参考我为「力扣」第 374 题：“猜数字大小”写的题解
[《借本题说一说取中位数的写法（Python 代码、Java 代码）》](https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/)。





二分查找在通常的资料里会介绍几种模板的写法，但我并不推荐通过模板学习算法的方式。我相信写算法没有那么模板，设计算法的人一定是通过了深入的思考，才设计出一个个精妙的算法和数据结构。

请大家一定不要去记忆所谓的二分查找模板，一题一个模板，相当于没有模板。

# 二分查找的三种写法

二分查找通常有以下几种写法，区别主要在于 `while` 里面，


| 形式                       | 结论与建议                                                   |
| -------------------------- | ------------------------------------------------------------ |
| `while (left <= right)`    | 简单问题用，在循环体里能找到答案以后退出。                   |
| `while (left < right)`     | 复杂问题用，把答案留到退出循环以后，再判断。是解决二分问题的利器，尤其在边界问题用，这种方式考虑细节最少，但是需要一定练习才能灵活运用。 |
| `while (left + 1 < right)` | 不建议，本质上和 `while (left <= right)` 写法一样，盲目套这个所谓的最无脑模板，反而学不会二分。 |


其实理解这三种写法并不难。关键在于掌握：**退出循环的时候，`left` 和 `right` 的位置关系**。只需要掌握一种写法就可以了。

# LeetCode 第 34 题采用 `while(left <= right)` 

本篇题解采用 `while(left <= right)` 这种二分查找的写法，并分析如何在循环体里设置 `left` 和 `right`，和应该返回 `left` 和 `right`，即怎样思考边界问题。**只要逻辑是完备，并且足够细心，写对二分查找问题并不困难**。



## 第 1 部分：查找 target 出现的第 1 个位置

二分查找的基本用法是在一个有序数组里查找目标元素，具体是看区间中间元素的值 `nums[mid]` 与 `target` 的大小关系。

+ 如果等于，就可以直接返回；
+ 如果严格大于，就往右边查找；
+ 如果严格小于，就往左边查找。

**就这 $3$ 种情况**，先判断等于，然后再判断大于还是小于，符合人们正常的思维。


具体到当前「力扣」第 34 题，由于一个元素出现多次，在具体分类讨论的时候，就有一点细微差别。

（如果嫌下面文字多，可以直接看代码，都有注释。）
+ 如果当前看到的元素 **恰好等于**  `target`，那么当前元素有可能是 `target` 出现的第 $1$ 个位置，由于我们要找第 $1$ 个位置，此时我们应该向左边继续查找；
+ 如果当前看到的元素 **严格大于**  `target`，那么当前元素一定不是要找的 `target` 出现的第 $1$ 个位置，第 $1$ 个位置肯定出现在 `mid` 的 **左边** ，因此就需要在 `[left, mid]` 区间里继续查找；
+ 如果当前看到的元素 **严格小于** `target`，那么当前元素一定不是要找的 `target` 出现的第 $1$ 个位置，第 $1$ 个位置肯定出现在 `mid` 的 **右边** ，因此就需要在 `[mid + 1, right]` 区间里继续查找。

代码 1：

```Java []
private int findFirstPosition(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            // ① 不可以直接返回，应该继续向左边找，即 [left..mid - 1] 区间里找
            right = mid - 1;
        } else if (nums[mid] < target) {
            // 应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        } else {
            // 此时 nums[mid] > target，应该继续向左边找，即 [left..mid - 1] 区间里找
            right = mid - 1;
        }
    }

    // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置
    // 因此还需要特别做一次判断
    if (left != nums.length && nums[left] == target) {
        return left;
    }
    return -1;
}
```

**解释**：
+ 第 $1$ 次出现的位置和最后 $1$ 次出现的位置肯定都在数组里。因此，初始化的时候 `left = 0` 、 `right = nums.length - 1`；
+ `nums[mid] == target` 的时候，在 `[left, mid - 1]` 区间里找，有没有可能 `nums[mid]` 就是第 $1$ 次出现的位置，有可能，但不要紧，退出循环的时候 `right` 指针在左，`left` 在右。**如果数组里存在 `target`，那么 `left` 一定位于 `target` 出现的第 $1$ 个位置**，请看下图。

![image.png](https://pic.leetcode-cn.com/1598625222-ESDFZS-image.png)

还有一种特殊情况，当要查找的目标元素不存在的时，分两种情况：（1）target 很大，（2）target 很小：

+ target 很大，还是上面的例子

![image.png](https://pic.leetcode-cn.com/1598625367-qIHrLh-image.png)

+ `target` 很小，还是上面的例子

![image.png](https://pic.leetcode-cn.com/1598625519-qWKIyx-image.png)

以上特殊例子，解释了为什么在 `while (left <= right)` 退出循环以后，需要单独判断 `left` 是否越界，以及判断 `nums[left]` 是不是目标元素的原因。


## 第 2 部分：查找 target 出现的最后 1 个位置

可以直接看注释。

代码 2：

```Java []
private int findLastPosition(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        } else if (nums[mid] < target) {
            // 应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        } else {
            // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
            right = mid - 1;
        }
    }
    // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断
    return right;
}
```

为什么返回 `right` 解释如下图：

![image.png](https://pic.leetcode-cn.com/1598625931-OriAVG-image.png)

这里**注意**：**无需讨论不存在的情况**。这是因为先执行了 `findFirstPosition()` 方法，这个方法如果返回 $-1$，显然我们就知道数组里不存在目标元素，可以直接返回 `[-1, -1]`。

接下来，我们补上主调方法：

代码 3：

```Java []
public int[] searchRange(int[] nums, int target) {
    if (nums.length == 0) {
        return new int[]{-1, -1};
    }
    int firstPosition = findFirstPosition(nums, target);
    // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置
    if (firstPosition == -1) {
        return new int[]{-1, -1};
    }
    int lastPosition = findLastPosition(nums, target);
    return new int[]{firstPosition, lastPosition};
}
```

---

完整代码如下：

## 完整代码 1（其实就是把上面的三个代码拼凑出来）

代码 4：

```Java []
public class Solution {

    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) {
            return new int[]{-1, -1};
        }
        int firstPosition = findFirstPosition(nums, target);
        if (firstPosition == -1) {
            return new int[]{-1, -1};
        }
        int lastPosition = findLastPosition(nums, target);
        return new int[]{firstPosition, lastPosition};
    }


    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }

        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置
        // 因此还需要特别做一次判断
        if (left != nums.length && nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }
        // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断
        return right;
    }
}
```
```C++ []
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> searchRange(vector<int> &nums, int target) {
        if (nums.empty()) {
            return vector<int>{-1, -1};
        }

        int firstPosition = findFirstPosition(nums, target);
        // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置
        if (firstPosition == -1) {
            return vector<int>{-1, -1};
        }
        int lastPosition = findLastPosition(nums, target);
        return vector<int>{firstPosition, lastPosition};
    }

private:
    int findFirstPosition(vector<int> &nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }

        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置
        // 因此还需要特别做一次判断
        if (left != nums.size() && nums[left] == target) {
            return left;
        }
        return -1;
    }

    int findLastPosition(vector<int> &nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }
        // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断
        return right;
    }
};
```

## 完整代码 2

应评论区网友要求，写了一个不利用 `findFirstPosition()` 结果的版本，**和「完整代码 1」没有本质上的区别**。

不利用 `findFirstPosition()` 的结果写 `findLastPosition()`。这里要注意，`findLastPosition()` 的逻辑当 `left == right` 的之后再执行下去，看 `findLastPosition()` 里面的逻辑，找到相等以后 `left = mid + 1;` 所以 `left` 右移一位，退出循环以后 `right` 在左，`left` 在右。因此 `right` 才是 `target` 最后一次出现的位置。但是要注意分支逻辑中有 `right = mid - 1;`，因此 `right` 有可能等于 `-1` 。所以退出循环以后要判断的逻辑是：

```Java []
if (right != -1 && nums[right] == target) {
    return right;
}
```

完整代码如下：

代码 5：

```Java []
import java.util.Arrays;

public class Solution {

    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) {
            return new int[]{-1, -1};
        }
        int firstPosition = findFirstPosition(nums, target);
        int lastPosition = findLastPosition(nums, target);
        return new int[]{firstPosition, lastPosition};
    }


    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }

        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置
        // 因此还需要特别做一次判断
        if (left != nums.length && nums[left] == target) {
            return left;
        }
        return -1;
    }


    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }

        if (right != -1 && nums[right] == target) {
            return right;
        }
        return -1;
    }
}
```

# `while(left < right)` 写法的好处在于退出循环的时候 `left` 与 `right` 的重合

至于 `while(left < right)` 的写法，建议大家参考本题的 [题解](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/) 和第 35 题 [高赞题解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)，我平常也多用 `while(left < right)` 的写法去思考复杂问题，确实可以少考虑很多细节，把思考的精力用于求解问题上。

# `while(left <= right)` 与 `while(left < right)` 写法的区别


这一部分也来自评论区网友的提问，我的理解如下：

首先抓住它们最主要的特征：

+ `while(left <= right)` 在退出循环的时候 `left = right + 1`，即 `right` 在左，`left` 在右；
+ `while(left < right)` 在退出循环的时候，有 `left == right` 成立。

我的经验是 `left <= right` 用在简单的二分问题中，如果题目要我们找的数的性质很简单，可以用这种写法，**在循环体里找到了就退出**。

在一些复杂问题中，例如找一些边界的值（就比如当前这个问题），用 `while(left < right)` 其实是更简单的，**把要找的数留到最后，在退出循环以后做判断**。我觉得最重要的原因是退出循环以后有 `left == right` 成立，这种思考问题的方式不容易出错。

`while(left < right)` 写法难点在于理解：初学的时候很难理解出现死循环的原因。特别是很难理解分支的取法决定中间数的取法。不过通过练习和调试，把这一关过了，相信解决一些难度较大的额额分查找问题就相对容易了。建议大家尝试使用 `while(left < right)` 的方式去解决一些较困难的问题。

# `while (left + 1 < right)` 的写法

一些资料上号称这是最无脑的写法，但是我有一些不同的意见：

+ 首先 `while (left + 1 < right)` 这种写法就很奇怪；
+ 其次，这种写法在设置边界的时候屏蔽了细节，全部写成 `left = mid` 和 `right = mid`，没有加 1 减 1，这一点虽然号称是优点，但我觉得是缺点，加 1 减 1 完全可以分析出来，屏蔽这个细节不能算是优点；
+ 退出循环的时候必须针对 `left` 和 `right` 编写逻辑，这是一个负担，增加了出错的可能；
+ 如果拿这种写法做当前这道题（LeetCode 第 34 题），就会发现代码很不好写。


# 总结

算法不能靠模板来学习，**应该先理解思想，然后通过练习和思考巩固**，这样在面对新问题的时候才不至于被一些边界和死循环给绕晕。

**摘要**：写对二分查找不应该靠记忆，而是需要深刻理解二分查找的基本思想，然后仔细分析题意，认真分类讨论，才不会出错。

+ [题目链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
+ [题解地址](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/)

**思路分析**：

+ 不可以找到 `target` 以后，然后向两边扩散（线性查找），这样的话时间复杂度为 $O(N)$，这里 $N$ 是输入数组的长度；

+ 应该使用两次二分查找，先找 `target` 第一次出现的位置，再找 `target` 最后一次出现的位置，注意分类讨论，并且把分类讨论的结果合并。

**参考代码**：

```java
public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return new int[]{-1, -1};
        }

        int firstPosition = findFirstPosition(nums, target);
        if (firstPosition == -1) {
            return new int[]{-1, -1};
        }

        int lastPosition = findLastPosition(nums, target);
        return new int[]{firstPosition, lastPosition};
    }

    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 小于一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // nums[mid] > target，下一轮搜索区间是 [left..mid]
                right = mid;
            }
        }

        if (nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] > target) {
                // 下一轮搜索区间是 [left..mid - 1]
                right = mid - 1;
            } else 
                // 下一轮搜索区间是 [mid..right]
                left = mid;
            } 
        }
        return left;
    }
}
```

**参考代码的补充说明**：

`findFirstPosition()`，分成三种情况：下面的描述可能有一点啰嗦，但是很多时候问题并不难，我们需要仔细一点就不难做对。

**情况 ①** ：当 `nums[mid] < target` 时

+ `mid` 一定不是 `target` 第一次出现的位置；
+ 由于数组有序，`mid` 的左边一定比 `nums[mid]` 还小，因此 `mid` 的左边一定不是 `target` 第一次出现的位置；
+ `mid` 的右边比 `nums[mid]` 还大，因此 `mid` 的右边有可能存在 `target` 第一次出现的位置。

因此下一轮搜索区间是 `[mid + 1..right]`，此时设置 `left = mid + 1`；


**情况 ②** ：当 `nums[mid] == target` 时

+ `mid` 有可能是 `target` 第一次出现的位置；
+ `mid` 的左边也有可能是 `target` 第一次出现的位置；
+ `mid` 的右边一定不是 `target` 第一次出现的位置。

因此下一轮搜索区间在 `[left..mid]`，此时设置 `right = mid`。


**情况 ③** ：当 `nums[mid] > target` 时

+ `mid` 一定不是 `target` 第一次出现的位置；
+ `mid` 的右边也一定不是 `target` 第一次出现的位置；
+ `mid` 的左边有可能是 `target` 第一次出现的位置，因此下一轮搜索区间在 `[left..mid - 1]`，此时设置 `right = mid - 1`。

**重点在这里**：把情况 ② 和情况 ③ 合并，即当 `nums[mid] >= target` 的时候，下一轮搜索区间是 `[left..mid]`，此时设置 `right = mid - 1`。这样做是因为：**只有当区间分割是 `[left..mid]` 和 `[mid + 1..right]` 的时候，`while(left < right)` 退出循环以后才有 `left == right` 成立**。

`findLastPosition()` 也可以类似分析，这里省略。

在本题解中，`while(left < right)` 只表示退出循环以后有 `left == right` 成立，不表示搜索区间为左闭右开区间，本题解以及我的其它题解中，对循环不变量的定义均为：在 `nums[left..right]` 中查找目标元素。

**复杂度分析**：

+ 时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别；
+ 空间复杂度：$O(1)$，只使用了常数个数的辅助变量。

---

欢迎大家关注我的公众号「算法不好玩」，B 站搜索「liweiwei1419」，我讲解的算法知识特别好懂。

---

# 「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置

传送门：[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)。

> 给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 *O*(log *n*) 级别。 如果数组中不存在目标值，返回 `[-1, -1]`。 **示例 1:**输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] **示例 2:**输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1]

思路：使用二分查找，我使用的是二分查找法我认为最好用的模板写法。

1、循环可以继续的条件是 `l < r`，这样退出循环的时候 `l == r` 成立，因此就不用纠结返回 `l` 还是 `r` 了；

不过要特别注意一点：我们是通过夹逼的方式把搜索的范围逼到一个点，那么这个点是不是符合要求还要单独做判断。

2、循环体比较简单，真正地做到了“二分”，即“写两个分支”作判断，只要分支条件写正确，其中一个分支一定可以排除掉中点，而另一个分支则保留了中点；

3、取“中点”的操作有 2 种，根据循环体的收缩情况，采用合适的中点方法，这一点很重要，否则会出现死循环。

（1）`mid = l + (r - l) // 2`，特点：在只有两个数的时候，靠近左边。

（2）`mid = l + (r - l + 1) // 2`，特点：在只有两个数的时候，靠近右边。

例如：循环体是 `l = mid + 1` 和 `r = mid` 的时候，表示左端点不断右移，则选择（1），否则会出现死循环；

循环体是 `l = mid` 和 `r = mid - 1` 的时候，表示右端点不断左移，则选择（2），否则会出现死循环。

Python 代码：

```python
class Solution:
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        left = self.__find_lower_bound(nums, target)
        if left == -1:
            return [-1, -1]

        right = self.__find_up_bound(nums, target)
        return [left, right]

    def __find_lower_bound(self, nums, target):
        # 找到小于等于 target 的第 1 个元素的索引
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                assert nums[mid] >= target
                r = mid
        # 最后还要单独判断一下
        if nums[l] != target:
            return -1
        return l

    def __find_up_bound(self, nums, target):
        # 找到大于等于 target 的最后 1 个元素的索引
        size = len(nums)
        if size == 0:
            return -1
        l = 0
        r = size - 1
        while l < r:
            mid = l + (r - l + 1) // 2
            if nums[mid] > target:
                r = mid - 1
            else:
                assert nums[mid] <= target
                l = mid
        # 最后还要单独判断一下
        if nums[l] != target:
            return -1
        return l

if __name__ == '__main__':
    solution = Solution()
    nums = [5, 7, 7, 8, 8, 10]
    target = 8
    result = solution.searchRange(nums, target)
    print(result)
```

总结：1、`while l < r` 就不用纠结返回  `l` 还是 `r` 了，因为循环终止条件是 `l==r` 为真；

2、`mid = l + (r - l) // 2` 和 `mid = l + (r - l + 1) // 2` 要注意。

正确的写法是：先写出分支，再写中点取法，否则很可能出现死循环。
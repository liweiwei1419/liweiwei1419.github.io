# 题解 |「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置（二分查找，中等）

**摘要**：写对二分查找不应该靠记忆，而是需要深刻理解二分查找的基本思想，然后仔细分析题意，认真分类讨论，才不会出错。

+ [题目链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
+ [题解地址](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/)

**思路分析**：

+ 不可以找到 `target` 以后，然后向两边扩散（线性查找），这样的话时间复杂度为 $O(N)$，这里 $N$ 是输入数组的长度；

+ 应该使用两次二分查找，先找 `target` 第一次出现的位置，再找 `target` 最后一次出现的位置，注意分类讨论，并且把分类讨论的结果合并。

**参考代码**：

```java
public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return new int[]{-1, -1};
        }

        int firstPosition = findFirstPosition(nums, target);
        if (firstPosition == -1) {
            return new int[]{-1, -1};
        }

        int lastPosition = findLastPosition(nums, target);
        return new int[]{firstPosition, lastPosition};
    }

    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 小于一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // nums[mid] > target，下一轮搜索区间是 [left..mid]
                right = mid;
            }
        }

        if (nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] > target) {
                // 下一轮搜索区间是 [left..mid - 1]
                right = mid - 1;
            } else 
                // 下一轮搜索区间是 [mid..right]
                left = mid;
            } 
        }
        return left;
    }
}
```

**参考代码的补充说明**：

`findFirstPosition()`，分成三种情况：下面的描述可能有一点啰嗦，但是很多时候问题并不难，我们需要仔细一点就不难做对。

**情况 ①** ：当 `nums[mid] < target` 时

+ `mid` 一定不是 `target` 第一次出现的位置；
+ 由于数组有序，`mid` 的左边一定比 `nums[mid]` 还小，因此 `mid` 的左边一定不是 `target` 第一次出现的位置；
+ `mid` 的右边比 `nums[mid]` 还大，因此 `mid` 的右边有可能存在 `target` 第一次出现的位置。

因此下一轮搜索区间是 `[mid + 1..right]`，此时设置 `left = mid + 1`；


**情况 ②** ：当 `nums[mid] == target` 时

+ `mid` 有可能是 `target` 第一次出现的位置；
+ `mid` 的左边也有可能是 `target` 第一次出现的位置；
+ `mid` 的右边一定不是 `target` 第一次出现的位置。

因此下一轮搜索区间在 `[left..mid]`，此时设置 `right = mid`。


**情况 ③** ：当 `nums[mid] > target` 时

+ `mid` 一定不是 `target` 第一次出现的位置；
+ `mid` 的右边也一定不是 `target` 第一次出现的位置；
+ `mid` 的左边有可能是 `target` 第一次出现的位置，因此下一轮搜索区间在 `[left..mid - 1]`，此时设置 `right = mid - 1`。

**重点在这里**：把情况 ② 和情况 ③ 合并，即当 `nums[mid] >= target` 的时候，下一轮搜索区间是 `[left..mid]`，此时设置 `right = mid - 1`。这样做是因为：**只有当区间分割是 `[left..mid]` 和 `[mid + 1..right]` 的时候，`while(left < right)` 退出循环以后才有 `left == right` 成立**。

`findLastPosition()` 也可以类似分析，这里省略。

在本题解中，`while(left < right)` 只表示退出循环以后有 `left == right` 成立，不表示搜索区间为左闭右开区间，本题解以及我的其它题解中，对循环不变量的定义均为：在 `nums[left..right]` 中查找目标元素。

**复杂度分析**：

+ 时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别；
+ 空间复杂度：$O(1)$，只使用了常数个数的辅助变量。

---

欢迎大家关注我的公众号「算法不好玩」，B 站搜索「liweiwei1419」，我讲解的算法知识特别好懂。

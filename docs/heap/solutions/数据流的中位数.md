## 6-6 使用优先队列解决的经典问题 3：数据流的中位数

这一节我们看一道面试常见问题，「力扣」第 295 题：[数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream)。

> 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
>
> 例如，
>
> [2,3,4] 的中位数是 3
>
> [2,3] 的中位数是 (2 + 3) / 2 = 2.5
>
> 设计一个支持以下两种操作的数据结构：
>
> void addNum(int num) - 从数据流中添加一个整数到数据结构中。
> double findMedian() - 返回目前所有元素的中位数。
> 示例：
>
> ```
> addNum(1)
> addNum(2)
> findMedian() -> 1.5
> addNum(3) 
> findMedian() -> 2
> ```
>
>
> 进阶:
>
> 1、如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
> 2、如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-median-from-data-stream
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

思路分析：一个比较容易想到的方法是维护一个有序数组，当然这个数组得是动态数组，每执行一次“findMedian”操作我都对这个动态数组排个序，还要根据此时动态数组里的元素是奇数还是偶数做一个判断，如果是奇数，直接拿中间那个数就好了，如果是偶数，中位数则是中间两个数的平均值。

但事实上，排序这件事情是相对多余的。因为我们其实只关心中间的那两个数字在排序以后的位置。

我们考察一下中位数的定义，中位数把一个有序数组分为两个部分。中位数就正好把这两个部分分开。结合题目告诉我们的，“如果列表长度是偶数，中位数则是中间两个数的平均值”这点，我们就知道，应该将读到的数据流里的数的个数分奇偶数来讨论。

+ 如果数据流读到了偶数个数，那么中位数是前半部分的最大值和后半部分的最小值的平均数；

+ 如果数据流读到了奇数个数，那么中位数就是前半部分的最大值。当然我这么说，其实是在做一个定义，中间的数我把它归到前半部分，当然也可以把它归到后半部分。这一点关系并不大。

由于我们只关心这两部分的最值，并且这两部分数据是动态变化的，这恰好符合优先队列的使用场景。不难想到，我们可以使用一个最大堆，一个最小堆。

+ 最大堆维护了前有序子数组的最大值；
+ 最小堆维护了后有序子数组的最小值；
+ 并且最小堆的元素至多只会比最大堆多 1 个。

同时对数据流读进来的元素个数做一个统计。如果是奇数，最小堆堆顶就是此时数据流的中位数，如果是偶数，二者堆顶的平均值就是此时的中位数。

那么下面就是如何维护这两个堆。因为要保证“最小堆的元素至多只会比最大堆多 1 个”。

为此可以设计这样的算法：

1、一开始毫无疑问，先到最小堆，

2、然后应该往最大堆加一个元素，但是为了保证有序性，这个元素得先经过“最大堆”，然后从最小堆的堆顶出队一个元素，再放入“最小堆”；

3、接下来，读到第 3 个数的时候，我们的目标就是让最大堆多一个元素，为了让这个数被两个堆都看到，顺序是“最大堆 -> 最小堆 -> 最大堆”，可以把一开始的情况归到这一种。

Java 代码：

```java
import java.util.PriorityQueue;

public class MedianFinder {

    /**
     * 当前大顶堆和小顶堆的元素个数之和
     */
    private int count;
    private PriorityQueue<Integer> maxheap;
    private PriorityQueue<Integer> minheap;

    /**
     * initialize your data structure here.
     */
    public MedianFinder() {
        count = 0;
        maxheap = new PriorityQueue<>((x, y) -> y - x);
        minheap = new PriorityQueue<>();
    }

    public void addNum(int num) {
        count += 1;
        maxheap.offer(num);
        minheap.add(maxheap.poll());
        // 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆
        if ((count & 1) != 0) {
            maxheap.add(minheap.poll());
        }
    }

    public double findMedian() {
        if ((count & 1) == 0) {
            // 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值
            return (double) (maxheap.peek() + minheap.peek()) / 2;
        } else {
            // 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素
            return (double) maxheap.peek();
        }
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(\log N)$，优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 $O(\log N)$ 级别的。
+ 空间复杂度：$O(N)$，使用了三个辅助空间，其中两个堆的空间复杂度是 $O(\cfrac{N}{2})$，一个表示数据流元素个数的计数器 `count`，占用空间 $O(1)$，综上空间复杂度为 $O(N)$。


(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{560:function(t,s,a){"use strict";a.r(s);var v=a(1),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("本节是对「回溯算法」内容的高度概括，理解这部分内容需要大家完成相关的练习。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gx39y88xh8j31gs0oi43s.jpg",alt:"image-20211205212430505",loading:"lazy"}})]),t._v(" "),s("h1",{attrs:{id:"回溯算法简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法简介"}},[t._v("#")]),t._v(" 回溯算法简介")]),t._v(" "),s("p",[t._v("「回溯算法」是解决很多算法问题的常见思想，它也是传统的人工智能的方法，其本质是 "),s("strong",[t._v("在树形问题中寻找解")]),t._v(" 。")]),t._v(" "),s("h2",{attrs:{id:"回溯算法是在树形问题上执行一次深度优先遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法是在树形问题上执行一次深度优先遍历"}},[t._v("#")]),t._v(" 回溯算法是在树形问题上执行一次深度优先遍历")]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("重点概括")]),t._v(" "),s("p",[t._v("回溯算法是对题目中所隐含的「树形结构」执行一次 "),s("strong",[t._v("深度优先遍历")]),t._v("。")])]),t._v(" "),s("p",[t._v("以下是维基百科中「回溯算法」和「深度优先遍历」的定义。")]),t._v(" "),s("div",{staticClass:"custom-block info"},[s("p",{staticClass:"custom-block-title"},[t._v("回溯算法")]),t._v(" "),s("p",[s("strong",[t._v("回溯法")]),t._v(" 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：")]),t._v(" "),s("ul",[s("li",[t._v("找到一个可能存在的正确的答案；")]),t._v(" "),s("li",[t._v("在尝试了所有可能的分步方法后宣告该问题没有答案。")])])]),t._v(" "),s("div",{staticClass:"custom-block info"},[s("p",{staticClass:"custom-block-title"},[t._v("深度优先搜索")]),t._v(" "),s("p",[s("strong",[t._v("深度优先搜索")]),t._v(" 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 "),s("strong",[t._v("尽可能深")]),t._v(" 的搜索树的分支。当结点 "),s("code",[t._v("v")]),t._v(" 的所在边都己被探寻过，搜索将 "),s("strong",[t._v("回溯")]),t._v(" 到发现结点 "),s("code",[t._v("v")]),t._v(" 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。")])]),t._v(" "),s("p",[t._v("我刚开始学习「回溯算法」的时候觉得很抽象，一直不能理解为什么 "),s("strong",[t._v("递归之后需要做和递归之前相同的逆向操作")]),t._v("，在做了很多相关的问题以后，我发现其实「回溯算法」与「 "),s("strong",[t._v("深度优先遍历")]),t._v(" 」有着千丝万缕的联系。")]),t._v(" "),s("h2",{attrs:{id:"树形问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树形问题"}},[t._v("#")]),t._v(" 树形问题")]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("做对这一类问题，通过题目中给出的一个简单的例子，在草稿纸上 "),s("strong",[t._v("画出题目中隐藏的树形结构图")]),t._v(" 很重要。")])]),t._v(" "),s("p",[t._v("用于搜索一个树形问题的所有解，叫做「回溯算法」，是通过什么样的方式搜索的？是通过 "),s("strong",[t._v("深度优先遍历")]),t._v(" 的方式搜索的。因此 「回溯算法」和「深度优先遍历」是一回事。")]),t._v(" "),s("h2",{attrs:{id:"搜索与遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#搜索与遍历"}},[t._v("#")]),t._v(" 搜索与遍历")]),t._v(" "),s("p",[t._v("我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。")]),t._v(" "),s("p",[t._v("搜索问题的解，可以通过 "),s("strong",[t._v("遍历")]),t._v(" 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 "),s("strong",[t._v("搜索一个问题的所有的解")]),t._v(" ，通过深度优先遍历的思想实现。")]),t._v(" "),s("h2",{attrs:{id:"遍历的实现方式是递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历的实现方式是递归"}},[t._v("#")]),t._v(" 遍历的实现方式是递归")]),t._v(" "),s("p",[t._v("递归算法能解决的一类典型问题，是具有 "),s("strong",[t._v("树形结构")]),t._v(" 的问题，即一个问题与一个或者多个规模更小、结构相同的问题之间存在联系，我们称这样的问题具有 "),s("strong",[t._v("递归")]),t._v(" 关系。")]),t._v(" "),s("h2",{attrs:{id:"「深度优先遍历」有「回退」的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#「深度优先遍历」有「回退」的过程"}},[t._v("#")]),t._v(" 「深度优先遍历」有「回退」的过程")]),t._v(" "),s("p",[t._v("因为「深度优先遍历」有「回退」的过程，才需要「状态重置」或者称「撤销选择」，这是「回溯」的意思。")]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("「回溯」是通过一个变量的变化搜索问题的所有解。")])]),t._v(" "),s("h2",{attrs:{id:"「回溯算法」的模板代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#「回溯算法」的模板代码"}},[t._v("#")]),t._v(" 「回溯算法」的模板代码")]),t._v(" "),s("p",[t._v("网上会有人提供「回溯算法」的模板代码，但其实「回溯算法」需要看问题的树形结构是「二叉树」还是「多叉树」来决定代码应该如何编写。")]),t._v(" "),s("p",[t._v("我的观点依然是：学习算法是不能靠模板来学的，思考、练习和调试非常重要，算法问题很灵活，盲目套模板是个误区。")]),t._v(" "),s("p",[t._v("本节提供的练习大家只要认真完成了，写出回溯算法就很容易了。")]),t._v(" "),s("h2",{attrs:{id:"与动态规划的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与动态规划的区别"}},[t._v("#")]),t._v(" 与动态规划的区别")]),t._v(" "),s("h3",{attrs:{id:"共同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共同点"}},[t._v("#")]),t._v(" 共同点")]),t._v(" "),s("p",[t._v("用于求解多阶段决策问题。多阶段决策问题即：")]),t._v(" "),s("ul",[s("li",[t._v("求解一个问题分为很多步骤（阶段）；")]),t._v(" "),s("li",[t._v("每一个步骤（阶段）可以有多种选择。")])]),t._v(" "),s("h3",{attrs:{id:"不同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[t._v("#")]),t._v(" 不同点")]),t._v(" "),s("ul",[s("li",[t._v("动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；")]),t._v(" "),s("li",[t._v("回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。")])]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 "),s("strong",[t._v("不断变化")]),t._v(" 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 "),s("strong",[t._v("回退")]),t._v(" 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。")]),t._v(" "),s("p",[t._v("在「力扣」第 51 题的题解《"),s("a",{attrs:{href:"https://leetcode-cn.com/problems/n-queens/solution/gen-ju-di-46-ti-quan-pai-lie-de-hui-su-suan-fa-si-/",target:"_blank",rel:"noopener noreferrer"}},[t._v("回溯算法（第 46 题 + 剪枝）"),s("OutboundLink")],1),t._v("》 中，展示了如何使用回溯算法搜索 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mn",[t._v("4")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("4")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),s("span",{staticClass:"mord"},[t._v("4")])])])]),t._v(" 皇后问题的一个解，相信对大家直观地理解「回溯算法」是有帮助。")])])}),[],!1,null,null,null);s.default=_.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{1058:function(s,t,a){"use strict";a.r(t);var n=a(1),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("ul",[t("li",[s._v("题目链接："),t("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/",target:"_blank",rel:"noopener noreferrer"}},[s._v("1111. 有效括号的嵌套深度"),t("OutboundLink")],1),s._v("；")]),s._v(" "),t("li",[s._v("题解链接："),t("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/qian-tao-shen-du-wan-cheng-gua-hao-pi-pei-wen-ti-s/",target:"_blank",rel:"noopener noreferrer"}},[s._v("嵌套深度 = 完成括号匹配问题实际使用的栈的最大高度"),t("OutboundLink")],1),s._v("。")])]),s._v(" "),t("h2",{attrs:{id:"题目描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[s._v("#")]),s._v(" 题目描述")]),s._v(" "),t("p",[t("strong",[s._v("有效括号字符串")]),s._v(" 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「"),t("strong",[s._v("有效括号字符串")]),s._v("」部分。")]),s._v(" "),t("p",[t("strong",[s._v("嵌套深度")]),s._v(" "),t("code",[s._v("depth")]),s._v(" 定义：即有效括号字符串嵌套的层数，"),t("code",[s._v("depth(A)")]),s._v(" 表示有效括号字符串 "),t("code",[s._v("A")]),s._v(" 的嵌套深度。详情参见题末「"),t("strong",[s._v("嵌套深度")]),s._v("」部分。")]),s._v(" "),t("p",[s._v("有效括号字符串类型与对应的嵌套深度计算方法如下图所示：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png",alt:"img",loading:"lazy"}})]),s._v(" "),t("p",[s._v("给你一个「有效括号字符串」 "),t("code",[s._v("seq")]),s._v("，请你将其分成两个不相交的有效括号字符串，"),t("code",[s._v("A")]),s._v(" 和 "),t("code",[s._v("B")]),s._v("，并使这两个字符串的深度最小。")]),s._v(" "),t("ul",[t("li",[s._v("不相交：每个 "),t("code",[s._v("seq[i]")]),s._v(" 只能分给 "),t("code",[s._v("A")]),s._v(" 和 "),t("code",[s._v("B")]),s._v(" 二者中的一个，不能既属于 "),t("code",[s._v("A")]),s._v(" 也属于 "),t("code",[s._v("B")]),s._v(" 。")]),s._v(" "),t("li",[t("code",[s._v("A")]),s._v(" 或 "),t("code",[s._v("B")]),s._v(" 中的元素在原字符串中可以不连续。")]),s._v(" "),t("li",[t("code",[s._v("A.length + B.length = seq.length")])]),s._v(" "),t("li",[s._v("深度最小："),t("code",[s._v("max(depth(A), depth(B))")]),s._v(" 的可能取值最小。")])]),s._v(" "),t("p",[s._v("划分方案用一个长度为 "),t("code",[s._v("seq.length")]),s._v(" 的答案数组 "),t("code",[s._v("answer")]),s._v(" 表示，编码规则如下：")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("answer[i] = 0")]),s._v("，"),t("code",[s._v("seq[i]")]),s._v(" 分给 "),t("code",[s._v("A")]),s._v(" 。")]),s._v(" "),t("li",[t("code",[s._v("answer[i] = 1")]),s._v("，"),t("code",[s._v("seq[i]")]),s._v(" 分给 "),t("code",[s._v("B")]),s._v(" 。")])]),s._v(" "),t("p",[s._v("如果存在多个满足要求的答案，只需返回其中任意 "),t("strong",[s._v("一个")]),s._v(" 即可。")]),s._v(" "),t("p",[t("strong",[s._v("示例 1：")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('输入：seq = "(()())"\n输出：[0,1,1,1,1,0]\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[t("strong",[s._v("示例 2：")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('输入：seq = "()(())()"\n输出：[0,0,0,1,1,0,1,1]\n解释：本示例答案不唯一。\n按此输出 A = "()()", B = "()()", max(depth(A), depth(B)) = 1，它们的深度最小。\n像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = "()()()", B = "()", max(depth(A), depth(B)) = 1 。\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[t("strong",[s._v("提示：")])]),s._v(" "),t("ul",[t("li",[t("code",[s._v("1 < seq.size <= 10000")])])]),s._v(" "),t("p",[t("strong",[s._v("有效括号字符串：")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('仅由 "(" 和 ")" 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。\n下述几种情况同样属于有效括号字符串：\n  1. 空字符串\n  2. 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串\n  3. 嵌套，可以记作 (A)，其中 A 是有效括号字符串\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[t("strong",[s._v("嵌套深度：")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：\n  1. s 为空时，depth("") = 0\n  2. s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串\n  3. s 为嵌套情况，depth("(" + A + ")") = 1 + depth(A)，其中 A 是有效括号字符串\n\n例如：""，"()()"，和 "()(()())" 都是有效括号字符串，嵌套深度分别为 0，1，2，而 ")(" 和 "(()" 都不是有效括号字符串。\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("h2",{attrs:{id:"分析题意"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析题意"}},[s._v("#")]),s._v(" 分析题意")]),s._v(" "),t("p",[s._v("1、首先需要弄清楚「有效括号」的意思。")]),s._v(" "),t("ul",[t("li",[s._v("如果做过「力扣」第 20 题："),t("a",{attrs:{href:"https://leetcode-cn.com/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"}},[s._v("有效的括号"),t("OutboundLink")],1),s._v("，就不难明白有效括号的含义：就像我们写代码一样，"),t("code",[s._v("{")]),s._v(" 与 "),t("code",[s._v("}")]),s._v(" （本题是 "),t("code",[s._v("(")]),s._v(" 与 "),t("code",[s._v(")")]),s._v("）需要成对出现，才叫匹配；")]),s._v(" "),t("li",[s._v("由于匹配操作符合「后进先出」的特点：遇到进来的右括号 "),t("code",[s._v(")")]),s._v(" ，它匹配后进来的左括号 "),t("code",[s._v("(")]),s._v("，它相对于之前扫描到的左括号 "),t("code",[s._v("(")]),s._v(" 先完成匹配，这种匹配工作需要使用的数据结构是「栈」；")]),s._v(" "),t("li",[s._v("在完成括号匹配的过程中，只需要把遍历到的左括号进栈，在遍历到右括号的时候，左括号出栈，这个思路是经典且重要的。")])]),s._v(" "),t("p",[s._v("2、看题目：")]),s._v(" "),t("blockquote",[t("p",[s._v("连接，可以记作 "),t("code",[s._v("AB")]),s._v("（"),t("code",[s._v("A")]),s._v(" 与 "),t("code",[s._v("B")]),s._v(" 连接），其中 "),t("code",[s._v("A")]),s._v(" 和 "),t("code",[s._v("B")]),s._v(" 都是有效括号字符串。")])]),s._v(" "),t("p",[s._v("说明连在一起的时候，以「有效括号字符串」为最小单位。例如："),t("code",[s._v('A = ")("')]),s._v(" 与 "),t("code",[s._v('B = "()"')]),s._v(" 就不能连接在一起，因为 "),t("code",[s._v("A")]),s._v(" 不是有效括号字符串。")]),s._v(" "),t("p",[s._v("3、看题目：")]),s._v(" "),t("blockquote",[t("p",[s._v("嵌套，可以记作 "),t("code",[s._v("(A)")]),s._v("，其中 A 是有效括号字符串；\n"),t("code",[s._v("s")]),s._v(" 为 "),t("code",[s._v("A")]),s._v(" 与 "),t("code",[s._v("B")]),s._v(" 连接时，"),t("code",[s._v("depth(A + B) = max(depth(A), depth(B))")]),s._v("，其中 "),t("code",[s._v("A")]),s._v(" 和 "),t("code",[s._v("B")]),s._v(" 都是有效括号字符串；\n例如："),t("code",[s._v('""')]),s._v("，"),t("code",[s._v('"()()"')]),s._v("，和 "),t("code",[s._v('"()(()())"')]),s._v(" 都是有效括号字符串，嵌套深度分别为 "),t("code",[s._v("0")]),s._v("，"),t("code",[s._v("1")]),s._v("，"),t("code",[s._v("2")]),s._v("，而 "),t("code",[s._v('")("')]),s._v(" 和 "),t("code",[s._v('"(()"')]),s._v(" 都不是有效括号字符串。")])]),s._v(" "),t("p",[s._v("从这些信息中，可以知道：")]),s._v(" "),t("ul",[t("li",[t("p",[t("strong",[s._v("「嵌套」才会产生「深度」")]),s._v("，所以题目的定义是"),t("strong",[s._v("嵌套深度")]),s._v("，极端例子 1："),t("code",[s._v("()()()()")]),s._v("，这个字符串的「嵌套深度」为 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mn",[s._v("1")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("1")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),t("span",{staticClass:"mord"},[s._v("1")])])])]),s._v("。极端例子 2："),t("code",[s._v("(((())))")]),s._v(" 这个字符串的「嵌套深度」为 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mn",[s._v("4")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("4")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),t("span",{staticClass:"mord"},[s._v("4")])])])]),s._v("。而这个深度恰好与在匹配过程中，栈的最大高度是一致的；")])]),s._v(" "),t("li",[t("p",[s._v("在「有效括号字符串」连接的时候，"),t("code",[s._v("depth(A + B) = max(depth(A), depth(B))")]),s._v(" 的意思是大吃小，即在两个「有效括号字符串」连接的时候，整体深度取决于部分「有效括号字符串」的深度，这一点特别像"),t("strong",[s._v("在二叉树中的计算二叉树的高度")]),s._v("；")])]),s._v(" "),t("li",[t("p",[s._v("其实仔细观察就会发现，这个「嵌套深度」就是输入字符串，"),t("strong",[s._v("使用栈完成括号匹配，栈中最多连续出现的左括号 "),t("code",[s._v("(")]),s._v(" 的个数")]),s._v("。")])]),s._v(" "),t("li",[t("p",[s._v("而题目要求我们把输入的整体有效字符串做一个重组，要求是只拆成两个部分 "),t("code",[s._v("A")]),s._v(" 和 "),t("code",[s._v("B")]),s._v(" ，每个字符要么分到 "),t("code",[s._v("A")]),s._v(" 要么分到 "),t("code",[s._v("B")]),s._v("，分到 "),t("code",[s._v("A")]),s._v(" 标记为 "),t("code",[s._v("0")]),s._v("，分到 "),t("code",[s._v("B")]),s._v(" 标记为 "),t("code",[s._v("1")]),s._v("。而"),t("strong",[s._v("每个部分的字符又要保持在输入字符串中的顺序不变")]),s._v("。因此输出是一个与原始字符串等长的整数数组，这个整数数组里只有 "),t("code",[s._v("0")]),s._v(" 和 "),t("code",[s._v("1")]),s._v("。")])])]),s._v(" "),t("p",[s._v("例如示例 1：")]),s._v(" "),t("p",[s._v("输入："),t("code",[s._v('seq = "(()())"')]),s._v("，嵌套深度为 2，最多连续出现了 2 个左括号。现在要拆分以后再重组，其实思路就有了，把这两个连续出现的左括号分到不同组即可。")]),s._v(" "),t("p",[s._v("输出："),t("code",[s._v("[0, 1, 1, 1, 1, 0]")]),s._v(" 对应了输入字符串的每个字符对应的组号，"),t("code",[s._v("0")]),s._v(" 分到 "),t("code",[s._v("A")]),s._v(" 组，"),t("code",[s._v("1")]),s._v(" 分到 "),t("code",[s._v("B")]),s._v(" 组。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://pic.leetcode-cn.com/adf9d154a6d9b2cb2da0b2d940c5d534ac3b07a389281a19558346b8aa28ebf8-image.png",alt:"image.png",loading:"lazy"}}),s._v("{:width=600}")]),s._v(" "),t("p",[s._v("标记为 "),t("code",[s._v("0")]),s._v(" 的组的「嵌套深度」是 1；标记为 1 的组的「嵌套深度」是 1，因此总的「嵌套深度」就是 1。")]),s._v(" "),t("p",[s._v("从这个示例中我们知道，重组以后的嵌套深度是原始嵌套深度的一半（不能整除的时候上取整）。")]),s._v(" "),t("ul",[t("li",[s._v("如果原始嵌套深度是偶数，例如 6，重组的嵌套深度 = 3；")]),s._v(" "),t("li",[s._v("如果原始嵌套深度是奇数，例如 7，重组的嵌套深度 = 4。")])]),s._v(" "),t("p",[s._v("示例 2：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://pic.leetcode-cn.com/b685ec7f24dc2990ef0950ab009fe4cdd78a591393691dc16dcc1324dd01423b-image.png",alt:"image.png",loading:"lazy"}}),s._v("{:width=600}")]),s._v(" "),t("p",[s._v("说明："),t("strong",[s._v("结果不唯一，但一定要保证连续的左括号 "),t("code",[s._v("((")]),s._v(" 不被分在同一组")]),s._v("，具体来说，就是完成「括号匹配」问题使用的栈里，同时出现的左括号，不能在同一个分组里，这样就不会增加嵌套的深度。")]),s._v(" "),t("h2",{attrs:{id:"思路分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思路分析"}},[s._v("#")]),s._v(" 思路分析")]),s._v(" "),t("ul",[t("li",[s._v("根据 "),t("code",[s._v("depth(A + B) = max(depth(A), depth(B))")]),s._v(" 这个定义，整体的「嵌套深度」取决于子序列的「嵌套深度」的最大者；")]),s._v(" "),t("li",[s._v("要使得 "),t("code",[s._v("max(depth(A), depth(B))")]),s._v(" 的可能取值最小，分析示例的时候提到，这很像一棵二叉树，要使得二叉树的深度最小，那么就需要该二叉树平衡，一个可行的做法是：把栈中连续出现的左括号 "),t("code",[s._v("(")]),s._v(" 根据奇偶性分到不同的组，"),t("strong",[s._v("右括号随与之匹配左括号的组号")]),s._v("；")]),s._v(" "),t("li",[s._v("如果出现 "),t("code",[s._v("()")]),s._v(" 这种子序列，即左括号后面连着出现了右括号，其实分在那一组都是没有关系的，因为它的存在不会使得「嵌套深度」更深。")])]),s._v(" "),t("p",[s._v("置顶的评论总结了解决这道题的核心思想，大家可以看一下。")]),s._v(" "),t("p",[t("strong",[s._v("参考代码")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-Java [] line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Solution")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("maxDepthAfterSplit")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" seq"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" len "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" seq"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("length")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" res "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("len"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 嵌套深度，栈的当前高度")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" depth "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 在 Java 里，seq.charAt(i) 函数会做下标越界检查，")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 因此先转换成字符数组是常见的做法")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" charArray "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" seq"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("toCharArray")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" len"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 遍历到左括号，连续括号个数加 1，")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("charArray"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token char"}},[s._v("'('")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                depth"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// % 2 也可以写成 & 1，为了保证语义清楚，写 % 2")]),s._v("\n                res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" depth "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 遍历到右括号，与当前栈顶左括号分在一组，因此先取模，再 --")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 这一步希望大家多体会，很有意思")]),s._v("\n                res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" depth "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n                depth"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br")])]),t("p",[s._v("大家还可以在「力扣」上搜索一些「括号匹配」的问题来做，在题库里搜索关键字「括号」，相信是非常有意思的问题。")]),s._v(" "),t("p",[s._v("今天是 4 月 1 日，官方选择第 1111 号问题，是不是很有意思呢。今天在题库里搜 reverse 或者 mirror 的题，试试看。")]),s._v(" "),t("p",[s._v("另外这道题的标签是「贪心」和「二分」。")]),s._v(" "),t("ul",[t("li",[s._v("「二分」应该是标错了，一分为二不能叫「二分」；")]),s._v(" "),t("li",[s._v("「贪心」个人觉得用只看局部，得到整体最优，这样解释感觉有点牵强。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);
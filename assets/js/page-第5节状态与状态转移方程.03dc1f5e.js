(window.webpackJsonp=window.webpackJsonp||[]).push([[594],{783:function(t,v,_){"use strict";_.r(v);var a=_(1),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"定义状态-定义子问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义状态-定义子问题"}},[t._v("#")]),t._v(" 定义状态：定义子问题")]),t._v(" "),v("p",[t._v("我们在拆分子问题的时候，会想到一个问题："),v("strong",[t._v("如何描述子问题")]),t._v("。而描述子问题这件事情就叫做 "),v("strong",[t._v("定义状态")]),t._v("。")]),t._v(" "),v("p",[t._v("PS：我也不知道为什么定义子问题要叫成定义状态，真的初学的时候很难懂（哭泣）。")]),t._v(" "),v("p",[t._v("状态的定义一定要非常精准，例如：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("dp[i]")]),t._v(" 表示 "),v("code",[t._v("[0..i]")]),t._v(" 里所有元素的和；")]),t._v(" "),v("li",[v("code",[t._v("dp[i]")]),t._v(" 表示 "),v("code",[t._v("[0..i)")]),t._v(" 里所有元素的和。")])]),t._v(" "),v("p",[t._v("这两件事情是完全不一样的，状态的不同定义会导致状态转移方程大相径庭。")]),t._v(" "),v("h2",{attrs:{id:"推导状态转移方程-描述不同规模子问题之间的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#推导状态转移方程-描述不同规模子问题之间的关系"}},[t._v("#")]),t._v(" 推导状态转移方程：描述不同规模子问题之间的关系")]),t._v(" "),v("p",[t._v("状态转移方程描述了不同规模子问题之间的关系。")]),t._v(" "),v("p",[t._v("由于求汇总值有这样的特点："),v("strong",[t._v("由小规模的问题的解可以得到大规模的问题的解")]),t._v("。大家想想是不是这样：求最小值、最大值、计数（根据分类计数加法原理）。下面这张图展示了一个具体的例子，帮助大家理解。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxbnm4r61vj31hc0u077v.jpg",alt:"image-20211213032152391",loading:"lazy"}})]),t._v(" "),v("p",[t._v("这件事情，在动态规划里就叫做「"),v("strong",[t._v("状态转移")]),t._v("」。")]),t._v(" "),v("p",[t._v("PS：所以状态转移方程就是个等式呀，为什么要叫方程呢？要求解未知数嘛？哪儿来的「转移」呢？转到哪里去，又移动了什么呢？为什么又要推导呢？初学的时候，真叫人头大啊，哈哈哈哈！")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxbld07fe6g306o06owoc.gif",alt:"",loading:"lazy"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);
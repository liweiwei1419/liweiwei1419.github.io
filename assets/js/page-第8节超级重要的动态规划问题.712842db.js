(window.webpackJsonp=window.webpackJsonp||[]).push([[607],{786:function(t,a,s){"use strict";s.r(a);var e=s(1),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"「力扣」第-509-题-斐波拉契数列、第-70-题-爬楼梯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「力扣」第-509-题-斐波拉契数列、第-70-题-爬楼梯"}},[t._v("#")]),t._v(" 「力扣」第 509 题：斐波拉契数列、第 70 题：爬楼梯")]),t._v(" "),a("p",[t._v("这两道问题是动态规划的入门问题。爬楼梯子问题之间的关系和斐波拉契数列是一模一样的。大家可以用「记忆化递归」和「递推」的方式都写一下，后面给出的问题可以只用「递推」实现。")]),t._v(" "),a("p",[t._v("描述清楚状态最重要，其它信息可以在在代码当中得到体现。")]),t._v(" "),a("h2",{attrs:{id:"「力扣」第-198-题-打家劫舍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「力扣」第-198-题-打家劫舍"}},[t._v("#")]),t._v(" 「力扣」第 198 题：打家劫舍")]),t._v(" "),a("p",[t._v("这是一道很经典的动态规划问题。定义子问题（状态）的时候需要考虑「偷」和「不偷」下标为 "),a("code",[t._v("i")]),t._v(" 的房子。"),a("strong",[t._v("为了保证求解过程具有无后效性，将状态表格设计成二维")]),t._v("，这件事情叫：子问题定义得更具体，子问题在之间的描述就越简单（这件事情没有那么绝对，大家不妨作为经验先接受它）。")]),t._v(" "),a("p",[t._v("什么叫子问题定义更具体呢？这个问题的表格是这样的：")]),t._v(" "),a("h2",{attrs:{id:"「力扣」第-300-题-最长上升子序列-无比重要的一道问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「力扣」第-300-题-最长上升子序列-无比重要的一道问题"}},[t._v("#")]),t._v(" 「力扣」第 300 题：最长上升子序列（无比重要的一道问题）")]),t._v(" "),a("p",[t._v("子序列，每一个数字是否被选取，需要分类讨论。因此，在状态定义的时候，定义 "),a("code",[t._v("dp[i]")]),t._v(" 表示：以 "),a("code",[t._v("nums[i]")]),t._v(" 结尾的最长上升子序列的长度。在这样的定义下，"),a("code",[t._v("nums[i]")]),t._v(" 必须被选择，这件事情保证了求解的过程满足「无后效性」。")]),t._v(" "),a("p",[t._v("这道问题也是被 liuyubobobo 老师推荐的一道问题，他特别强调了：最长上升子序列常见的解法有 2 种。"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("msup",[a("mi",[t._v("N")]),a("mn",[t._v("2")])],1),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(N^2)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1.0641em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord"},[a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"msupsub"},[a("span",{staticClass:"vlist-t"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.8141em"}},[a("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 的做法在网上已经有了充分的讨论。而这道题的二分查找算法，更本质上是因为 "),a("strong",[t._v("状态的定义发生了变化")]),t._v("，使得复杂度降到了 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("N")]),a("mi",[t._v("log")]),a("mo",[t._v("⁡")]),a("mi",[t._v("N")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(N \\log N)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.1667em"}}),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.1667em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("。因此我们需要深刻理解状态的定义，状态的定义非常关键。")]),t._v(" "),a("h2",{attrs:{id:"「力扣」第-53-题-最大子段和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「力扣」第-53-题-最大子段和"}},[t._v("#")]),t._v(" 「力扣」第 53 题：最大子段和")]),t._v(" "),a("p",[t._v("是一道和「力扣」第 300 题类似的问题，连续子段的问题和子序列问题一样类似，有不确定的地方。因此，状态的定义中包含 "),a("code",[t._v("nums[i]")]),t._v(" 必须被选择的信息，保证了求解过程具有无后效性。")]),t._v(" "),a("h2",{attrs:{id:"「力扣」第-5-题-最长回文子串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「力扣」第-5-题-最长回文子串"}},[t._v("#")]),t._v(" 「力扣」第 5 题：最长回文子串")]),t._v(" "),a("p",[t._v("这道题的动态规划解法，是我觉得最像填表法的。因为它的状态就是一张二维表格，"),a("strong",[t._v("填表的顺序还需要我们注意")]),t._v("。")]),t._v(" "),a("p",[t._v("这些问题大家可以在题解区、讨论区找到它们的解法，真正理解状态涉及的思想（"),a("strong",[t._v("如何定义子问题")]),t._v("），是最重要的。其它状态转移方程、初始化、填表顺序、输出都依赖于状态定义。")]),t._v(" "),a("h2",{attrs:{id:"其它问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它问题"}},[t._v("#")]),t._v(" 其它问题")]),t._v(" "),a("p",[t._v("「力扣」上的有 2 为朋友整理了「动态规划」题单，他们是：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://leetcode-cn.com/u/feeenedumplings/",target:"_blank",rel:"noopener noreferrer"}},[t._v("FennelDumplings"),a("OutboundLink")],1),t._v("《"),a("a",{attrs:{href:"https://leetcode-cn.com/circle/article/NfHhXD/",target:"_blank",rel:"noopener noreferrer"}},[t._v("力扣上的 DP 问题分类汇总"),a("OutboundLink")],1),t._v("》；")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://leetcode-cn.com/u/richenyunqi/",target:"_blank",rel:"noopener noreferrer"}},[t._v("日沉云起"),a("OutboundLink")],1),t._v("《"),a("a",{attrs:{href:"https://leetcode-cn.com/circle/article/2Xxlw3/",target:"_blank",rel:"noopener noreferrer"}},[t._v("leetcode动态规划题目总结"),a("OutboundLink")],1),t._v("》。")])]),t._v(" "),a("p",[t._v("一定要花时间做掉哦，当然也不用全部做完，以能解决面试中的动态规划问题为准。")])])}),[],!1,null,null,null);a.default=r.exports}}]);
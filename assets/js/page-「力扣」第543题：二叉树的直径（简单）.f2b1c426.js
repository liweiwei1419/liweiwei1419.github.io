(window.webpackJsonp=window.webpackJsonp||[]).push([[387],{832:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[t._v("#")]),t._v(" 题目描述")]),t._v(" "),s("p",[t._v("给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。")]),t._v(" "),s("p",[s("strong",[t._v("示例 :")]),t._v("\n给定二叉树")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("          1\n         / \\\n        2   3\n       / \\\n      4   5\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("返回 "),s("strong",[t._v("3")]),t._v(", 它的长度是路径 "),s("code",[t._v("[4, 2, 1, 3]")]),t._v(" 或者 "),s("code",[t._v("[5, 2, 1, 3]")]),t._v("。")]),t._v(" "),s("p",[t._v("**注意：**两结点之间的路径长度是以它们之间边的数目表示。")]),t._v(" "),s("p",[s("strong",[t._v("Constraints:")])]),t._v(" "),s("ul",[s("li",[t._v("The number of nodes in the tree is in the range "),s("code",[t._v("[1, 10^4]")]),t._v(".")]),t._v(" "),s("li",[s("code",[t._v("-100 <= Node.val <= 100")])])]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"理解什么是二叉树的直径"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解什么是二叉树的直径"}},[t._v("#")]),t._v(" 理解什么是二叉树的直径")]),t._v(" "),s("p",[t._v("题目中对「直径」的解释是这样的：任意两个结点路径长度中的最大值。这里需要补充一下定义。")]),t._v(" "),s("p",[t._v("任意给出一棵二叉树的两个结点，路径指的是：分别从这两个结点向上走，找到 "),s("strong",[t._v("最近的公共祖先")]),t._v(" 结点而形成的路径。"),s("strong",[t._v("只有这样的定义下，直径才是唯一确定的")]),t._v("。")]),t._v(" "),s("p",[t._v("下图展示的是同一棵树，不同的结点 A 和结点 B 定义的直径（图中绿色标注的部分）。其中左图展示的路径经过了根结点，右图展示的路径不经过根结点。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxizhtlbucj31hc0u0ack.jpg",alt:"",loading:"lazy"}})]),t._v(" "),s("p",[t._v("在这样的定义下，"),s("strong",[t._v("路径上的每一个结点最多只与 2 条边连接")]),t._v("。")]),t._v(" "),s("blockquote",[s("p",[t._v("友情提示：确定定义非常关键，直接决定了这道问题是否有解。")])]),t._v(" "),s("h2",{attrs:{id:"无后效性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无后效性"}},[t._v("#")]),t._v(" 无后效性")]),t._v(" "),s("p",[t._v("根据「直径」的定义，这条路径一定会经过某一个结点。而最长的直径会经过哪一个结点这件事情不确定。")]),t._v(" "),s("p",[t._v("动态规划求解的思路需要考虑所有子问题，也就是 "),s("strong",[t._v("每一个结点产生的子问题都会考虑到")]),t._v("。因此我们在设计子问题的时候，就要求我们求解的 "),s("strong",[t._v("子问题")]),t._v(" 的直径 "),s("strong",[t._v("必须经过子问题表述的子树的根结点")]),t._v("。")]),t._v(" "),s("blockquote",[s("p",[t._v("在设计状态的时候，把不确定的事情确定下来，计算得到结果，是「动态规划」的设计思想「无后效性」的应用。我们想一想打家劫舍问题、最长上升子序列问题的状态定义。打家劫舍问题，某一个房间可以偷也可以不偷，我们分别求出，某一个房间被偷的时候的子问题的结果，某一个房间不被偷的时候的子问题的结果，通过比较得出最优值。")])]),t._v(" "),s("p",[t._v("另一件事情，"),s("strong",[t._v("直径可能是「直」的，也可能是「弯」的")]),t._v("（这句话怎么这么搞笑）。「直」和「弯」的定义如下（虽然左边「直」的看起来也很「弯」，大家看图中红字的定义哦）：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxizhyn5jtj31hc0u041k.jpg",alt:"",loading:"lazy"}})]),t._v(" "),s("p",[s("strong",[t._v("我们只规定子问题求解得到的路径是「直」的")]),t._v("。为什么这么规定呢？因为 "),s("strong",[t._v("「直的」情况简单，它可以组成复杂的「弯」的情况")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"状态定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态定义"}},[t._v("#")]),t._v(" 状态定义")]),t._v(" "),s("p",[t._v("经过了子树的根结点，并且路径只来自左子树和右子树其中之一的 "),s("strong",[t._v("最长的")]),t._v(" 长度，也就是说，这条「直径」其实是「半径」。")]),t._v(" "),s("p",[t._v("根结点必须被选择，且根结点是路径上端点，也就是说，我们定义的子问题，这条路径只来自左右子树的其中一个，返回长度最长的值。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7ug1t0oj216a0k6q4r.jpg",alt:"",loading:"lazy"}})]),t._v(" "),s("blockquote",[s("p",[t._v("状态定义即子问题的定义，这是人为规定的，不一定要和题目问的定义一样，状态定义得简单、具体，可以为求解题目要求的问题服务。大家可以想一想「力扣」第 53 题（最大子段和），最后需要遍历一遍所有的状态值，求出最大者，和当前这道问题是一模一样的。")])]),t._v(" "),s("h2",{attrs:{id:"为什么是「后序遍历」"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么是「后序遍历」"}},[t._v("#")]),t._v(" 为什么是「后序遍历」")]),t._v(" "),s("p",[t._v("这件事情也比较理论化，我不敢确定我的解释是不是能够让大家看懂。")]),t._v(" "),s("p",[t._v("深度优先遍历就是从根结点开始在树中转一圈，最后回到根结点。我们采用后序遍历计算结果的方式，表现为：")]),t._v(" "),s("blockquote",[s("p",[t._v("从叶子结点开始，一层一层向上传递信息，最后在根结点汇总结果。")])]),t._v(" "),s("p",[t._v("为什么是「后序遍历」呢？")]),t._v(" "),s("ul",[s("li",[t._v("因为二叉树从子结点到父结点只会有一条路径；")]),t._v(" "),s("li",[t._v("而从根结点到子节点至多会有两条路径。")])]),t._v(" "),s("p",[t._v("「后序遍历」相当于 "),s("strong",[t._v("先求得两个子问题的结果，再根据两个子问题的结果得到当前规模更大的子问题的结果")]),t._v("，这是「分而治之」的思想。")]),t._v(" "),s("h2",{attrs:{id:"题目问的结果在求解子问题的过程中得到"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题目问的结果在求解子问题的过程中得到"}},[t._v("#")]),t._v(" 题目问的结果在求解子问题的过程中得到")]),t._v(" "),s("p",[t._v("这个小点的标题就展示了这一部分要和大家说的信息。")]),t._v(" "),s("p",[t._v("我们对状态的定义规定了只来自左右子树的一边，在后序遍历的时候，左右子树的结果都求得的情况下，当前结点就可以把左右两棵子树的求解结果进行相加，就是题目要求的 "),s("strong",[t._v("经过某个结点")]),t._v(" 的长度最长的直径。")]),t._v(" "),s("p",[t._v("这件事情我其实是在描述「状态转移方程」：")]),t._v(" "),s("p",[t._v("经过了某个结点的路径长度 = 左子树传递上来的路径长度 + 右子树传递上来的路径长度。")]),t._v(" "),s("p",[t._v("大家可以再想一想，为什么路径传递上来，我们规定只能来自左子树和右子树的其中一个子树。大家还可以再回顾一下开始我们说的路径的定义。")]),t._v(" "),s("p",[t._v("我们依然还是先给出，把需要注意的地方写在注释里，大家先看代码：")]),t._v(" "),s("p",[s("strong",[t._v("参考代码")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("diameterOfBinaryTree")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        res "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * @param node\n     * @return 必须经过 node 结点的一条路径的最长长度，并且这条路径只能来自左子树和右子树其中之一\n     */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 后序遍历：先计算左右子树的结果")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在深度优先遍历的过程中找到最大值")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把左、右子树中最长的路径连接起来，就是题目中要求我们找的路径")]),t._v("\n        res "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前结点必须被选择，因此是这里的 1，左右子树只能选一条")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br")])]),s("p",[s("strong",[t._v("代码解释")]),t._v("："),s("code",[t._v("return 1 + Math.max(left, right);")]),t._v(" 可以这样理解。除了根结点以外，每一个结点都有一条边指向它的直接父亲结点。因此向上传递的时候，要把指向父亲结点的这条边加上。而全局的 "),s("code",[t._v("res")]),t._v(" 只需要连接左子树和右子树，不需要向上传，因此不加 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mn",[t._v("1")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("1")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),s("span",{staticClass:"mord"},[t._v("1")])])])]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7ujrblbj21hc0u0tbv.jpg",alt:"",loading:"lazy"}})]),t._v(" "),s("p",[s("strong",[t._v("时间复杂度")]),t._v("：遍历了树一次，因此时间复杂度为 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("N")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(N)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),s("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("，这里 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("N")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("N")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),s("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")])])])]),t._v(" 为二叉树的结点总数。")]),t._v(" "),s("p",[t._v("下面的这幻灯片（大家需要动动手指，滑起来，"),s("strong",[t._v("手机上放大到全屏，否则比较难控制滑动的力度")]),t._v("）展示了上面的代码是如何计算「最长路径的长度」的。可以帮助大家体会代码的执行流程，以及状态设计的思想。")]),t._v(" "),s("Presentation",{attrs:{id:"presentation-64a56f6e","data-code":"%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2Fe6c9d24egy1h2u7ulkhdnj21hc0u075u.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizlss0rbj31hc0u0wh0.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizkmyoptj31hc0u0q4i.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizlhyzpzj31hc0u075v.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizkqt1vlj31hc0u0q4j.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizu9725uj31hc0u0wg3.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizkuh1jpj31hc0u0n01.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizl11gg9j31hc0u0wg4.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizl5pvktj31hc0u0dir.jpg)%0A%0A---%0A%0A!%5B%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxizl9l4qxj31hc0u0779.jpg)%0A",theme:"[theme]"}}),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("解决这道题的思路和昨天我们分享的「力扣」第 124 题（二叉树中的最大路径和）一样。")]),t._v(" "),s("p",[t._v("首先是理解题意，"),s("strong",[t._v("对「直径」「路径」的定义的理解非常关键")]),t._v("，直接决定了递归函数（也就是状态设计）为什么规定了「路径」只能来自其中一个子树。")]),t._v(" "),s("p",[t._v("然后是求解这一类问题的思想：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("后序遍历")]),t._v("：一层一层向上传递；")]),t._v(" "),s("li",[s("strong",[t._v("无后效性")]),t._v("：把不确定的因素固定下来，以便分类讨论。")])]),t._v(" "),s("p",[t._v("我又来不厌其烦地、反复说一件事情：")]),t._v(" "),s("blockquote",[s("p",[t._v("动态规划的问题，如果有不确定的地方，如果有分类讨论的地方，我们在设计状态的时候，就需要把它们固定下来。")])]),t._v(" "),s("h2",{attrs:{id:"练习"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#练习"}},[t._v("#")]),t._v(" 练习")]),t._v(" "),s("p",[t._v("这部分练习包括了昨天推送的文章的练习，还包括了几道会员题。这些问题依然是先理解题目中「直径」「路径」的定义，有些问题「路径」指的是结点的个数，有些问题「路径」指的是边的条数。")]),t._v(" "),s("ul",[s("li",[t._v("「力扣」第 124 题：二叉树中的最大路径和（困难）；")]),t._v(" "),s("li",[t._v("「力扣」第 337 题：打家劫舍 III（中等）；")]),t._v(" "),s("li",[t._v("「力扣」第 543 题：二叉树的直径（简单，本节讲解问题）；")]),t._v(" "),s("li",[t._v("「力扣」第 687 题：最长同值路径（中等）；")]),t._v(" "),s("li",[t._v("「力扣」第 968 题：监控二叉树（困难）；")]),t._v(" "),s("li",[t._v("「力扣」第 1372 题：二叉树中的最长交错路径（中等）；")]),t._v(" "),s("li",[t._v("「力扣」第 1245 题：树的直径（中等，会员题）")]),t._v(" "),s("li",[t._v("「力扣」第 298 题：二叉树的最长连续序列（中等，会员题）；")]),t._v(" "),s("li",[t._v("「力扣」第 549 题：二叉树中最长的连续序列（中等，会员题）。")])]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("这就是今天的分享，感谢大家的收看，今天是周末了，祝大家周末愉快！如果大家觉得我的分享有用，还请帮我点一下「在看」或者给我点赞。")]),t._v(" "),s("p",[t._v("讲得不好的地方，也欢迎大家指出来，感谢大家的支持和鼓励。")])],1)}),[],!1,null,null,null);s.default=e.exports}}]);
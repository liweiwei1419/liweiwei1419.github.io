(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{864:function(t,a,s){"use strict";s.r(a);var i=s(1),n=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("理解切分定理是理解最小生成树的两个算法（Kruskal 算法和 Prim 算法）的理论基础。")]),t._v(" "),a("h2",{attrs:{id:"什么是切分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是切分"}},[t._v("#")]),t._v(" 什么是切分")]),t._v(" "),a("p",[t._v("把图中的结点分为两个部分，称为一个切分（Cut）。如果一个边的两个端点，属于切分（Cut）不同的两边，这个边称为横切边（Crossing Edge）。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxa9bfch6zj319i0twgoy.jpg",alt:"",loading:"lazy"}})]),t._v(" "),a("h2",{attrs:{id:"切分定理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#切分定理"}},[t._v("#")]),t._v(" 切分定理")]),t._v(" "),a("div",{staticClass:"custom-block info"},[a("p",{staticClass:"custom-block-title"},[t._v("切分定理告诉我们")]),t._v(" "),a("p",[t._v("对于任意切分，最短的横切边一定属于最小生成树。")])]),t._v(" "),a("p",[t._v("切分定理：在一幅加权图中，给定 "),a("strong",[t._v("任意")]),t._v(" 切分，所有横切边中权重 "),a("strong",[t._v("最小")]),t._v(" 的边一定属于图的最小生成树。")]),t._v(" "),a("p",[t._v("切分定理的关键字是「任意」。")]),t._v(" "),a("p",[a("strong",[t._v("说明")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("对给定的任意切分都成立，这一点非常重要；")]),t._v(" "),a("li",[t._v("有了切分定理，就可以从一个顶点开始，一点一点扩散，直至找到了所有的顶点，最小生成树就找到了。")])]),t._v(" "),a("h2",{attrs:{id:"理解切分定理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解切分定理"}},[t._v("#")]),t._v(" 理解切分定理")]),t._v(" "),a("p",[t._v("理解切分定理的关键是关于树的两条性质：")]),t._v(" "),a("ul",[a("li",[t._v("性质 1：一棵树任意连接两个顶点，会形成环；")]),t._v(" "),a("li",[t._v("性质 2：一棵树任意删除一条边，就会分裂成两棵树。")])]),t._v(" "),a("p",[t._v("补充说明：")]),t._v(" "),a("ul",[a("li",[t._v("把树看成图，树是一个连通图，从一个顶点可以到达图中任意一个顶点；")]),t._v(" "),a("li",[t._v("连接不同的树的任意两个顶点，会形成一棵更大的树。")])]),t._v(" "),a("h2",{attrs:{id:"证明切分定理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#证明切分定理"}},[t._v("#")]),t._v(" 证明切分定理")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxa9blrvmmj31470u0n04.jpg",alt:"",loading:"lazy"}})]),t._v(" "),a("p",[t._v("证明切分定理可以使用「反证法」，这个证明看起来就跟什么都没说一样。")]),t._v(" "),a("p",[a("strong",[t._v("证明")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("假设我们选择了横切边中不是最短的那条边（"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("e")]),a("mn",[t._v("1")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("e1")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord mathnormal"},[t._v("e")]),a("span",{staticClass:"mord"},[t._v("1")])])])]),t._v("），此时得到最小生成树；")]),t._v(" "),a("li",[t._v("由于存在最短的横切边（"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("e")]),a("mn",[t._v("2")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("e2")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord mathnormal"},[t._v("e")]),a("span",{staticClass:"mord"},[t._v("2")])])])]),t._v("），把最短的横切边加进来，"),a("strong",[t._v("就形成了一个环")]),t._v("；")]),t._v(" "),a("li",[t._v("此时我们去掉最开始选择的边（"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("e")]),a("mn",[t._v("1")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("e1")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord mathnormal"},[t._v("e")]),a("span",{staticClass:"mord"},[t._v("1")])])])]),t._v("），环有变成了一棵树，并且由于 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("e")]),a("mn",[t._v("2")]),a("mo",[t._v("<")]),a("mi",[t._v("e")]),a("mn",[t._v("1")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("e2 < e1")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6835em","vertical-align":"-0.0391em"}}),a("span",{staticClass:"mord mathnormal"},[t._v("e")]),a("span",{staticClass:"mord"},[t._v("2")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2778em"}}),a("span",{staticClass:"mrel"},[t._v("<")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2778em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord mathnormal"},[t._v("e")]),a("span",{staticClass:"mord"},[t._v("1")])])])]),t._v("，我们就找到了权值之和更小的生成树，与一开始的「最小生成树」的最小性矛盾，故对于任意切分，横切边中最短的那条边一定属于「最小生成树」。")])]),t._v(" "),a("p",[t._v("我们先说 Kruskal 算法，因为它的描述很简单，Kruskal 算法的实现需要用到并查集。然后介绍 Prim 算法，Prim 算法的实现需要用到优先队列。")])])}),[],!1,null,null,null);a.default=n.exports}}]);
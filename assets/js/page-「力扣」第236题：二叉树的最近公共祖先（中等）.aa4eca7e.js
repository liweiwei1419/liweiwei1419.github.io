(window.webpackJsonp=window.webpackJsonp||[]).push([[272],{1087:function(e,t,s){"use strict";s.r(t);var a=s(1),n=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ul",[t("li",[e._v("题目描述："),t("a",{attrs:{href:"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("236. 二叉树的最近公共祖先"),t("OutboundLink")],1),e._v("。")])]),e._v(" "),t("h2",{attrs:{id:"题目描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),t("p",[e._v("给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[e._v("百度百科"),t("OutboundLink")],1),e._v("中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),t("strong",[e._v("一个节点也可以是它自己的祖先")]),e._v("）。”")]),e._v(" "),t("p",[t("strong",[e._v("示例 1：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png",alt:"img",loading:"lazy"}})]),e._v(" "),t("div",{staticClass:"language-输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[t("strong",[e._v("示例 2：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png",alt:"img",loading:"lazy"}})]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[t("strong",[e._v("示例 3：")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：root = [1,2], p = 1, q = 2\n输出：1\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[t("strong",[e._v("提示：")])]),e._v(" "),t("ul",[t("li",[e._v("树中节点数目在范围 "),t("code",[e._v("[2, 10^5]")]),e._v(" 内。")]),e._v(" "),t("li",[t("code",[e._v("-10^9 <= Node.val <= 10^9")])]),e._v(" "),t("li",[e._v("所有 "),t("code",[e._v("Node.val")]),e._v(" "),t("code",[e._v("互不相同")]),e._v(" 。")]),e._v(" "),t("li",[t("code",[e._v("p != q")])]),e._v(" "),t("li",[t("code",[e._v("p")]),e._v(" 和 "),t("code",[e._v("q")]),e._v(" 均存在于给定的二叉树中。")])]),e._v(" "),t("h2",{attrs:{id:"思路分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思路分析"}},[e._v("#")]),e._v(" 思路分析")]),e._v(" "),t("p",[e._v("给定一棵二叉树和两个结点，寻找这两个结点的最近公共祖先。该问题是经典的 LCA 问题。在"),t("a",{attrs:{href:"https://www.liwei.party/2018/05/12/leetcode-solution/lowest-common-ancestor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1),e._v("我写了比较完整的分析过程。")])])}),[],!1,null,null,null);t.default=n.exports}}]);
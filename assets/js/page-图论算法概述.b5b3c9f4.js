(window.webpackJsonp=window.webpackJsonp||[]).push([[530],{853:function(t,a,v){"use strict";v.r(a);var _=v(1),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ul",[a("li",[t._v("《算法（第 4 版）》")]),t._v(" "),a("li",[t._v("《算法导论》")])]),t._v(" "),a("h2",{attrs:{id:"「最短路径问题」知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「最短路径问题」知识点"}},[t._v("#")]),t._v(" 「最短路径问题」知识点")]),t._v(" "),a("p",[t._v("「最短路径问题」专题要解决的问题和重点：")]),t._v(" "),a("ol",[a("li",[t._v("单源最短路径问题（Dijkstra 算法、Bellman-Ford 算法）")]),t._v(" "),a("li",[t._v("所有点对的最短路径问题（Floyd 算法）。")])]),t._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("本专栏只讲解 Dijkstra 算法和「松弛操作」。")])]),t._v(" "),a("h3",{attrs:{id:"单源最短路径问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单源最短路径问题"}},[t._v("#")]),t._v(" 单源最短路径问题")]),t._v(" "),a("ol",[a("li",[t._v("Dijkstra 算法（没有负权边的单源最短路径问题，重点讲解）")])]),t._v(" "),a("ul",[a("li",[t._v("松弛操作：重点强调由于没有负权边，因此每一轮可以确定从源点到一个顶点的最短路径")]),t._v(" "),a("li",[t._v("算法思想：贪心算法、动态规划")]),t._v(" "),a("li",[t._v("数据结构：堆（优先队列）")]),t._v(" "),a("li",[t._v("时间复杂度")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("Bellman-Ford 算法（有负权边的单源最短路径问题）")])]),t._v(" "),a("ul",[a("li",[t._v("算法思想：动态规划")]),t._v(" "),a("li",[t._v("需要讲清楚进行顶点个数 - 1 次操作是找到最短路径的上限，并且最后还要执行一次松弛操作判断是否有负权环")]),t._v(" "),a("li",[t._v("SPFA 算法的思想可以提一下，甚至可以不讲，面试肯定不会考")]),t._v(" "),a("li",[t._v("时间复杂度")])]),t._v(" "),a("h3",{attrs:{id:"所有点对的最短路径问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有点对的最短路径问题"}},[t._v("#")]),t._v(" 所有点对的最短路径问题")]),t._v(" "),a("p",[t._v("Floyd 算法其实还是松弛操作和动态规划。")]),t._v(" "),a("h2",{attrs:{id:"「最小生成树」知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「最小生成树」知识点"}},[t._v("#")]),t._v(" 「最小生成树」知识点")]),t._v(" "),a("p",[t._v("「最小生成树」专题要解决的问题：")]),t._v(" "),a("p",[t._v("找到无向图的最小生成树。")]),t._v(" "),a("h3",{attrs:{id:"切分定理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#切分定理"}},[t._v("#")]),t._v(" 切分定理")]),t._v(" "),a("p",[t._v("Kruskal 算法和 Prim 算法都利用到了「切分定理」。")]),t._v(" "),a("h3",{attrs:{id:"kruskal-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kruskal-算法"}},[t._v("#")]),t._v(" Kruskal 算法")]),t._v(" "),a("ul",[a("li",[t._v("算法思想：贪心算法")]),t._v(" "),a("li",[t._v("数据结构：并查集")])]),t._v(" "),a("h3",{attrs:{id:"prim-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prim-算法"}},[t._v("#")]),t._v(" Prim 算法")]),t._v(" "),a("ul",[a("li",[t._v("算法思想：贪心算法")]),t._v(" "),a("li",[t._v("数据结构：堆（优先队列）")])])])}),[],!1,null,null,null);a.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[632],{849:function(s,t,a){"use strict";a.r(t);var n=a(1),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[t("strong",[s._v("例：「力扣」第 124 题：二叉树中的最大路径和（困难）")])]),s._v(" "),t("p",[t("strong",[s._v("路径")]),s._v(" 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 "),t("strong",[s._v("至多出现一次")]),s._v(" 。该路径 "),t("strong",[s._v("至少包含一个")]),s._v(" 节点，且不一定经过根节点。")]),s._v(" "),t("p",[t("strong",[s._v("路径和")]),s._v(" 是路径中各节点值的总和。")]),s._v(" "),t("p",[s._v("给你一个二叉树的根节点 "),t("code",[s._v("root")]),s._v(" ，返回其 "),t("strong",[s._v("最大路径和")]),s._v(" 。")]),s._v(" "),t("p",[t("strong",[s._v("示例 1：")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxbldhfgecj30fc0ak3yl.jpg",alt:"",loading:"lazy"}})]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("strong",[s._v("示例 2：")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxbldk4gyuj30jc0f2gm0.jpg",alt:"",loading:"lazy"}})]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("strong",[s._v("提示：")])]),s._v(" "),t("ul",[t("li",[s._v("树中节点数目范围是 "),t("code",[s._v("[1, 3 * 10^4]")])]),s._v(" "),t("li",[t("code",[s._v("-1000 <= Node.val <= 1000")])])]),s._v(" "),t("p",[t("strong",[s._v("思路分析")]),s._v("：")]),s._v(" "),t("p",[s._v("首先「后序遍历」是肯定要的，因此我们写出的代码一定会有递归，并且在递归函数里：")]),s._v(" "),t("ul",[t("li",[s._v("首先写递归终止条件：")]),s._v(" "),t("li",[s._v("然后，先计算两个子树的结果，然后得到了两个子树的结果以后才与计算当前结点有关的变量的值。")])]),s._v(" "),t("p",[s._v("题目只问最大路径的和是多少，并没有要我们得到这个最大路径。这样的问题很可能需要使用「动态规划」的思想去解决。")]),s._v(" "),t("p",[s._v("而树形动态规划的状态定义没有其它动态规划那么明显，它不是画表格，它有可能：")]),s._v(" "),t("ul",[t("li",[s._v("设计在递归函数中；")]),s._v(" "),t("li",[s._v("在递归函数的返回值里设计多个变量返回。")])]),s._v(" "),t("blockquote",[t("p",[s._v("使用「动态规划」解决的问题通常都有这样的特点：「动态规划」只记录了一系列选择的结果，并不记录过程，因此「动态规划」对数据是有「压缩」的。因此我们会看到很多「动态规划」的问题只要求我们得到一个结果。并且如果做过「背包问题」的朋友就会知道，从「动态规划」的表格中，只能通过「倒序」的方式恢复满足条件的一个解，不能得到所有解。")])]),s._v(" "),t("p",[s._v("其实我们需要明确题目给出的「路径」的概念。根据示例，「路径」的形态，不只是「从上到下」或者「从下到上」，有可能有「折线」的形态。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxbldpxcwzj30oi0iowf7.jpg",alt:"",loading:"lazy"}})]),s._v(" "),t("p",[s._v("题目当中说：「同一个节点在一条路径序列中 "),t("strong",[s._v("至多出现一次")]),s._v(" 」「该路径 "),t("strong",[s._v("至少包含一个")]),s._v(" 节点」「且不一定经过根节点」，这些都是非常关键的信息。")]),s._v(" "),t("p",[s._v("因为「该路径 "),t("strong",[s._v("至少包含一个")]),s._v(" 节点」，因此我们在 "),t("strong",[s._v("设计状态")]),s._v(" 的时候就可以考虑让当前考虑的结点必须被选择。")]),s._v(" "),t("p",[s._v("在当前结点必须被选择的时候，路径可能来自左子树，也可能来自右子树，这两件事情需要分类讨论，我们对状态的定义只要求只能来自左子树和右子树中的一条路径。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxbldu4pflj316a0js0uj.jpg",alt:"",loading:"lazy"}})]),s._v(" "),t("blockquote",[t("p",[s._v("「必须经过子问题的根结点」和「只保留左子树和右子树其中一条路径」这两件事情就是「动态规划」的「无后效性」的应用。")])]),s._v(" "),t("p",[s._v("我们把不确定的、需要分类讨论的事情确定下来，以便求解。")]),s._v(" "),t("p",[s._v("我们直接给出「参考代码」，我们把需要注意的地方作为注释写在代码中，「树形 DP」与的状态设计与状态转移是隐含在递归方法里的，这一点很不一样。")]),s._v(" "),t("p",[t("strong",[s._v("参考代码")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Solution")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("maxPathSum")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TreeNode")]),s._v(" root"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        res "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Integer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("MIN_VALUE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("root"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n     * 规定 node 必须被选取\n     *\n     * @param node\n     * @return 返回必须经过 node 的不是「弯曲」的路径，即：这条路径在左子树和右子树的路径中只能选择一条\n     */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TreeNode")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("node "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 这里体现了「后序遍历」，先递归求解左、右子树")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 由于结点的值有可能为负数，因此如果子树得到的路径是负数，可以舍弃，表现为和 0 取最大值")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" leftSubTreeSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("left"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" rightSubTreeSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("right"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// node.val 必须被选择体现在这里")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 在深度优先遍历的过程中选出最大值")]),s._v("\n        res "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("val "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" leftSubTreeSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" rightSubTreeSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// node.val 必须被选择体现在这里")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("val "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("leftSubTreeSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" rightSubTreeSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br")])]),t("p",[t("strong",[s._v("时间复杂度")]),s._v("：遍历了树一次，因此时间复杂度为 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mi",[s._v("O")]),t("mo",{attrs:{stretchy:"false"}},[s._v("(")]),t("mi",[s._v("N")]),t("mo",{attrs:{stretchy:"false"}},[s._v(")")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("O(N)")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),t("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[s._v("O")]),t("span",{staticClass:"mopen"},[s._v("(")]),t("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[s._v("N")]),t("span",{staticClass:"mclose"},[s._v(")")])])])]),s._v("，这里 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mi",[s._v("N")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("N")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),t("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[s._v("N")])])])]),s._v(" 为二叉树的结点总数。")]),s._v(" "),t("p",[t("strong",[s._v("总结")]),s._v("：")]),s._v(" "),t("p",[s._v("初学树形 DP 可能会觉得比较难理解，大家不用很担心，我刚开始学习「力扣」第 337 题：打家劫舍 III 的时候，花了很长的时间，和一个扣友讨论过很多次，才理解动态规划是怎么计算的。")]),s._v(" "),t("p",[s._v("理解一个算法设计思想最好的办法还是多做题，我们下面给出的问题都采用了今天介绍的「后序遍历」和「动态规划」的思想解决。")]),s._v(" "),t("p",[t("strong",[s._v("相关问题")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("「力扣」第 337 题：打家劫舍 III（中等）；")]),s._v(" "),t("li",[s._v("「力扣」第 543 题：二叉树的直径（简单）；")]),s._v(" "),t("li",[s._v("「力扣」第 687 题：最长同值路径（中等）；")]),s._v(" "),t("li",[s._v("「力扣」第 968 题：监控二叉树（困难）；")]),s._v(" "),t("li",[s._v("「力扣」第 1372 题：二叉树中的最长交错路径（中等）。")])]),s._v(" "),t("p",[s._v("今天的问题如果是第 1 次看会很晕，如果大家觉得我哪里没有讲清楚的话，可以给我留言，我们后面还可以安排讲这里的「相关问题」，把「后序遍历」和「无后效性」多讲几次，可能就会清楚很多了。")]),s._v(" "),t("p",[s._v("感谢大家的收看，今天周五了，又是 521，祝大家天天开心！")])])}),[],!1,null,null,null);t.default=e.exports}}]);
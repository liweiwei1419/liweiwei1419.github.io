(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{1134:function(s,t,a){"use strict";a.r(t);var n=a(1),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[s._v("重点提示")]),s._v(" "),t("p",[s._v("这一节重要。")])]),s._v(" "),t("p",[s._v("代码的实现的理解有一些绕。这一版我们实现压缩更彻底的路径压缩。其实我们不看上面的分析，我们想象路径压缩的目的是什么，就是让我们的并查集表示的树结构层数更低，那么最优的情况应该是下面这样，把一棵树压缩成 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mn",[s._v("2")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("2")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),t("span",{staticClass:"mord"},[s._v("2")])])])]),s._v(" 层，所有的结点都指向一个根，这才是把一个并查集压缩到最彻底的情况。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxdw4vud2mj31300fu0th.jpg",alt:"image-20211215014749356",loading:"lazy"}})]),s._v(" "),t("p",[s._v("那么，代码又应该如何实现呢？我们需要使用递归的思想。这一版代码的实现难点就在于：应该定义 "),t("code",[s._v("find(p)")]),s._v(" "),t("strong",[s._v("返回的是 "),t("code",[s._v("p")]),s._v(" 这个结点的父结点")]),s._v("。")]),s._v(" "),t("p",[s._v("Java 代码：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 返回索引为 p 的元素的根结点\n * 理解这个方法的关键点：我们就是要把这个结点的父结点指向根结点，\n * 既然父亲结点不是根结点，我们就继续拿父亲结点找根结点\n * 一致递归找下去，\n * 最后返回的时候，写 parent[p] 是可以的\n * 写 parent[parent[p]] 也是没有问题的\n *\n * @param p\n * @return\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("find")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 在 find 的时候执行路径压缩")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("assert")]),s._v(" p "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" p "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" count"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 注意：这里是 if 不是 while，否则就变成循环")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("p "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!=")]),s._v(" parent"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 这一行代码的逻辑要想想清楚")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 只要不是根结点")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 就把父亲结点指向父亲结点的父亲结点")]),s._v("\n        parent"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("find")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("parent"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" parent"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br")])]),t("p",[s._v("最后，我们来比较一下基于路径压缩的两种方法。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxdw81l9w0j31cg0u0q8v.jpg",alt:"",loading:"lazy"}})]),s._v(" "),t("p",[s._v("并查集能够很好地帮助我们解决网络中两个结点是否连接的问题。但是，对于网络中的两个结点的路径，最短路径的问题，我们就要使用图来解决。")]),s._v(" "),t("h2",{attrs:{id:"关于路径压缩的思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于路径压缩的思考"}},[s._v("#")]),s._v(" 关于路径压缩的思考")]),s._v(" "),t("p",[s._v("写到这里，我们发现在路径压缩的过程中，我们之前引入的辅助合并的数组，不管是 "),t("code",[s._v("rank")]),s._v(" 还是 "),t("code",[s._v("size")]),s._v("，它们的定义都不准确了，因为我们在路径压缩的过程中没有对它们的定义进行维护。这一点其实并不影响我们的算法的正确性，我们不去维护 "),t("code",[s._v("rank")]),s._v(" 数组和 "),t("code",[s._v("size")]),s._v(" 数组的定义，是因为第 1 点：难于实现，第 2 点： "),t("code",[s._v("rank")]),s._v(" 数组还是 "),t("code",[s._v("size")]),s._v(" 数组的当前实现仍然可以作为一个参考值，比起随机的做法要更有意义一些。")]),s._v(" "),t("p",[s._v("其实写到这里，数组 "),t("code",[s._v("rank")]),s._v(" 还是数组 "),t("code",[s._v("size")]),s._v(" 的意义都不太重要了，我们只须要在 "),t("code",[s._v("find")]),s._v(" 的时候，做好路径压缩，把孩子结点指向父亲结点即可。")])])}),[],!1,null,null,null);t.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{804:function(s,t,a){"use strict";a.r(t);var n=a(1),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("ul",[t("li",[s._v("题目链接："),t("a",{attrs:{href:"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/",target:"_blank",rel:"noopener noreferrer"}},[s._v("124. 二叉树中的最大路径和"),t("OutboundLink")],1),s._v("。")])]),s._v(" "),t("h2",{attrs:{id:"题目描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[s._v("#")]),s._v(" 题目描述")]),s._v(" "),t("p",[t("strong",[s._v("路径")]),s._v(" 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 "),t("strong",[s._v("至多出现一次")]),s._v(" 。该路径 "),t("strong",[s._v("至少包含一个")]),s._v(" 节点，且不一定经过根节点。")]),s._v(" "),t("p",[t("strong",[s._v("路径和")]),s._v(" 是路径中各节点值的总和。")]),s._v(" "),t("p",[s._v("给你一个二叉树的根节点 "),t("code",[s._v("root")]),s._v(" ，返回其 "),t("strong",[s._v("最大路径和")]),s._v(" 。")]),s._v(" "),t("p",[t("strong",[s._v("示例 1：")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7ld1xo5j208y052q2t.jpg",alt:"img",loading:"lazy"}})]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("strong",[s._v("示例 2：")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7lfhdu3j20bz08et8q.jpg",alt:"img",loading:"lazy"}})]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("strong",[s._v("提示：")])]),s._v(" "),t("ul",[t("li",[s._v("树中节点数目范围是 "),t("code",[s._v("[1, 3 * 10^4]")])]),s._v(" "),t("li",[t("code",[s._v("-1000 <= Node.val <= 1000")])])]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("本题解介绍了这一类问题需要如何思考。最重要的思想是「"),t("strong",[s._v("后序遍历")]),s._v("」和动态规划的「"),t("strong",[s._v("无后效性")]),s._v("」。")]),s._v(" "),t("p",[s._v("如果觉得内容比较多的话，可以先看看题解最后的视频，了解程序是如何通过「后序遍历」，记录了子问题的解，从而得到原问题的解。")]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("首先我们需要理解题意。")]),s._v(" "),t("h3",{attrs:{id:"明确什么是「路径」-非常重要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#明确什么是「路径」-非常重要"}},[s._v("#")]),s._v(" 明确什么是「路径」（非常重要）")]),s._v(" "),t("p",[s._v("任意给出一棵二叉树的两个结点，路径指的是：分别从这两个结点向上走，找到 "),t("strong",[s._v("最近的公共祖先")]),s._v(" 结点而形成的路径。"),t("strong",[s._v("只有这样的定义下，路径才是唯一确定的")]),s._v("。")]),s._v(" "),t("p",[s._v("下图展示的是同一棵树，不同的结点 A 和结点 B 定义的直径（图中绿色标注的部分）。其中左图展示的路径经过了根结点，右图展示的路径不经过根结点。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7lirjwlj21hc0u076s.jpg",alt:"image.png",loading:"lazy"}})]),s._v(" "),t("p",[s._v("下面的树种绿色结点构成的部分不符合题目中路径的定义。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxizodwwsbj31hc0u0aby.jpg",alt:"image.png",loading:"lazy"}})]),s._v(" "),t("p",[s._v("也就是说："),t("strong",[s._v("路径上的每一个结点最多只与 2 条边连接")]),s._v("。")]),s._v(" "),t("blockquote",[t("p",[s._v("友情提示：确定定义非常关键，直接决定了这道问题是否有解。")])]),s._v(" "),t("h3",{attrs:{id:"无后效性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无后效性"}},[s._v("#")]),s._v(" 无后效性")]),s._v(" "),t("p",[s._v("根据「直径」的定义，这条路径一定会经过某一个结点。而最长的直径会经过哪一个结点这件事情不确定。")]),s._v(" "),t("p",[s._v("动态规划求解的思路需要考虑所有子问题，也就是 "),t("strong",[s._v("每一个结点产生的子问题都会考虑到")]),s._v("。因此我们在设计子问题的时候，就要求我们求解的 "),t("strong",[s._v("子问题")]),s._v(" 的直径 "),t("strong",[s._v("必须经过子问题表述的子树的根结点")]),s._v("。")]),s._v(" "),t("blockquote",[t("p",[s._v("在设计状态的时候，把不确定的事情确定下来，计算得到结果，是「动态规划」的设计思想「无后效性」的应用。我们想一想打家劫舍问题（「力扣」第 198 题）、最长上升子序列问题（「力扣」第 300 题）的状态定义。打家劫舍问题，某一个房间可以偷也可以不偷，我们分别求出，某一个房间被偷的时候的子问题的结果，某一个房间不被偷的时候的子问题的结果，通过比较得出最优值。")])]),s._v(" "),t("p",[s._v("另一件事情，"),t("strong",[s._v("路径可能是「直」的，也可能是「弯」的")]),s._v("。「直」和「弯」的定义如下（虽然左边「直」的看起来也很「弯」，大家看图中红字的定义哦）：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gxizohnsntj31hc0u041k.jpg",alt:"image.png",loading:"lazy"}})]),s._v(" "),t("p",[t("strong",[s._v("我们只规定子问题求解得到的路径是「直」的")]),s._v("。为什么这么规定呢？因为 "),t("strong",[s._v("「直的」情况简单，它可以组成复杂的「弯」的情况")]),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"状态定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态定义"}},[s._v("#")]),s._v(" 状态定义")]),s._v(" "),t("p",[s._v("我们规定必须经过子树的根结点，并且最大路径的和表示的路径只来自左子树和右子树 "),t("strong",[s._v("其中之一")]),s._v(" 的 "),t("strong",[s._v("最大值")]),s._v("。也就是说，这条「路径」其实只走一边。")]),s._v(" "),t("p",[s._v("我们把不确定的、需要分类讨论的事情确定下来，以便求解。")]),s._v(" "),t("h2",{attrs:{id:"为什么是「后序遍历」"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么是「后序遍历」"}},[s._v("#")]),s._v(" 为什么是「后序遍历」")]),s._v(" "),t("p",[s._v("深度优先遍历就是从根结点开始在树中转一圈，最后回到根结点。我们采用后序遍历计算结果的方式，表现为：")]),s._v(" "),t("blockquote",[t("p",[s._v("从叶子结点开始，一层一层向上传递信息，最后在根结点汇总结果。")])]),s._v(" "),t("p",[s._v("为什么是「后序遍历」呢？")]),s._v(" "),t("ul",[t("li",[s._v("因为二叉树从子结点到父结点只会有一条路径；")]),s._v(" "),t("li",[s._v("而从根结点到子节点至多会有两条路径。")])]),s._v(" "),t("p",[s._v("「后序遍历」相当于 "),t("strong",[s._v("先求得两个子问题的结果，再根据两个子问题的结果得到当前规模更大的子问题的结果")]),s._v("，这是「分而治之」的思想。")]),s._v(" "),t("h2",{attrs:{id:"题目问的结果在求解子问题的过程中得到"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目问的结果在求解子问题的过程中得到"}},[s._v("#")]),s._v(" 题目问的结果在求解子问题的过程中得到")]),s._v(" "),t("p",[s._v("我们对状态的定义规定了只来自左右子树的一边，在后序遍历的时候，左右子树的结果都求得的情况下，当前结点就可以把左右两棵子树的求解结果进行综合，就是题目要求的 "),t("strong",[s._v("经过某个结点")]),s._v(" 的最大路径和。")]),s._v(" "),t("p",[s._v("下面给出「参考代码」，我们把需要注意的地方作为注释写在代码中，「树形 DP」与的状态设计与状态转移是隐含在递归方法里的，这一点请大家留意。")]),s._v(" "),t("p",[s._v("大家可以先理解代码，代码之后有一个具体的例子，展示了代码是如何执行，并计算题目要求的结果的。")]),s._v(" "),t("p",[t("strong",[s._v("参考代码")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Solution")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("maxPathSum")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TreeNode")]),s._v(" root"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        res "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Integer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("MIN_VALUE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("root"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n     * 规定 node 必须被选取\n     *\n     * @param node\n     * @return 返回必须经过 node 的直的路径的最大和，这条路径到 node 为止，即：这条路径在左子树和右子树的路径中只能选择一条\n     */")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TreeNode")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("node "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 这里体现了「后序遍历」，先递归求解左、右子树")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 由于结点的值有可能为负数，因此如果子树得到的路径是负数，可以舍弃，表现为和 0 取最大值")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" leftSubTreeSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("left"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" rightSubTreeSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("dfs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("right"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// node.val 必须被选择体现在这里")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 在深度优先遍历的过程中选出最大值")]),s._v("\n        res "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("val "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" leftSubTreeSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" rightSubTreeSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// node.val 必须被选择体现在这里")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("val "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("max")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("leftSubTreeSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" rightSubTreeSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br")])]),t("p",[t("strong",[s._v("时间复杂度")]),s._v("：遍历了树一次，因此时间复杂度为 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mi",[s._v("O")]),t("mo",{attrs:{stretchy:"false"}},[s._v("(")]),t("mi",[s._v("N")]),t("mo",{attrs:{stretchy:"false"}},[s._v(")")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("O(N)")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),t("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[s._v("O")]),t("span",{staticClass:"mopen"},[s._v("(")]),t("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[s._v("N")]),t("span",{staticClass:"mclose"},[s._v(")")])])])]),s._v("，这里 "),t("span",{staticClass:"katex"},[t("span",{staticClass:"katex-mathml"},[t("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[t("semantics",[t("mrow",[t("mi",[s._v("N")])],1),t("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("N")])],1)],1)],1),t("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[t("span",{staticClass:"base"},[t("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),t("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[s._v("N")])])])]),s._v(" 为二叉树的结点总数。")]),s._v(" "),t("p",[s._v("下面的视频可以帮助大家理解程序是如何运行的。")]),s._v(" "),t("Presentation",{attrs:{id:"presentation-64a56f66","data-code":"%0A!%5B0124.001%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd763s0j31hc0u0di1.jpg)%0A%0A---%0A%0A!%5B0124.002%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixu45eaoj31hc0u0di1.jpg)%0A%0A---%0A%0A!%5B0124.003%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd4zhspj31hc0u0mzi.jpg)%0A%0A---%0A%0A!%5B0124.004%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd6tdikj31hc0u0di2.jpg)%0A%0A---%0A%0A!%5B0124.005%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd898cvj31hc0u0q56.jpg)%0A%0A---%0A%0A!%5B0124.006%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd7qqboj31hc0u0acc.jpg)%0A%0A---%0A%0A!%5B0124.007%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd5ypbaj31hc0u0whs.jpg)%0A%0A---%0A%0A!%5B0124.008%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd25x0qj31hc0u0di3.jpg)%0A%0A---%0A%0A!%5B0124.009%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd952vwj31hc0u0q5z.jpg)%0A%0A---%0A%0A!%5B0124.010%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd35g55j31hc0u00w0.jpg)%0A%0A---%0A%0A!%5B0124.011%5D(https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008i3skNgy1gxixd42ivuj31hc0u0wh9.jpg)%0A",theme:"[theme]"}}),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("p",[s._v("首先是理解题意，"),t("strong",[s._v("对「路径」的定义的理解非常关键")]),s._v("，直接决定了递归函数（也就是状态设计）为什么规定了「路径」只能来自其中一个子树。\n​\n然后是求解这一类问题的思想：\n​")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("后序遍历")]),s._v("：一层一层向上传递；")]),s._v(" "),t("li",[t("strong",[s._v("无后效性")]),s._v("：把不确定的因素固定下来，以便分类讨论。")])]),s._v(" "),t("p",[s._v("如果大家做过「力扣」第 53 题："),t("RouterLink",{attrs:{to:"/problems/maximum-subarray/"}},[s._v("最大子序和")]),s._v(" 就会发现，当前问题（「力扣」第 124 题） 其实是这道问题的在树上的版本。重点再说一遍：")],1),s._v(" "),t("ul",[t("li",[s._v("路径的定义；")]),s._v(" "),t("li",[s._v("后序遍历；")]),s._v(" "),t("li",[s._v("动态规划的无后效性。")])]),s._v(" "),t("h2",{attrs:{id:"同类问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同类问题"}},[s._v("#")]),s._v(" 同类问题")]),s._v(" "),t("p",[s._v("这些问题依然是先理解题目中「直径」「路径」的定义，"),t("strong",[s._v("有些问题「路径」指的是结点的个数，有些问题「路径」指的是边的条数")]),s._v("。")]),s._v(" "),t("ul",[t("li",[s._v("「力扣」第 124 题：二叉树中的最大路径和（困难，本节讲解问题）；")]),s._v(" "),t("li",[s._v("「力扣」第 337 题：打家劫舍 III（中等）；")]),s._v(" "),t("li",[s._v("「力扣」第 543 题：二叉树的直径（简单）；")]),s._v(" "),t("li",[s._v("「力扣」第 687 题：最长同值路径（中等）；")]),s._v(" "),t("li",[s._v("「力扣」第 968 题：监控二叉树（困难）；")]),s._v(" "),t("li",[s._v("「力扣」第 1372 题：二叉树中的最长交错路径（中等）；")])])],1)}),[],!1,null,null,null);t.default=e.exports}}]);
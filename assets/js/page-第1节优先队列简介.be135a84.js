(window.webpackJsonp=window.webpackJsonp||[]).push([[570],{895:function(t,a,s){"use strict";s.r(a);var i=s(1),n=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("这一部分我们介绍优先队列（Priority Queue）。")]),t._v(" "),a("h2",{attrs:{id:"「优先队列」与「堆」的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#「优先队列」与「堆」的关系"}},[t._v("#")]),t._v(" 「优先队列」与「堆」的关系")]),t._v(" "),a("ul",[a("li",[t._v("优先队列（Priority Queue）是一种「抽象的」数据结构；")]),t._v(" "),a("li",[t._v("堆（Heap）是「具体的」实现，这个系列我们只讲「二叉堆」，其它优先队列的实现不涉及。")])]),t._v(" "),a("h2",{attrs:{id:"优先队列用于解决什么样的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先队列用于解决什么样的问题"}},[t._v("#")]),t._v(" 优先队列用于解决什么样的问题")]),t._v(" "),a("p",[t._v("「优先队列」是从下面的这种场景中抽象出来的数据结构。")]),t._v(" "),a("p",[t._v("班级里要选一名同学代表全班参加程序编程竞赛，此时我们只会关心第 1 名是谁，第 1 名本人不想参赛了，或者说第 1 名因为其它因素不符合参考资格，我们才考虑第 2 名，但也是从剩下的那些同学中挑出第 1 名。")]),t._v(" "),a("p",[t._v("即当前我们 "),a("strong",[t._v("只关心当前「最优」的那个元素")]),t._v("，第 2 名及其以后的同学都不考虑了。")]),t._v(" "),a("p",[t._v("「优先队列」相对于「普通队列」而言。「普通队列」的性质是「先进先出，后进后出」。「优先队列」由元素的"),a("strong",[t._v("优先级")]),t._v("决定出队的顺序。")]),t._v(" "),a("h2",{attrs:{id:"普通队列与优先队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通队列与优先队列"}},[t._v("#")]),t._v(" 普通队列与优先队列")]),t._v(" "),a("h3",{attrs:{id:"普通队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通队列"}},[t._v("#")]),t._v(" 普通队列")]),t._v(" "),a("p",[t._v("我们知道「队列」是一种先进先出（FIFO）的数据结构，出队顺序谁先来谁先出去，有点先到先得的意思，日常生活中，随处可见的排队现象，抽象出来，就是「队列」这种数据结构。")]),t._v(" "),a("h3",{attrs:{id:"优先队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先队列"}},[t._v("#")]),t._v(" 优先队列")]),t._v(" "),a("p",[t._v("同时，在我们的生活中，有些情况下，并不是按照谁先来，谁先处理的原则来处理事情，例如，我们自己的时间管理，我们会先处理最重要或者是最紧急的事情。又或者是我们非常看不惯的一种现象是，有些服务会针对 VIP 用户优先处理。「优先队列」的思想就类似与我们处理这一类问题的思路，我们按照问题或者任务的重要程度（有的时候称之为优先级），处理觉得更重要，优先级更高的事情，而不是来一个问题就马上处理解决这个问题。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("普通队列")]),t._v(" "),a("th",[t._v("优先队列")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("先进先出，后进后出。入队的时间顺序决定了出队的顺序。")]),t._v(" "),a("td",[t._v("出队顺序与入队顺序无关，只与队列中元素的"),a("strong",[t._v("优先级")]),t._v("有关，优先级最高的元素最先出队。")])])])]),t._v(" "),a("h2",{attrs:{id:"更多「优先队列」在生活中的例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更多「优先队列」在生活中的例子"}},[t._v("#")]),t._v(" 更多「优先队列」在生活中的例子")]),t._v(" "),a("p",[t._v("「优先队列」更多地应用于动态的情况，即数据不是一开始就定好的，而是随时都有可能来新的数据，此时新数据与旧数据在一起选出「优先级」最高的那个元素。比如以下场景，重点理解「动态执行」这个概念：")]),t._v(" "),a("ol",[a("li",[t._v("医院看病：重症患者往往优先治疗，即使他是后来者；")]),t._v(" "),a("li",[t._v("操作系统：选择优先级最高的任务执行；")]),t._v(" "),a("li",[t._v("上网：服务端依次回应客户端的请求：通常也是使用优先队列，优先级高的客户端优先响应；")])]),t._v(" "),a("p",[t._v("下面是一个静态的例子：例：从 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mn",[t._v("1000000")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("1000000")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord"},[t._v("1000000")])])])]),t._v(" 个数中选出最大的 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mn",[t._v("100")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("100")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord"},[t._v("100")])])])]),t._v(" 个数。这个问题我们抽象成数学表达就是：在 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("N")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("N")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")])])])]),t._v(" 个元素中选出前 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("M")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("M")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("M")])])])]),t._v(" 个元素。")]),t._v(" "),a("ol",[a("li",[t._v("如果我们使用之前学习的排序算法，时间复杂度为："),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("N")]),a("mi",[t._v("log")]),a("mo",[t._v("⁡")]),a("mi",[t._v("N")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(N \\log N)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.1667em"}}),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.1667em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("，即先排序，再取出前 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("M")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("M")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("M")])])])]),t._v(" 个元素。此时，这个问题的时间复杂度完全由使用的排序算法决定；")]),t._v(" "),a("li",[t._v("如果我们使用优先队列，那么解决该问题的时间复杂度为："),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("N")]),a("mi",[t._v("log")]),a("mo",[t._v("⁡")]),a("mi",[t._v("M")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(N \\log M)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.1667em"}}),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.1667em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("M")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("。与使用排序算法不同之处在于，我们只要维护有 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("M")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("M")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6833em"}}),a("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10903em"}},[t._v("M")])])])]),t._v(" 个元素的数据结构就可以了。")])]),t._v(" "),a("h2",{attrs:{id:"优先队列的主要操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先队列的主要操作"}},[t._v("#")]),t._v(" 优先队列的主要操作")]),t._v(" "),a("p",[t._v("「优先队列」的主要操作有：")]),t._v(" "),a("ul",[a("li",[t._v("入队；")]),t._v(" "),a("li",[t._v("出队：把当前优先队列中优先级最高的元素拿出来。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);
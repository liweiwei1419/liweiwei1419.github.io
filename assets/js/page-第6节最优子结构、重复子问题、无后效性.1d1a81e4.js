(window.webpackJsonp=window.webpackJsonp||[]).push([[599],{785:function(t,s,v){"use strict";v.r(s);var _=v(1),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"最优子结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最优子结构"}},[t._v("#")]),t._v(" 最优子结构")]),t._v(" "),s("p",[t._v("即，较小规模的子问题的可以构成较大规模的子问题。这部分和「状态转移方程」一样去理解就好。")]),t._v(" "),s("h2",{attrs:{id:"重复子问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重复子问题"}},[t._v("#")]),t._v(" 重复子问题")]),t._v(" "),s("p",[t._v("由于有很多重复子问题，所以子问题的结果需要记录下来。")]),t._v(" "),s("h2",{attrs:{id:"无后效性-无比重要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无后效性-无比重要"}},[t._v("#")]),t._v(" 无后效性（无比重要）")]),t._v(" "),s("p",[s("strong",[t._v("学习「动态规划」，一定须要深刻理解「无后效性」")]),t._v("。「无后效性」这个概念超级超级重要。")]),t._v(" "),s("p",[t._v("很遗憾，在《算法导论》里都没有找到关于「无后效性」的解释。在李煜东的《算法竞赛进阶指南》里是这样描述「无后效性」的：")]),t._v(" "),s("div",{staticClass:"custom-block info"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("动态规划要求已经求解的子问题不受后续阶段的影响。")])]),t._v(" "),s("p",[t._v("这句话我根据经验总结如下：动态规划在解决子问题的过程中，"),s("strong",[t._v("一旦某一个子问题的求解结果确定以后，就不会再被修改")]),t._v("。重要的事情说 3 遍：求解的过程形成了一张 "),s("strong",[t._v("有向无环图")]),t._v("，求解的过程形成了一张 "),s("strong",[t._v("有向无环图")]),t._v("，求解的过程形成了一张 "),s("strong",[t._v("有向无环图")]),t._v("。")]),t._v(" "),s("p",[t._v("因此，子问题的定义就非常关键。常见的做法是：在设计状态的时候，维度定得细一点，"),s("strong",[t._v("通常表现为增加维度")]),t._v("。这样一来，新的子问题就可以比较容易参考以前计算出来的子问题的结果，以避免复杂的分类讨论。")]),t._v(" "),s("p",[t._v("无后效性这个概念一开始不理解没有关系，理解它需要我们有一些求解问题的经验。一边解决问题，一边理解概念。")])])}),[],!1,null,null,null);s.default=a.exports}}]);
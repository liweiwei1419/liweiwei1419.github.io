(window.webpackJsonp=window.webpackJsonp||[]).push([[602],{1014:function(t,o,e){"use strict";e.r(o);var r=e(1),s=Object(r.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("video",{attrs:{src:"https://suanfa8.com/files/quick-sort/6-7.mp4",controls:"controls",width:"800",height:"450"}},[t._v("\nYour browser does not support the video tag.\n")]),t._v(" "),o("p",[t._v("以下是针对特殊测试用例（有很多重复元素的输入数组）有 3 种版本的快排：")]),t._v(" "),o("ul",[o("li",[t._v("版本 1：基本快排：把等于切分元素的所有元素分到了数组的同一侧，可能会造成递归树倾斜；")]),t._v(" "),o("li",[t._v("版本 2：双指针快排：把等于切分元素的所有元素 "),o("strong",[t._v("等概率")]),t._v(" 地分到了数组的两侧，避免了递归树倾斜，递归树相对平衡；")]),t._v(" "),o("li",[t._v("版本 3：三指针快排：把等于切分元素的所有元素挤到了数组的中间，在有很多元素和切分元素相等的情况下，递归区间大大减少。")])]),t._v(" "),o("div",{staticClass:"custom-block danger"},[o("p",{staticClass:"custom-block-title"},[t._v("经验总结")]),t._v(" "),o("p",[t._v("之所以快排有这些优化，起因都是来自「递归树」的高度。"),o("strong",[t._v("关于「树」的算法的优化，绝大部分都是在和树的「高度」较劲")]),t._v("。类似的通过减少树高度、使得树更平衡的数据结构还有「二叉搜索树」优化成「AVL 树」或者「红黑树」、「并查集」的「按秩合并」与「路径压缩」。")])]),t._v(" "),o("ul",[o("li",[t._v("写对「快速排序」的技巧：保持「循环不变量」，即定义的变量在循环开始前、循环过程中、循环结束以后，都保持不变的性质，这个性质是人为根据问题特点定义的。")]),t._v(" "),o("li",[t._v("「循环不变量」的内容在《算法导论》这本书里有介绍。我个人觉得非常有用。"),o("strong",[t._v("「循环不变量」是证明算法有效性的基础，更是写对代码的保证，遵守循环不变量，是不是该写等于号，先交换还是先 "),o("code",[t._v("++")]),t._v(" ，就会特别清楚，绝对不会写错，我在编码的时候，会将遵守的「循环不变量」作为注释写在代码中")]),t._v("。")])]),t._v(" "),o("p",[t._v("快速排序丢失了稳定性，如果需要稳定的快速排序，需要具体定义比较函数，这个过程叫「稳定化」，在这里就不展开了。")]),t._v(" "),o("p",[t._v("使用「快速排序」解决的经典问题（非常重要）：")]),t._v(" "),o("ul",[o("li",[t._v("TopK 问题：「力扣」第 215 题："),o("a",{attrs:{href:"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("数组中的第 K 个最大元素"),o("OutboundLink")],1),t._v("；")]),t._v(" "),o("li",[t._v("荷兰国旗问题：「力扣」第 75 题："),o("a",{attrs:{href:"https://leetcode-cn.com/problems/sort-colors/",target:"_blank",rel:"noopener noreferrer"}},[t._v("颜色分类"),o("OutboundLink")],1),t._v("。")])])])}),[],!1,null,null,null);o.default=s.exports}}]);